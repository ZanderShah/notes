CS 341
=

An **algorithm** is a well-defined procedure to solve a computational problem.

## Review of Asymptotic Notation

$T(n) \in O(f(n))$ if and only if $\exists$ two positive constants $c, n_0$ such that $\forall n \ge n_0$, $T(n) \le c\cdot f(n)$.

Example: $T(n) = \sum_{i=0}^k a_i n^i \in O(n^k)$, $a_k > 0$.

> $$\begin{aligned}T(n) &\le \sum_{i=0}^k|a_i|n^i \\ &= n^k\sum_{i=0}^k|a_i|\end{aligned}$$
> So for $c = \sum_{i=0}^k|a_i|, n_0 = 1$, $T(n) \in O(n^k)$.

$T(n) \in \Omega(f(n))$ if and only if $\exists c, n_0 > 0$ such that $\forall n \ge n_0, T(n) \ge c\cdot f(n)$.

Example: $T(n) = \sum_{i=0}^k a_i n^i \in \Omega(n^k)$.

> Let us guess $c = \frac{a_k}{2}$.
> $$\begin{aligned}\sum_{i=0}^ka_in^i &\ge \frac{a_k}{2}n^k \\ n &\ge \sum_{i=0}^{k-1} \frac{-2a_in^i}{a_k n^{k-1}}\end{aligned}$$
> The problem is that the sum is not a constant so it cannot be $n_0$.
> $$n = \sum_{i=0}^k\left|\frac{2a_i}{a_k}\right|$$

$T(n) \in \Theta(f(n))$ if and only if $T(n) \in O(f(n))$ and $T(n) \in \Omega(f(n))$.

$T(n) \in o(f(n))$ if and only if $\forall c > 0, \exists n_0$ such that $\forall n \ge n_0 T(n) \le c \cdot f(n)$.

$T(n) \in \omega(f(n))$ if and only if $\forall c > 0, \exists n_0$ such that $\forall n \ge n_0, T(n) \ge c\cdot f(n)$.

### Limits

$T(n) \in o(f(n))$ iff $\lim_{n\to \infty}\frac{T(n)}{f(n)} = 0$.

$T(n) \in \omega(f(n))$ iff $\lim_{n\to \infty}\frac{T(n)}{f(n)} = \infty$.

$T(n) \in \Theta(f(n))$ iff $\lim_{n\to\infty}\frac{T(n)}{f(n)} = c > 0$.

## Important Summations

1. $\sum_{i=1}^n i = \frac{n}{n-1}{2} \in \Theta(n^2)$.
2. $\sum_{i=1}^n i^2 = \frac{n}{n+1}{2n + 1}{6} \in \Theta(n^3)$.
3. $\sum_{i=1}^ni^d \in \Theta(n^{d + 1})$.
4. $\sum_{i=1}^nc^i = \frac{c^{k-1} -1}{c-1} \in \begin{cases}\Theta(c^k), c > 1\\ \Theta(1), c < 1\\ \Theta(k), c = 1\end{cases}$
5. $\sum_{i=1}^n \frac{1}{i} \in \Theta(\log n)$.
6. $\log(n!) = n\log n - \Theta(n)$, by Stirling's formula.

# Reductions

> Solving a computational problem $C_1$ by using an algorithm that solves a problem $C_2$.

An equation or an inequality that describes a function $T(n)$ in terms of $T$'s value on inputs smaller than $n$ and a base case.

Example: MergeSort.

> $T(n) \le 2T(\frac{n}{2}) + 7n$, $T(2) = 2$.

## Solving Reccurences

1. Proof by induction.
2. Recursion tree method.
3. Master theorem.
    - If the input is of the form $T(n) \le aT(\frac{n}{b}) + f(n)$.

### Induction

Exampe: Median-of-Medians.

$$T(n) \le T(\frac{n}{5}) + T(\frac{7n}{10}) + n, T(1) = 1$$

> **Claim**: $T(n) \le 10n$.
>
> **Base Case**: $T(1) = 1 < 10$.
>
> **Induction Hypothesis**: $\forall k < n, T(k) \le 10k$.
>
> $$\begin{aligned}T(n) &\le \frac{10n}{5} + \frac{70n}{10} + n\\ &= 2n + 7n + n\\ &= 10\end{aligned}$$

### Master Theorem

We observed using the recursion tree method, that there are three possibilities in the overall runtime analysis.

1. Work at each level stays the same.
2. Work increases per level and work at the leaves dominate.
3. Work keeps decreasing per level and the work at the root dominates.

Assume all subproblems are of equal size.

$T(n) \le aT(\frac{n}{b}) + O(n^d), T(1) \le 1$, where $a$ is the number of recursive calls, $b$ is the input size shrinkage order, and $d$ is the exponent in the work done at the combine step.

$$T(n) \in \begin{cases}
O(n^d \log(n)),\ &a = b^d \\
O(a^{\log_b(n)}n^{\log_b(a)}),\ &a > b^d \\
O(n^d),\ &a < b^d \\
\end{cases}$$

**Proof**. Assume for simplicity that $n$ is a power of $b$. We have $\log_b(n)$ levels, with $a^{\log_b(n)}$ leaves. The total work done at each level $j$ is $a^j(\frac{n}{b})^d$ so the total work is.

$$\begin{aligned}\sum_{j=0}^{\log_b(n)}a^j\frac{n^d}{b^{jd}} &= cn^d\sum_{j=0}^{\log_b(n)} \left(\frac{a}{b^d}\right)^j\end{aligned}$$

We can obtain the runtimes by checking the convergence of the above sum.

## 2D Maxima

**Input**: Set $P$ of $n$ 2D points.

**Output**: All maximal points. $p$ is maximal if there is no such $p^\prime$ that dominates $p$ ($p^\prime.x > p.x \cap p^\prime.y > p.y)$.

# A1 Hint Aside

1. Implement locks.
2. Implement condition variables.
3. Traffic simulation.
    - Improve flow of cars through the intersecation, currently only implements one car at a time.
    - Modify synchonization with locks, CVs, semaphores.
        - Semaphores are not recommended. CVs are.
- You **don't** need an individual lock for each CV.
- You are not going to own the lock as you go through the intersection.
- Need to check safely whether the car can enter the intersection and safely remove once they are out of the intersection.
    - Lock is used to protect the modification of the intersection, not for actually going through.
- Recommended number of CVs is **4**.

Multiple ways to to keep track of where cars are in the intersection.

- OS/161 provides an array, queue, and a few other data structure libraries. Documentation can be found in the test directory.
    - Possible to do with simply counters.
- Can't use wait channels directly.
- Don't modify traffic.c

> **sy2, uw1, sy3** are the tests to run.

- Initialize your lock variables for CV.

## Volatile and Race Conditions

- Race conditions are mostly your fault, but they can also come from the **compiler** and **CPU**.
    - Optimizations.
    - **Memory models** describe how threads access to memory in shared regions behave. Tells compiler and CPU which optimizations can be performed.
        - OS/161 does not have this.
        - CPU also has memory model which re-orders loads and stores. There are assembly level barriers to prevent race conditions at each level.
    - Register optimizations.
- Keyword **volatile** disables the optimizations forcing a value to be loaded and stored to memory with each use. Prevents compiler from re-ordering loads and stores for that variable.

## Deadlocks

    lock lock_a, lock_b

    int FuncA() {
        lock_acquire(lock_a);
        lock_acquire(lock_b);
        ...
        lock_release(lock_a);
        lock_relase(lock_b);
    }

    int FuncB() {
        lock_acquire(lock_b);
        lock_acquire(lock_a);
        ...
        lock_relase(lock_b);
        lock_release(lock_a);
    }

- Multiple threads are asleep waiting for each other. **Deadlock**.

1. **No Hold and Wait**. Prevent a thread from requesting resources if it currently has resources allocated to it. Either get them all at once, or have none.
2. **Resource Ordering**. Order the resource types and require each thread acquire resources in increasing type order.

Example.

    lock A, B

    try_acquire() {
        spin_acquire(lk->spin);
        if (lk->held) {
            release(lk->spin);
            return false;
        }
        lk->held = true;
        lk->owner = me;
        release(lk->spin);
        return true;
    }

    FuncA() {
        acquire(A)
        while(!try_acquire(B)) {
            release(A);
            acquire(A);
        }
    }
