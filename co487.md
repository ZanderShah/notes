CO 487
=

## Fundamental Goals of Cryptography

- **Confidentiality**: Keeping data secret from all not authorized.
- **Data Integrity**: Ensure data has not been altered by unauthorized means.
- **Data Origin Authentication**: Corroborating the source of data.
- **Non-Repudiation**: Prevents entity from denying previous commitments or actions.

**Symmetric-key cryptography**: The **client** and **server** share some **secret** information $k$, called a **key**.

**Public-key cryptography**: Share an **authenticated** (but not secret) information.

### SSL Protocol

1. Server transmits **certificate** to client.
    - Contains server's identifying information, with **RSA** public key and signature of **certifying authority**.
    - Certifying authority is trusted.
2. Client **verifies** signature to verify **authenticity**.
3. Client selects random key $k$ and **encrypts** with server's RSA public key, transmits ciphertext to server.
4. Server **decrpyts** ciphertext.

Is SSL **really** secure?

There are many potential security vulnerabilities.

1. Crypto is weak (e.g. AES, HMAC, RSA).
2. **Quantum attacks** on underlying cryptography.
3. Weak random number generation.
4. Fraudulent certificates.
    - Mistakes due to human error.
5. Software bugs (both inadvertent and malicious).
6. **Phishing** attacks.
7. SSL only protects data during transit, does not protect data when it is collected at the server.

Crypto might be strong, but **information security** is more difficult (**cybersecurity**).

- Cryptography providers some mathematical tools to assist, but it is a **small** part of the entire solution.

## Symmetric-key Encryption Scheme

- $M$, plaintext space.
- $C$, ciphertext space.
- $K$, key space.
- A family of encryption functions $E_k: M \to C, \forall k \in K$.
- A family of decryption functions $D_k: C \to M, \forall k \in K$.

> Such that $D_k(E_k(m)) = m$.

1. Alice and Bob agree on a **secret** key over a **secure channel**.
2. Alice computes $c = E_k(m)$ and sends over the **unsecure channel**.
3. Bob retrieves plaintex by computing $m = D_k(c)$.

Why not always use the secure channel? It is commonly slow, inconvenient.

### What does security mean for a SKES?

1. What is the adversary's goal?
2. What are the computational powers?
3. How does the adversary interact with the two communicating parties?

**Security model**: Defines the computational abilities of the adversary, and how she interacts.

**Basic assumption**: Adversary knows everything about the SKES, only missing the key $k$.

### Adversary's Interaction

1. Passive Attacks.
    - **Ciphertext-only attack**. The attacker knows some ciphertext.
    - **Known-plaintext attack**. Knows some plaintext and corresponding ciphertext.
2. Active Attacks.
    - **Chosen-plaintext attack**. Adversary chooses plaintext and obtains corresponding ciphertext.

Attacks which are not considered in this course.

- **Clandestine attacks**. Bribery, blackmail.
- **Side-channel attacks**. Monitor encryption and decryption equipment. Timing attacks, power analysis, electromagnetic radiation analysis.

### Computational Power of Adversary

- **Information-theoretic security**: Eve has infinite computational resources.
- **Complexity-theoretic security**: Eve is a *polynomial-time Turing machine*.
- **Computational security**: Eve has a specific computational bound.

### Adversary's Goal

1. Recover the secret key.
2. Systematically recover plaintext from secret text. May not necessarily need the secret key.
3. Learn **some** partial information about the plaintext from the ciphertext.


> We want to guard against the **strongest** attacker going for the **weakest** goal.

- If the attacker can achieve 1 or 2, the SKES is said to be **totally insecure**.
- If attacker cannot learn anything, it is said to be **semantically secure**.

A SKES is said to be **secure** if it is semantically secure against a chosen-plaintext attack by a computational bounded adversary.

To **break** a SKES, the attacker needs to do the following.

1. Given a challenge ciphertext $c$.
2. Select plaintexts and obtain corresponding ciphertexts.
3. After a feasible amount of computation, obtain information about plaintext $m$ corresponding to the challenge ciphertext $c$.

## Work Factor

- $2^{40}$ operations **very easy**.
- $2^{56}$ operations **easy**.
- $2^{64}$ operations **feasible**.
- $2^{80}$ operations **barely feasible**.
- $2^{128}$ operations **infeasible**.

> The Bitcoin network is presently performing hash operations at the rate of $2^{65}$ per second, $2^{90}$ per year.

> The **Laundeur limit** from thermodynamics proposes that exhaustively trying $2^{128}$ symmetric keys would require more power for a year than the world produces.

## Security Level

A cryptographic scheme is said to have a **security level** of $l$ bits if the fastest known attack on the scheme takes approximately $2^l$ operations. As of 2019, a security level of **128 bits** is desirable in practice.

## Polyalphabtic Ciphers

> **Basic Idea**. Use several permutations, plaintext encrypted to one of several possible cipher letters.

Example: **Vigenere Cipher**.

- **Security key** is an English word having no repeated letters.
- Totally insecure against a chosen-plaintext attack, you can send single letters at a time.

### The One-Time Pad

- Key is a **random** string of letters as long as the plaintext.
- Add the key character to the plaintext character modulo 26.

If the key is shorter than the ciphertext, the key **should not** be re-used.

- If $c_1 = m_1 + k$ and $c_2 = m_2 + k$ then $c_1 - c_2 = m_1 - m_2$.
- So $c_1 - c_2$ depends only on the plaintext and hence can leak information about the plaintext.

- **Perfect secrecy**. One-time pad is semantically secure against ciphertext-only attacks by an adversary with infinite computational resources.
- Formally proven using concepts from information theory.
- It is not useful unless the key is at least as long as the plaintext, so we should use a **stream cipher**.

## Stream Ciphers

Use a **pseudorandom** generator PRBG (Pseudo-Random Bit Generator).

- The **seed** is the **secret key** shared between communicating parties.
- Security depends on the quality of the PRBG.
- The keystream should be indistinguishable from a random sequence (**indistinguishability requirement**).
- If an adversary knows a portion of the ciphertext and corresponding plaintext, they can easily find the corresponding portion of the keystream. Thus, given portions of the keystream, it should be infeasible to learn any information about the rest of the keystream (**unpredictability requirement**).
