<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>co487</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="co-487">CO 487</h1>
<h2 id="fundamental-goals-of-cryptography">Fundamental Goals of Cryptography</h2>
<ul>
<li><strong>Confidentiality</strong>: Keeping data secret from all not authorized.</li>
<li><strong>Data Integrity</strong>: Ensure data has not been altered by unauthorized means.</li>
<li><strong>Data Origin Authentication</strong>: Corroborating the source of data.</li>
<li><strong>Non-Repudiation</strong>: Prevents entity from denying previous commitments or actions.</li>
</ul>
<p><strong>Symmetric-key cryptography</strong>: The <strong>client</strong> and <strong>server</strong> share some <strong>secret</strong> information <span class="math inline">k</span>, called a <strong>key</strong>.</p>
<p><strong>Public-key cryptography</strong>: Share an <strong>authenticated</strong> (but not secret) information.</p>
<h3 id="ssl-protocol">SSL Protocol</h3>
<ol type="1">
<li>Server transmits <strong>certificate</strong> to client.
<ul>
<li>Contains server’s identifying information, with <strong>RSA</strong> public key and signature of <strong>certifying authority</strong>.</li>
<li>Certifying authority is trusted.</li>
</ul></li>
<li>Client <strong>verifies</strong> signature to verify <strong>authenticity</strong>.</li>
<li>Client selects random key <span class="math inline">k</span> and <strong>encrypts</strong> with server’s RSA public key, transmits ciphertext to server.</li>
<li>Server <strong>decrpyts</strong> ciphertext.</li>
</ol>
<p>Is SSL <strong>really</strong> secure?</p>
<p>There are many potential security vulnerabilities.</p>
<ol type="1">
<li>Crypto is weak (e.g. AES, HMAC, RSA).</li>
<li><strong>Quantum attacks</strong> on underlying cryptography.</li>
<li>Weak random number generation.</li>
<li>Fraudulent certificates.
<ul>
<li>Mistakes due to human error.</li>
</ul></li>
<li>Software bugs (both inadvertent and malicious).</li>
<li><strong>Phishing</strong> attacks.</li>
<li>SSL only protects data during transit, does not protect data when it is collected at the server.</li>
</ol>
<p>Crypto might be strong, but <strong>information security</strong> is more difficult (<strong>cybersecurity</strong>).</p>
<ul>
<li>Cryptography providers some mathematical tools to assist, but it is a <strong>small</strong> part of the entire solution.</li>
</ul>
<h2 id="symmetric-key-encryption-scheme">Symmetric-key Encryption Scheme</h2>
<ul>
<li><span class="math inline">M</span>, plaintext space.</li>
<li><span class="math inline">C</span>, ciphertext space.</li>
<li><span class="math inline">K</span>, key space.</li>
<li>A family of encryption functions <span class="math inline">E_k: M \to C, \forall k \in K</span>.</li>
<li>A family of decryption functions <span class="math inline">D_k: C \to M, \forall k \in K</span>.</li>
</ul>
<blockquote>
<p>Such that <span class="math inline">D_k(E_k(m)) = m</span>.</p>
</blockquote>
<ol type="1">
<li>Alice and Bob agree on a <strong>secret</strong> key over a <strong>secure channel</strong>.</li>
<li>Alice computes <span class="math inline">c = E_k(m)</span> and sends over the <strong>unsecure channel</strong>.</li>
<li>Bob retrieves plaintex by computing <span class="math inline">m = D_k(c)</span>.</li>
</ol>
<p>Why not always use the secure channel? It is commonly slow, inconvenient.</p>
<h3 id="what-does-security-mean-for-a-skes">What does security mean for a SKES?</h3>
<ol type="1">
<li>What is the adversary’s goal?</li>
<li>What are the computational powers?</li>
<li>How does the adversary interact with the two communicating parties?</li>
</ol>
<p><strong>Security model</strong>: Defines the computational abilities of the adversary, and how she interacts.</p>
<p><strong>Basic assumption</strong>: Adversary knows everything about the SKES, only missing the key <span class="math inline">k</span>.</p>
<h3 id="adversarys-interaction">Adversary’s Interaction</h3>
<ol type="1">
<li>Passive Attacks.
<ul>
<li><strong>Ciphertext-only attack</strong>. The attacker knows some ciphertext.</li>
<li><strong>Known-plaintext attack</strong>. Knows some plaintext and corresponding ciphertext.</li>
</ul></li>
<li>Active Attacks.
<ul>
<li><strong>Chosen-plaintext attack</strong>. Adversary chooses plaintext and obtains corresponding ciphertext.</li>
</ul></li>
</ol>
<p>Attacks which are not considered in this course.</p>
<ul>
<li><strong>Clandestine attacks</strong>. Bribery, blackmail.</li>
<li><strong>Side-channel attacks</strong>. Monitor encryption and decryption equipment. Timing attacks, power analysis, electromagnetic radiation analysis.</li>
</ul>
<h3 id="computational-power-of-adversary">Computational Power of Adversary</h3>
<ul>
<li><strong>Information-theoretic security</strong>: Eve has infinite computational resources.</li>
<li><strong>Complexity-theoretic security</strong>: Eve is a <em>polynomial-time Turing machine</em>.</li>
<li><strong>Computational security</strong>: Eve has a specific computational bound.</li>
</ul>
<h3 id="adversarys-goal">Adversary’s Goal</h3>
<ol type="1">
<li>Recover the secret key.</li>
<li>Systematically recover plaintext from secret text. May not necessarily need the secret key.</li>
<li>Learn <strong>some</strong> partial information about the plaintext from the ciphertext.</li>
</ol>
<blockquote>
<p>We want to guard against the <strong>strongest</strong> attacker going for the <strong>weakest</strong> goal.</p>
</blockquote>
<ul>
<li>If the attacker can achieve 1 or 2, the SKES is said to be <strong>totally insecure</strong>.</li>
<li>If attacker cannot learn anything, it is said to be <strong>semantically secure</strong>.</li>
</ul>
<p>A SKES is said to be <strong>secure</strong> if it is semantically secure against a chosen-plaintext attack by a computational bounded adversary.</p>
<p>To <strong>break</strong> a SKES, the attacker needs to do the following.</p>
<ol type="1">
<li>Given a challenge ciphertext <span class="math inline">c</span>.</li>
<li>Select plaintexts and obtain corresponding ciphertexts.</li>
<li>After a feasible amount of computation, obtain information about plaintext <span class="math inline">m</span> corresponding to the challenge ciphertext <span class="math inline">c</span>.</li>
</ol>
<h2 id="work-factor">Work Factor</h2>
<ul>
<li><span class="math inline">2^{40}</span> operations <strong>very easy</strong>.</li>
<li><span class="math inline">2^{56}</span> operations <strong>easy</strong>.</li>
<li><span class="math inline">2^{64}</span> operations <strong>feasible</strong>.</li>
<li><span class="math inline">2^{80}</span> operations <strong>barely feasible</strong>.</li>
<li><span class="math inline">2^{128}</span> operations <strong>infeasible</strong>.</li>
</ul>
<blockquote>
<p>The Bitcoin network is presently performing hash operations at the rate of <span class="math inline">2^{65}</span> per second, <span class="math inline">2^{90}</span> per year.</p>
</blockquote>
<blockquote>
<p>The <strong>Laundeur limit</strong> from thermodynamics proposes that exhaustively trying <span class="math inline">2^{128}</span> symmetric keys would require more power for a year than the world produces.</p>
</blockquote>
<h2 id="security-level">Security Level</h2>
<p>A cryptographic scheme is said to have a <strong>security level</strong> of <span class="math inline">l</span> bits if the fastest known attack on the scheme takes approximately <span class="math inline">2^l</span> operations. As of 2019, a security level of <strong>128 bits</strong> is desirable in practice.</p>
<h2 id="polyalphabtic-ciphers">Polyalphabtic Ciphers</h2>
<blockquote>
<p><strong>Basic Idea</strong>. Use several permutations, plaintext encrypted to one of several possible cipher letters.</p>
</blockquote>
<p>Example: <strong>Vigenere Cipher</strong>.</p>
<ul>
<li><strong>Security key</strong> is an English word having no repeated letters.</li>
<li>Totally insecure against a chosen-plaintext attack, you can send single letters at a time.</li>
</ul>
<h3 id="the-one-time-pad">The One-Time Pad</h3>
<ul>
<li>Key is a <strong>random</strong> string of letters as long as the plaintext.</li>
<li>Add the key character to the plaintext character modulo 26.</li>
</ul>
<p>If the key is shorter than the ciphertext, the key <strong>should not</strong> be re-used.</p>
<ul>
<li>If <span class="math inline">c_1 = m_1 + k</span> and <span class="math inline">c_2 = m_2 + k</span> then <span class="math inline">c_1 - c_2 = m_1 - m_2</span>.</li>
<li><p>So <span class="math inline">c_1 - c_2</span> depends only on the plaintext and hence can leak information about the plaintext.</p></li>
<li><strong>Perfect secrecy</strong>. One-time pad is semantically secure against ciphertext-only attacks by an adversary with infinite computational resources.</li>
<li>Formally proven using concepts from information theory.</li>
<li><p>It is not useful unless the key is at least as long as the plaintext, so we should use a <strong>stream cipher</strong>.</p></li>
</ul>
<h2 id="stream-ciphers">Stream Ciphers</h2>
<p>Use a <strong>pseudorandom</strong> generator PRBG (Pseudo-Random Bit Generator).</p>
<ul>
<li>The <strong>seed</strong> is the <strong>secret key</strong> shared between communicating parties.</li>
<li>Security depends on the quality of the PRBG.</li>
<li>The keystream should be indistinguishable from a random sequence (<strong>indistinguishability requirement</strong>).</li>
<li>If an adversary knows a portion of the ciphertext and corresponding plaintext, they can easily find the corresponding portion of the keystream. Thus, given portions of the keystream, it should be infeasible to learn any information about the rest of the keystream (<strong>unpredictability requirement</strong>).</li>
</ul>
<h3 id="rc4-stream-cipher">RC4 Stream Cipher</h3>
<ul>
<li>Very simple, fast, variable key lengths. No catastrophic weaknesses have been found.</li>
<li>Two components, <strong>key scheduling algorithm</strong>, <strong>keystream generator</strong>.</li>
</ul>
<h4 id="rc4-key-scheduling-algorithm">RC4 Key Scheduling Algorithm</h4>
<blockquote>
<p><span class="math inline">K[i], \overline{K}[i], S[i]</span> are bytes.</p>
</blockquote>
<p><strong>Input</strong>: Secret key <span class="math inline">K[0], K[1], ..., K[d-1]</span>.</p>
<p><strong>Output</strong>: 256-long array: <span class="math inline">S[0], S[1], ..., S[255]</span>.</p>
<pre><code>for i in range(256):
    S[i] = i
    K2[i] = K[i % d]
j = 0
for i in range(256):
    j = (K2[i] + S[i] + j) % 256
    S[i], S[j] = S[j], S[i] </code></pre>
<p><strong>Idea</strong>: <span class="math inline">S</span> is a “random-looking” permutation of <span class="math inline">\{0, 1, ..., 255\}</span> which is generated from the secret key.</p>
<h4 id="rc4-keystream-generator">RC4 Keystream Generator</h4>
<p><strong>INput</strong>: 256-long byte array <span class="math inline">S[0], S[1], ..., S[255]</span>.</p>
<p><strong>Output</strong>: Keystream.</p>
<pre><code>i = 0, j = 0
while keystream_bytes_are_required:
    i = (i + 1) % 256
    j = (S[i] + j) % 256
    S[i], S[j] = S[j], S[i]
    t = (S[i] + S[j]) % 256
    output(t)</code></pre>
<p><strong>Encryption</strong>: Keystream bytes are xored with the plaintext bytes.</p>
<p>Fluhrer-Mantin-Shamir attack exploits known biases in the first few bytes of the keystream. Defeated by discarding the first few bytes.</p>
<p>Because of several new weaknesses, RC4 is no longer used in applications such as SSL. Instead, use AES-CTR.</p>
<h2 id="wireless-security">Wireless Security</h2>
<blockquote>
<p>More attack opportunities, no physical access. Attackers can be at a distance and leave no physical evidence of attack.</p>
</blockquote>
<ul>
<li>IEEE 802.11 standard includes protocol called <strong>Wired Equivalent Privacy</strong>.
<ul>
<li>WEP’s goal is (only) to protect link-level data during wireless transmission between mobile stations and access points.</li>
</ul></li>
</ul>
<ol type="1">
<li><strong>Confidentiality</strong>: Prevent against casual eavesdropping.
<ul>
<li>RC4 used for encryption.</li>
</ul></li>
<li><strong>Data Integrity</strong>: Prevent tampering with transmitted messages.
<ul>
<li>Checksum.</li>
</ul></li>
<li><strong>Access Control</strong>: Protect access to a wireless network infrastructure.
<ul>
<li>Discard all packets that are not properly encrypted.</li>
</ul></li>
</ol>
<p>Mobile stations share a key <span class="math inline">k</span> with access points. Messages are divided into <strong>packets</strong> of some fixed length. WEP uses a <strong>per-packet 24-bit initialization vector (IV)</strong> <span class="math inline">v</span> to process each packet. <span class="math inline">v</span> is prepended to the key to generate the keystream.</p>
<p><strong>Question</strong>: Are confidentiality, data integrity, and access control achieved?</p>
<p>Since there are only <span class="math inline">2^{24}</span> choices for IV, collisions are guaranteed after enough time. If they are selected randomly, then one can expect a collision after <span class="math inline">2^{12}</span> packets. This allows attackers to obtain multiple messages with the same <span class="math inline">v</span>, so they can obtain <span class="math inline">m_1 \oplus m_2</span>.</p>
<p>It is also easy to make controlled changes to encrypted packets without invalidating the checksum.</p>
<ul>
<li>Suppose <span class="math inline">(v, c)</span> is an encrypted packet.</li>
<li>Let <span class="math inline">c = RC4(v || k) \oplus (m||S)</span>, where <span class="math inline">k, m, S</span> are unknown.</li>
<li>Let <span class="math inline">m^\prime = m \oplus \Delta</span> where <span class="math inline">\Delta</span> is a bit string where 1s correspond to bits of <span class="math inline">m</span> an attacker wishes to change.</li>
<li><span class="math inline">c^\prime = c \oplus (\Delta || CRC(\Delta))</span>. Then <span class="math inline">(v, c^\prime)</span> is a valid encrypted packet.</li>
</ul>
<p>Knowledge of one plaintext <span class="math inline">m</span> corresponding to <span class="math inline">(v, c)</span> allows an attacker to compute a valid encrypted packet for any plaintext with the same keystream.</p>
<h2 id="block-ciphers">Block Ciphers</h2>
</body>
</html>
