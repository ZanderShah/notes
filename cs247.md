CS 247
=

```c++
#include <iostream>
using namespace std;

int main() {
    Rational r, s;
    cout << "Enter rational number (a/b): ";
    cin >> r;
    cout << "Enter rational number (a/b): ";
    cin >> s;

    Rational t(r + s);
    cout << r + s << endl;
    cout << r * s << endl;
    cout << r == s << endl;
}
```

- Default / copy constructors.
    ```c++
    // Using MIL (member initialization list).
    Rational::Rational(int num, int den) : numerator_(num), denominator_(den) {
        // !den <=> den == 0
        if (!den) throw "Divide by zero!";
    };

    Rational::Rational(int num) : numerator_(num), denominator_(1) {};

    Rational::Rational() : numerator_(0), denominator_(1) {};

    // But we can instead use default arguments which would look like ...
    class Rational {
    public:
        Rational(int num = 0, int den = 1) : numerator_(num), denominator_(den) {
            if (!den) throw "Divide by zero!";
        };
    };
    // This will allow for implicit conversions which may be unintuitive to the user so we can denote it with "explicit".
    ```
- Operators.
    ```c++
    Rational operator+(const Rational &lhs, const Rational &rhs) {
        // Code for adding two rationals together.
        // Two options. We can write mutators / accessors or friend function.
        return Rational(...);
    }
    ```
    **General rule**: If it doesn't need to be a member function then it shouldnt.

    We passed our operand as a const l-value reference.
    - Behaves like a "const pointer with automatic dereferencing".

### Rules for Function Overloading
- Must differ in type or number of parameters.
- Can't differ by only return type.

**Accessors (*getters*)**: Methods that return the value of a member field.     
**Mutators (*setters*)** :Methods that allow for the setting of member fields.

These restrict the usage of member fields to only those we give access to through the public interface. They also allow usage of member fields only under our ADT's terms / supervision.

### Common Naming Conventions
- attribute, getAttribute(), setAttribute().
- attribute_, attribute(), attributeIs().

## Should it be a member?
> Only if it has to be.
- Constructors, destructors, accessors, mutators.
- Virtual methods.
- Cannot be written with only our ADT's provided public interface (need's access to internals).
    - Could also be a friend. Usually only if it can't be a member function.
- Certain operators (as per C++ standard) must be members.
    - operator=, operator[], operator(), operator->, operator T (where T is a type).
- Certain functions can't / shouldn't be members.
    - Input and output operators.
    ```c++
    class Rational {
        istream &operator>> (istream &in) {
            // Read from in;
            return in;
        }
    };

    int main() {
        Rational r;
        // If we defined operator>> as above.
        r >> cin;
        // We also would not be able to chain reasonably.
        Rational rr;
        rr >> (r >> cin);
        // So we want to stream to be the left-hand side operand.
    }
    ```
    ```c++
    istream &operator>>(istream &in, Rational &r) {
        char slash;
        int n, d;
        in >> n >> slash >> d;
        r.numeratorIs(n);
        r.denominatorIs(d);
        return in;
    }

    ostream &operator<<(ostream &out, const Rational &r) {
        // We need to make sure that the accessors are declared const.
        out << r.numerator() << '/' << r.denominator();
        return out;
    }
    ```
- In general, prefer **non-member**, **non-friend** functions.
    - Offers better encapsulation.
    - Compiler ensures accesses cannot be made to private components.
    - More flexible packaging of data because you can put declarations of standalone functions wherever you want.
- If a member function needs full access and can't be a member function, then make it a **friend**.

Classes can also be friends. This is often used when we have nested classes. Alternatively, if nested class is private, it could just be a struct with full public visibility.

```c++
class Stack {
public:
    Stack();
    ~Stack();
    void push(int n);
    int pop();
    int peek();

    class Node {
        friend class Stack;
    public:
        Node(int data, Node *next);
        Node(const Node& other);
        Node &operator=(const Node &other);
        ~Node();
    private:
        int data_;
        Node *next_;
    };

private:
    Node *top_;
};
```
> Node can be private (and should be in this case) but there are some cases in which the we want the user to access the class but not the constructor (we can just make the constructor private).
```c++
Node::Node(int data, Node *next) : data_(data), next_(next) {}

// Built in copy-constructor copies all values (byte-wise) of built in types and for any object fields, calls copy-constructor. For our case, it would only be a shallow copy (next node would be shared).
Node::Node(const Node &other) : data_{data}, next_{other.next_ ? new Node(*other.next_) : nullptr} {}

Node& Node::operator=(const Node &other) {
    // Self-assignment check.
    if (this == &other) return *this;

    // We need to allocate the memory before just in case new throws an exception.
    Node *tmp = other.next_ ? new Node(*other.next_) : nullptr;

    data_ = other.data_;
    delete next;
    next_ = tmp;

    return *this;
}

Node::~Node() {
    // Calling delete on nullptr is safe
    delete next_;
}
```
## Copy and Swap Idiom
```c++
class Node {
    ...
private:
    void swap(Node &n);
}
```
```c++
#include <utility>

void Node::swap(Node &other) {
    std::swap(data_, other.data_);
    std::swap(next_, other.next_);
}

Node& Node::operator=(const Node &other) {
    // Destructor for tmp will get called which does the clean-up for us.
    Node tmp{other};
    swap(tmp);
    return *this;
}
```

## Lvalue References
```c++
Node plusOne(Node n) {
    for (Node *p = &n; p; p = p->next()) {
        p->dataIs(p->data() + 1);
    }
    return n;
}
int main() {
    Node n = new Node{0, new Node{1, new Node{2, nullptr}}};
    // m will have to be deep copied from plusOne(n).
    Node m = plusOne(n);
}
```
> lvalue is anything with a memory address.  
> rvalues are temporary objects.

To create a reference to an rvalue, you use &&. Now, we have a new important constructor and assignment operator.

```c++
class Node {
    ...
    Node(Node &&other);
    Node &operator=(Node &&other);
};

Node::Node(Node &&other) : data_(other.data_), next_(other.next_) {
    // Need to set to nullptr so that the destructor doesn't destroy the data we stole.
    other.next_ = nullptr;
}

Node & Node::operator=(Node &&other) {
    swap(other);
    return *this;
}
```

## C++ Gives You
1. Default constructor (*disappears as soon as any other constructor is written*).
2. Copy constructor (*copies all fields*).
3. Destructor (*does nothing*).
4. Copy assignment operator (*copy assign all fields*).
5. Move constructor (*identical to built in copy constructor, disappears if you write a copy constructor*).
6. Move assignment operator (*same thing but with copy assignment operator*).

## When Are Defaults Insufficient?
- When you own a resource.
- You have logical / semantic meaning to these operations / your objects.
- **Big 5**: {copy constructor, move constructor, copy assignment operator, move assignment operator, destructor};
    - Rule of thumb is that if you need 1, you need all 5.

Compilers can leave out copy / move constructors and call the basic constructor in the right memory location.

## Entity vs. Value Objects
> Does the object represent something in the real world or is it just an attribute that describes the state?

### Entity Object
- Computer embodiment of a real world entity.
- Each object has a distinct entity.
- Objects with same attribute values does not imply they are the same.

Examples:
> **Physical objects**: airplane, runway, taxiway.  
> **People**: passengers, booking attendant.    
> **Records**: customer info, flight schedule, boarding pass.   
> **Transactions**: reservations, cancellations, reciepts.

### Value Object
- Value objects simply represent a value in our ADT.
- Value objects with same attribute values are considered to be identical.

Example: Consider a video blackgack game. Which of the following should be implemented as entity or value objects?
- **Card**: Entity
- **Deck**: Entity
- **Hand**: Entity
- **Player**: Entity
- **Score**: Value

The distinction between entity and value objects is important because it defines how we use the object, and in turn, how we write the class.

### Design of Entity ADTs
An operation on an entity object should represent a real life event.
- Prohibit copy construtor.
- Prohibit assignment.
- Prohibit type conversions.
- Avoid equality (except of attributes).
- Clone operation may be useful.
- Computations on entities are generally not meaningful.
- Think twice about overloading operators for your entity classes other than new and delete.
- operator< may be useful if it operates on name or some unique id.
- Refer to entity objects through pointer or reference.
- May allow moves ...
- Construction of a new object should reflect a new object in real life.

### Prohibiting Copy Constructor
- Previous to c++11, declare private and don't implement.
- From c++11 onwards, we can delete it.
```c++
class X {
public:
    X(const & x) = delete;
    X & operator=(const & x) = delete;
};
```

### Design of Value ADTs
- Equality **is** important in value types.
    - May be non-trivial (e.g. Matrix).
- Copy constructor, assignment operator.
- Virtual methods / inheritance is uncommon.

## Mutable vs. Immutable
- Mutable objects can cause problems when they are referenced by more than one variables.

Entity objects are usually mutable. Their attributes can change via mutators.

Value based objects should be immutable. Instead, variables of the ADT are assigned to different objects (reassignment). All field types should be primitive or immutable types.

### Writing Immutable ADTs
- **No** mutators.
- Fields should be private.
- Make sure methods don't get overwritten or class at all.
- Declare class *final* (strong immutability).
    - Or declare methods *final*.

## Static Members
- You can declare fields of a class and methods static.
- Shared across objects of that class, tied / global to class scope.

# Singleton Design (Anti) Pattern
- The singleton pattern is used when we have a class for which we only ever want one instance of that class and the object is used across much of the system.
    - Valid example would be a settings class for an application / game.
- It is better design to just pass the class around where it is needed.
```c++
class Egg {
    static Egg e; // Singleton Object.

    int i;
    Egg(int ii) : i(ii) {} // Private Constructor.

public:
    static Egg & instance() {
        return e;
    }

    int val() const {
        return i;
    }

    Egg(const & Egg) = delete;
    Egg & operator=(const Egg &) = delete;
};

Egg Egg::e(42); // How you initialize the singleton egg.
```