CS 247
=

```c++
#include <iostream>
using namespace std;

int main() {
    Rational r, s;
    cout << "Enter rational number (a/b): ";
    cin >> r;
    cout << "Enter rational number (a/b): ";
    cin >> s;

    Rational t(r + s);
    cout << r + s << endl;
    cout << r * s << endl;
    cout << r == s << endl;
}
```

- Default / copy constructors.
    ```c++
    // Using MIL (member initialization list).
    Rational::Rational(int num, int den) : numerator_(num), denominator_(den) {
        // !den <=> den == 0
        if (!den) throw "Divide by zero!";
    };

    Rational::Rational(int num) : numerator_(num), denominator_(1) {};

    Rational::Rational() : numerator_(0), denominator_(1) {};

    // But we can instead use default arguments which would look like ...
    class Rational {
    public:
        Rational(int num = 0, int den = 1) : numerator_(num), denominator_(den) {
            if (!den) throw "Divide by zero!";
        };
    };
    // This will allow for implicit conversions which may be unintuitive to the user so we can denote it with "explicit".
    ```
- Operators.
    ```c++
    Rational operator+(const Rational &lhs, const Rational &rhs) {
        // Code for adding two rationals together.
        // Two options. We can write mutators / accessors or friend function.
        return Rational(...);
    }
    ```
    **General rule**: If it doesn't need to be a member function then it shouldnt.

    We passed our operand as a const l-value reference.
    - Behaves like a "const pointer with automatic dereferencing".

### Rules for Function Overloading
- Must differ in type or number of parameters.
- Can't differ by only return type.

**Accessors (*getters*)**: Methods that return the value of a member field.     
**Mutators (*setters*)** :Methods that allow for the setting of member fields.

These restrict the usage of member fields to only those we give access to through the public interface. They also allow usage of member fields only under our ADT's terms / supervision.

### Common Naming Conventions
- attribute, getAttribute(), setAttribute().
- attribute_, attribute(), attributeIs().

## Should it be a member?
> Only if it has to be.
- Constructors, destructors, accessors, mutators.
- Virtual methods.
- Cannot be written with only our ADT's provided public interface (need's access to internals).
    - Could also be a friend. Usually only if it can't be a member function.
- Certain operators (as per C++ standard) must be members.
    - operator=, operator[], operator(), operator->, operator T (where T is a type).
- Certain functions can't / shouldn't be members.
    - Input and output operators.
    ```c++
    class Rational {
        istream &operator>> (istream &in) {
            // Read from in;
            return in;
        }
    };

    int main() {
        Rational r;
        // If we defined operator>> as above.
        r >> cin;
        // We also would not be able to chain reasonably.
        Rational rr;
        rr >> (r >> cin);
        // So we want to stream to be the left-hand side operand.
    }
    ```
    ```c++
    istream &operator>>(istream &in, Rational &r) {
        char slash;
        int n, d;
        in >> n >> slash >> d;
        r.numeratorIs(n);
        r.denominatorIs(d);
        return in;
    }

    ostream &operator<<(ostream &out, const Rational &r) {
        // We need to make sure that the accessors are declared const.
        out << r.numerator() << '/' << r.denominator();
        return out;
    }
    ```
- In general, prefer **non-member**, **non-friend** functions.
    - Offers better encapsulation.
    - Compiler ensures accesses cannot be made to private components.
    - More flexible packaging of data because you can put declarations of standalone functions wherever you want.
- If a member function needs full access and can't be a member function, then make it a **friend**.

Classes can also be friends. This is often used when we have nested classes. Alternatively, if nested class is private, it could just be a struct with full public visibility.

```c++
class Stack {
public:
    Stack();
    ~Stack();
    void push(int n);
    int pop();
    int peek();

    class Node {
        friend class Stack;
    public:
        Node(int data, Node *next);
        Node(const Node& other);
        Node &operator=(const Node &other);
        ~Node();
    private:
        int data_;
        Node *next_;
    };

private:
    Node *top_;
};
```
> Node can be private (and should be in this case) but there are some cases in which the we want the user to access the class but not the constructor (we can just make the constructor private).
```c++
Node::Node(int data, Node *next) : data_(data), next_(next) {}

// Built in copy-constructor copies all values (byte-wise) of built in types and for any object fields, calls copy-constructor. For our case, it would only be a shallow copy (next node would be shared).
Node::Node(const Node &other) : data_{data}, next_{other.next_ ? new Node(*other.next_) : nullptr} {}

Node& Node::operator=(const Node &other) {
    // Self-assignment check.
    if (this == &other) return *this;

    // We need to allocate the memory before just in case new throws an exception.
    Node *tmp = other.next_ ? new Node(*other.next_) : nullptr;

    data_ = other.data_;
    delete next;
    next_ = tmp;

    return *this;
}

Node::~Node() {
    // Calling delete on nullptr is safe
    delete next_;
}
```
## Copy and Swap Idiom
```c++
class Node {
    ...
private:
    void swap(Node &n);
}
```
```c++
#include <utility>

void Node::swap(Node &other) {
    std::swap(data_, other.data_);
    std::swap(next_, other.next_);
}

Node& Node::operator=(const Node &other) {
    // Destructor for tmp will get called which does the clean-up for us.
    Node tmp{other};
    swap(tmp);
    return *this;
}
```

## Lvalue References
```c++
Node plusOne(Node n) {
    for (Node *p = &n; p; p = p->next()) {
        p->dataIs(p->data() + 1);
    }
    return n;
}
int main() {
    Node n = new Node{0, new Node{1, new Node{2, nullptr}}};
    // m will have to be deep copied from plusOne(n).
    Node m = plusOne(n);
}
```
> lvalue is anything with a memory address.  
> rvalues are temporary objects.

To create a reference to an rvalue, you use &&. Now, we have a new important constructor and assignment operator.

```c++
class Node {
    ...
    Node(Node &&other);
    Node &operator=(Node &&other);
};

Node::Node(Node &&other) : data_(other.data_), next_(other.next_) {
    // Need to set to nullptr so that the destructor doesn't destroy the data we stole.
    other.next_ = nullptr;
}

Node & Node::operator=(Node &&other) {
    swap(other);
    return *this;
}
```

## C++ Gives You
1. Default constructor (*disappears as soon as any other constructor is written*).
2. Copy constructor (*copies all fields*).
3. Destructor (*does nothing*).
4. Copy assignment operator (*copy assign all fields*).
5. Move constructor (*identical to built in copy constructor, disappears if you write a copy constructor*).
6. Move assignment operator (*same thing but with copy assignment operator*).

## When Are Defaults Insufficient?
- When you own a resource.
- You have logical / semantic meaning to these operations / your objects.
- **Big 5**: {copy constructor, move constructor, copy assignment operator, move assignment operator, destructor};
    - Rule of thumb is that if you need 1, you need all 5.

Compilers can leave out copy / move constructors and call the basic constructor in the right memory location.

## Entity vs. Value Objects
> Does the object represent something in the real world or is it just an attribute that describes the state?

### Entity Object
- Computer embodiment of a real world entity.
- Each object has a distinct entity.
- Objects with same attribute values does not imply they are the same.

Examples:
> **Physical objects**: airplane, runway, taxiway.  
> **People**: passengers, booking attendant.    
> **Records**: customer info, flight schedule, boarding pass.   
> **Transactions**: reservations, cancellations, reciepts.

### Value Object
- Value objects simply represent a value in our ADT.
- Value objects with same attribute values are considered to be identical.

Example: Consider a video blackgack game. Which of the following should be implemented as entity or value objects?
- **Card**: Entity
- **Deck**: Entity
- **Hand**: Entity
- **Player**: Entity
- **Score**: Value

The distinction between entity and value objects is important because it defines how we use the object, and in turn, how we write the class.

### Design of Entity ADTs
An operation on an entity object should represent a real life event.
- Prohibit copy construtor.
- Prohibit assignment.
- Prohibit type conversions.
- Avoid equality (except of attributes).
- Clone operation may be useful.
- Computations on entities are generally not meaningful.
- Think twice about overloading operators for your entity classes other than new and delete.
- operator< may be useful if it operates on name or some unique id.
- Refer to entity objects through pointer or reference.
- May allow moves ...
- Construction of a new object should reflect a new object in real life.

### Prohibiting Copy Constructor
- Previous to c++11, declare private and don't implement.
- From c++11 onwards, we can delete it.
```c++
class X {
public:
    X(const & x) = delete;
    X & operator=(const & x) = delete;
};
```

### Design of Value ADTs
- Equality **is** important in value types.
    - May be non-trivial (e.g. Matrix).
- Copy constructor, assignment operator.
- Virtual methods / inheritance is uncommon.

## Mutable vs. Immutable
- Mutable objects can cause problems when they are referenced by more than one variables.

Entity objects are usually mutable. Their attributes can change via mutators.

Value based objects should be immutable. Instead, variables of the ADT are assigned to different objects (reassignment). All field types should be primitive or immutable types.

### Writing Immutable ADTs
- **No** mutators.
- Fields should be private.
- Make sure methods don't get overwritten or class at all.
- Declare class *final* (strong immutability).
    - Or declare methods *final*.

## Static Members
- You can declare fields of a class and methods static.
- Shared across objects of that class, tied / global to class scope.

# Singleton Design (Anti) Pattern
- The singleton pattern is used when we have a class for which we only ever want one instance of that class and the object is used across much of the system.
    - Valid example would be a settings class for an application / game.
- It is better design to just pass the class around where it is needed.
```c++
class Egg {
    static Egg e; // Singleton Object.

    int i;
    Egg(int ii) : i(ii) {} // Private Constructor.

public:
    static Egg & instance() {
        return e;
    }

    int val() const {
        return i;
    }

    Egg(const & Egg) = delete;
    Egg & operator=(const Egg &) = delete;
};

Egg Egg::e(42); // How you initialize the singleton egg.
```

# Compilation and Linking

If we need to change the size of a class because we need a new variable, all clients must recompile.

## pImpl Idiom (*Pointer to Implementation*)
- Only the pointer class needs to recompile, the rest just need to relink.

```c++
// XWindow Impl.h
#include <xll/xlib.h>

struct XWindowImpl {
    Display *d;
    Window w;
    int s;
    GC gc;
    unsigned long colours[10];
}
```
```c++
// XWindow.h

class XWindow {
    XWindowImpl * pImpl;
public:
    // Same as before.
}
```
```c++
// XWindow.cc

XWindow::XWindow(...) : pImpl(new XWindowImpl(...)) {}

// All other members, usages of d, w, s, ... become pImpl->d ...
```

# Namespaces and Directives
- **Never** place a using statement in a header file.
- **Never** place a using statement before an include.

Defining your own namespace may be used for subdividing global namespace into named space. Within a namespace, you can refer to other members by their local names.

- Namespaces can be defined at a global scope or within another class.

**Module**: A software component that encapsulates some design decision.

## Interface
> Abstraction public description of some module.
- Supports the hiding of information.
- Reduces information overload on the client programmers.

## Benefits of Modularity
- Simplifies development.
- Supports teamwork.
- Facilitates change because it consolidates all information required for a module in one place and allows for the implementation to change as long as the interface is identical.

## Interface Specification
> Defines what the unit requires, in the way of services of assumptions for it to work correctly.

### CS 247 Interface Specification
**Precondition**: Constraints that must hold **before** the function is called.
**Postconditions**: COnstraints that hold **after** the function is called.
**Modifies**: The objects / variables this function may modify.
**Throws**: Exceptions your function may throw, and conditions under which they are thrown.
**Ensures**: Guaranteed side effects on modified objects.
**Returns**: Describes return value.

```c++
// sumVector.h
#include <vector>
int sumVector(const std::vector<int> & vect);
// Preconditions: vect is a valid vector whose content's sum does not overflow.
// Requires ...
// Modifies ...
// Ensures ...
// Returns ...

int sumVector(const std::vector<int> & vect) {
    int sum = 0;
    for (size_t i = 0; i < vect.size(); ++i) {
        sum += vect[i];
    }
    return sum;
}
```
```c++
class IntStack {
    // Specification Fields:
    // stack
    // top = top element of stack
public:
    IntStack();
    // Ensures: Initializes stack to an empty stack.

    ~IntStack();
    // Modifies: stack.
    // Ensures: stack no longer exists, memory is all freed.

    void push(int elem);
    // Modifies: stack, top.
    // Ensures: stack is appended with elem, top = elem.

    int top();
    // Requires: stack is non-empty.
    // Returns: top.

    void pop();
    // Modifies: stack, top.
    // Ensures: If stack@pre is empty, then stack is empty.
    //          Otherwise, stack = stack@pre with elem removed.
    //          top = remaining top of nothing if stack is empty.
};
```
*Stack* and *top* are **Abstract Specification Data Members**. They don't define the actual structure / fields of our class but rather a way to describe the client's view of the objects state that we can write expressions over.

An **interface specification** describes the behaviour of some software unit (function or class). An implementation **satisfies** a specification if it conforms to the described behaviour.

The **specificand set** of a spec is the set of all conforming implementations. A **strong** specification is more tolerant on inputs, and more demanding on outputs. A **weak** specification is more demanding on inputs, and more tolerant on outputs.

Spec $A$ is stronger than $B$ ($A \ge B$) if and only if.
> 1. $A$'s preconditions are equal to or stronger than $B$'s.
>       - Requires $A$ $\ge$ Requires $B$.
> 2. $A$'s postconditions are stronger or equal to $B$'s.
>       - Requires $B$ $\ge$ (Ensures $A$ $\cap$ Returns $A$) $\ge$ (Ensures $B$ $\cap$ Returns $B$).
> 3. $A$ modifies the same or more objects than $B$.
> 4. $A$ throws the same or fewer exceptions than $B$.

### Preconditions
- The client is responsible for holding preconditions before calling your code.
- Best practice is that if the precondition is easy to check, do so and throw exceptions if violated.

## Handling Exceptions
```c++
#include <stdexcept>

try {
    cout << v.at(100000) << endl;
} catch (out_of_range) {
    cerr << "Range Error." << endl;
}
```
```c++
void f() {
    // out_of_range is a class. out_of_range("f") is a constructor call.
    throw out_of_range("f");
}

void g() {
    f();
}

void h() {
    g();
}

int main() {
    // The exception is propogated if it is not in a try or if there is no matching catch.
    try {
        h();
    } catch (out_of_range ex) {
        cout << ex.what() << endl;
        ...
        throw; // throw s; may cause issues if inheritance in exceptions.
    } catch (...) {
        /// catch (...) will catch everything.
    }
}
```
You can throw anything. You can catch by reference to avoid slicing the object but the static type thrown is what determines what gets caught.

```c++
class BaseExn {};
class DerivedExn : public BaseExn {};

void f() {
    DerivedExn d;
    BaseExn &b = d;
    throw b;
}

void h() {
    DerivedExn d;
    throw d;
}

int main() {
    ...
    try {
        h();
    } catch (BaseExn &h) {
        // This handler will run.
        ...
    } catch (DerivedExn &d) {
        ...
    }
    ...
    try {
        f();
    } catch (DerivedExn &d) {
        ...
    } catch (BaseExn &h) {
        // This handler will run.
        ...
    }
}
```

You should **never** throw an exception in a destructor because exceptions will unwind the stack which will call the destructors for all stack allocated objects. This can cause multiple unhandled exceptions.

### Exception Safety
```c++
void f() {
    MyClass *p = new MyClass;
    MyClass mc;
    g();
    delete P;
}
```

No leaks in the code, but what if $g$ throws? During stack unwinding, $mc$ is popped off the stack and its destructor runs, freeing any resources associated with it. $p$ is a pointer, when it is popped off the stack, no fancy destructor is called, the object it points to is leaked.

Our only guarantee is that stack allocated data will be popped off (objects will have their destructors run).

**C++ Idiom**: Resource acquisition **is** intialization. (*RAII*). Every resource should be wrapped in a stack allocated object upon acquisition, whose destructor will free it.

```c++
#include <memory>
// unique_ptr<T> destructor will delete the pointer.
// std::make_unique<T>();
void f() {
    auto p = std::make_unique<MyClass>();
    MyClass mc;
    g();
}
```
Unique pointers are **unique** so copying is disabled. Moving is allowed. We also have shared pointers for when we want to copy.
```c++
void f() {
    auto p1 = std::make_shared<MyClass>();
    ...
    if (...) {
        auto p2 = p1;
    } // p2 is popped off, but it does not free the memory.
}
```
This can be implemented by having a pointer to a counter (*reference count*). We can increment when copying and decrement when the object no longer points at the same thing. If the reference count drops to 0, the destructor frees the memory.
```c++
MyClass *p = new MyClass;
shared_ptr<MyClass> sp1(p);
if (...) {
    shared_ptr<MyClass> sp2(p);
    ...
} // sp2 goes out of scope and the destructor frees p.
sp1->myFn(); // SegFault.
```

- Error handling itself is an intrinsically non-local problem.
- Consider vector::at, the vector class can detect the error but not decide what to do about it.
- The client knows what they want to do about an error, but may not be able to detect it.
- Throw exceptions when the current context can detect the problem but the problem can't be solved locally.

```c++
void fun_fib(int n) {
    if (n == 0) throw 0;
    if (n == 1) throw 1;

    try {
        fun_fib(n - 1);
    } catch (int a) {
        try {
            fun_fib(n - 2);
        } catch (int b) {
            throw (a + b);
        }
    }
}
```
> This is **very** slow. Orders of magnitude slower than the recursive solution.

In addition to unique and shared pointers, we also have **weak_ptrs**.
- Construct a weak pointer from a shared_ptr.
- Does not act like a regular pointer as shared an unique.
- weak_ptr<T>::lock() returns a shared_ptr to the data that the original shared_ptr pointed at.
- weak_ptr<T>::expired checks whether the reference is still valid.

Weak pointers are typically used to **break cycles in shared pointers**.

There are three levels of exception safety (no safety is not included) for a function $f$.
1. **Basic Guarantee**: Should $f$ terminate due to an exception, the program will be left in a valid but unspecified state.
    - "Valid" means taht no resources are leaked and that any class invariants are not broken.
2. **Strong Guarantee**: Should $f$ terminate due to an exception, the program state will be as if $f$ were never called.
3. **No-Throw Guarantee**: $f$ will never throw an exception and always complete its task.

```c++
class A {...};
class B {...};

class C {
    A a;
    B b;

public:
    void f() {
        a.method1(); // Provides strong guarantee.
        b.method2(); // Provides strong guarantee.
    }
};
```
> Does C::f provide a strong guarantee? **No** because a.method1() could succeed and make changes but b.method2() could crash (we would not undo changes).

```c++
class C {
    A a;
    B b;

public:
    void f() {
        A temp_a = a;
        B temp_b = b;
        temp_a.method1();
        temp_b.method2();
        // Copy assignments cannot throw.
        a = temp_a;
        b = temp_b;
    }
}
```

How do we create our objects so copying can't throw?

- These are temp objects so we can treat them how we like.
- A non-copying swap is core to writing exception safe code.

How can we write swaps for objects so that they do not throw?
- Swapping pointers can't throw.
- **Solution**: pImpl idiom!

```c++
class CImpl {
    A a;
    B b;
    friend class C;
};

class C {
    unique_ptr<CImpl> pImpl;
public:
    void f() {
        auto temp = make_unique<CImpl>(*pImpl);
        temp->a.method1();
        temp->b.method2();
        std::swap(pImpl, temp); // No-throw guarantee.
    }
};
```

If a function offers the no-throw guarantee, you should marck it as such with "noexcept" keyword. At the very least, move operators should be noexcept. This allow the compiler to make optimizations (e.g. vector::emplace_back).

**Why is Encapsulation Important?** To hold class invariants.