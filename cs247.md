CS 247
=

```c++
#include <iostream>
using namespace std;

int main() {
    Rational r, s;
    cout << "Enter rational number (a/b): ";
    cin >> r;
    cout << "Enter rational number (a/b): ";
    cin >> s;

    Rational t(r + s);
    cout << r + s << endl;
    cout << r * s << endl;
    cout << r == s << endl;
}
```

- Default / copy constructors.

    ```c++
    // Using MIL (member initialization list).
    Rational::Rational(int num, int den) : numerator_(num), denominator_(den) {
        // !den <=> den == 0
        if (!den) throw "Divide by zero!";
    };

    Rational::Rational(int num) : numerator_(num), denominator_(1) {};

    Rational::Rational() : numerator_(0), denominator_(1) {};

    // But we can instead use default arguments which would look like ...
    class Rational {
    public:
        Rational(int num = 0, int den = 1) : numerator_(num), denominator_(den) {
            if (!den) throw "Divide by zero!";
        };
    };
    // This will allow for implicit conversions which may be unintuitive to the user so we can denote it with "explicit".
    ```

- Operators.

    ```c++
    Rational operator+(const Rational &lhs, const Rational &rhs) {
        // Code for adding two rationals together.
        // Two options. We can write mutators / accessors or friend function.
        return Rational(...);
    }
    ```

    **General rule**: If it doesn't need to be a member function then it shouldnt.

    We passed our operand as a const l-value reference.

    - Behaves like a "const pointer with automatic dereferencing".

### Rules for Function Overloading

- Must differ in type or number of parameters.
- Can't differ by only return type.

**Accessors (*getters*)**: Methods that return the value of a member field.     
**Mutators (*setters*)** :Methods that allow for the setting of member fields.

These restrict the usage of member fields to only those we give access to through the public interface. They also allow usage of member fields only under our ADT's terms / supervision.

### Common Naming Convention
s
- attribute, getAttribute(), setAttribute().
- attribute_, attribute(), attributeIs().

## Should it be a member?

> Only if it has to be.

- Constructors, destructors, accessors, mutators.
- Virtual methods.
- Cannot be written with only our ADT's provided public interface (need's access to internals).
    - Could also be a friend. Usually only if it can't be a member function.
- Certain operators (as per C++ standard) must be members.
    - operator=, operator[], operator(), operator->, operator T (where T is a type).
- Certain functions can't / shouldn't be members.
    - Input and output operators.

    ```c++
    class Rational {
        istream &operator>> (istream &in) {
            // Read from in;
            return in;
        }
    };

    int main() {
        Rational r;
        // If we defined operator>> as above.
        r >> cin;
        // We also would not be able to chain reasonably.
        Rational rr;
        rr >> (r >> cin);
        // So we want to stream to be the left-hand side operand.
    }
    ```

    ```c++
    istream &operator>>(istream &in, Rational &r) {
        char slash;
        int n, d;
        in >> n >> slash >> d;
        r.numeratorIs(n);
        r.denominatorIs(d);
        return in;
    }

    ostream &operator<<(ostream &out, const Rational &r) {
        // We need to make sure that the accessors are declared const.
        out << r.numerator() << '/' << r.denominator();
        return out;
    }
    ```

- In general, prefer **non-member**, **non-friend** functions.
    - Offers better encapsulation.
    - Compiler ensures accesses cannot be made to private components.
    - More flexible packaging of data because you can put declarations of standalone functions wherever you want.
- If a member function needs full access and can't be a member function, then make it a **friend**.

Classes can also be friends. This is often used when we have nested classes. Alternatively, if nested class is private, it could just be a struct with full public visibility.

```c++
class Stack {
public:
    Stack();
    ~Stack();
    void push(int n);
    int pop();
    int peek();

    class Node {
        friend class Stack;
    public:
        Node(int data, Node *next);
        Node(const Node& other);
        Node &operator=(const Node &other);
        ~Node();
    private:
        int data_;
        Node *next_;
    };

private:
    Node *top_;
};
```

> Node can be private (and should be in this case) but there are some cases in which the we want the user to access the class but not the constructor (we can just make the constructor private).

```c++
Node::Node(int data, Node *next) : data_(data), next_(next) {}

// Built in copy-constructor copies all values (byte-wise) of built in types and for any object fields, calls copy-constructor. For our case, it would only be a shallow copy (next node would be shared).
Node::Node(const Node &other) : data_{data}, next_{other.next_ ? new Node(*other.next_) : nullptr} {}

Node& Node::operator=(const Node &other) {
    // Self-assignment check.
    if (this == &other) return *this;

    // We need to allocate the memory before just in case new throws an exception.
    Node *tmp = other.next_ ? new Node(*other.next_) : nullptr;

    data_ = other.data_;
    delete next;
    next_ = tmp;

    return *this;
}

Node::~Node() {
    // Calling delete on nullptr is safe
    delete next_;
}
```

## Copy and Swap Idiom

```c++
class Node {
    ...
private:
    void swap(Node &n);
}
```

```c++
#include <utility>

void Node::swap(Node &other) {
    std::swap(data_, other.data_);
    std::swap(next_, other.next_);
}

Node& Node::operator=(const Node &other) {
    // Destructor for tmp will get called which does the clean-up for us.
    Node tmp{other};
    swap(tmp);
    return *this;
}
```

## Lvalue References

```c++
Node plusOne(Node n) {
    for (Node *p = &n; p; p = p->next()) {
        p->dataIs(p->data() + 1);
    }
    return n;
}
int main() {
    Node n = new Node{0, new Node{1, new Node{2, nullptr}}};
    // m will have to be deep copied from plusOne(n).
    Node m = plusOne(n);
}
```

> lvalue is anything with a memory address.  
> rvalues are temporary objects.

To create a reference to an rvalue, you use &&. Now, we have a new important constructor and assignment operator.

```c++
class Node {
    ...
    Node(Node &&other);
    Node &operator=(Node &&other);
};

Node::Node(Node &&other) : data_(other.data_), next_(other.next_) {
    // Need to set to nullptr so that the destructor doesn't destroy the data we stole.
    other.next_ = nullptr;
}

Node & Node::operator=(Node &&other) {
    swap(other);
    return *this;
}
```

## C++ Gives You

1. Default constructor (*disappears as soon as any other constructor is written*).
2. Copy constructor (*copies all fields*).
3. Destructor (*does nothing*).
4. Copy assignment operator (*copy assign all fields*).
5. Move constructor (*identical to built in copy constructor, disappears if you write a copy constructor*).
6. Move assignment operator (*same thing but with copy assignment operator*).

## When Are Defaults Insufficient?

- When you own a resource.
- You have logical / semantic meaning to these operations / your objects.
- **Big 5**: {copy constructor, move constructor, copy assignment operator, move assignment operator, destructor};
    - Rule of thumb is that if you need 1, you need all 5.

Compilers can leave out copy / move constructors and call the basic constructor in the right memory location.

## Entity vs. Value Objects

> Does the object represent something in the real world or is it just an attribute that describes the state?

### Entity Object

- Computer embodiment of a real world entity.
- Each object has a distinct entity.
- Objects with same attribute values does not imply they are the same.

Examples:

> **Physical objects**: airplane, runway, taxiway.  
> **People**: passengers, booking attendant.    
> **Records**: customer info, flight schedule, boarding pass.   
> **Transactions**: reservations, cancellations, reciepts.

### Value Object

- Value objects simply represent a value in our ADT.
- Value objects with same attribute values are considered to be identical.

Example: Consider a video blackgack game. Which of the following should be implemented as entity or value objects?

- **Card**: Entity
- **Deck**: Entity
- **Hand**: Entity
- **Player**: Entity
- **Score**: Value

The distinction between entity and value objects is important because it defines how we use the object, and in turn, how we write the class.

### Design of Entity ADTs
An operation on an entity object should represent a real life event.

- Prohibit copy construtor.
- Prohibit assignment.
- Prohibit type conversions.
- Avoid equality (except of attributes).
- Clone operation may be useful.
- Computations on entities are generally not meaningful.
- Think twice about overloading operators for your entity classes other than new and delete.
- operator< may be useful if it operates on name or some unique id.
- Refer to entity objects through pointer or reference.
- May allow moves ...
- Construction of a new object should reflect a new object in real life.

### Prohibiting Copy Constructor

- Previous to c++11, declare private and don't implement.
- From c++11 onwards, we can delete it.

```c++
class X {
public:
    X(const & x) = delete;
    X & operator=(const & x) = delete;
};
```

### Design of Value ADTs

- Equality **is** important in value types.
    - May be non-trivial (e.g. Matrix).
- Copy constructor, assignment operator.
- Virtual methods / inheritance is uncommon.

## Mutable vs. Immutable

- Mutable objects can cause problems when they are referenced by more than one variables.

Entity objects are usually mutable. Their attributes can change via mutators.

Value based objects should be immutable. Instead, variables of the ADT are assigned to different objects (reassignment). All field types should be primitive or immutable types.

### Writing Immutable ADTs

- **No** mutators.
- Fields should be private.
- Make sure methods don't get overwritten or class at all.
- Declare class *final* (strong immutability).
    - Or declare methods *final*.

## Static Members

- You can declare fields of a class and methods static.
- Shared across objects of that class, tied / global to class scope.

# Singleton Design (Anti) Pattern
- The singleton pattern is used when we have a class for which we only ever want one instance of that class and the object is used across much of the system.
    - Valid example would be a settings class for an application / game.
- It is better design to just pass the class around where it is needed.

```c++
class Egg {
    static Egg e; // Singleton Object.

    int i;
    Egg(int ii) : i(ii) {} // Private Constructor.

public:
    static Egg & instance() {
        return e;
    }

    int val() const {
        return i;
    }

    Egg(const & Egg) = delete;
    Egg & operator=(const Egg &) = delete;
};

Egg Egg::e(42); // How you initialize the singleton egg.
```

# Compilation and Linking

If we need to change the size of a class because we need a new variable, all clients must recompile.

## pImpl Idiom (*Pointer to Implementation*)

- Only the pointer class needs to recompile, the rest just need to relink.

```c++
// XWindow Impl.cc
#include <xll/xlib.h>

struct XWindowImpl {
    Display *d;
    Window w;
    int s;
    GC gc;
    unsigned long colours[10];
}
```
```c++
// XWindow.h

class XWindow {
    XWindowImpl * pImpl;
public:
    // Same as before.
}
```

```c++
// XWindow.cc

XWindow::XWindow(...) : pImpl(new XWindowImpl(...)) {}

// All other members, usages of d, w, s, ... become pImpl->d ...
```

# Namespaces and Directives

- **Never** place a using statement in a header file.
- **Never** place a using statement before an include.

Defining your own namespace may be used for subdividing global namespace into named space. Within a namespace, you can refer to other members by their local names.

- Namespaces can be defined at a global scope or within another class.

**Module**: A software component that encapsulates some design decision.

## Interface

> Abstraction public description of some module.

- Supports the hiding of information.
- Reduces information overload on the client programmers.

## Benefits of Modularity

- Simplifies development.
- Supports teamwork.
- Facilitates change because it consolidates all information required for a module in one place and allows for the implementation to change as long as the interface is identical.

## Interface Specification

> Defines what the unit requires, in the way of services of assumptions for it to work correctly.

### CS 247 Interface Specification

**Precondition**: Constraints that must hold **before** the function is called.
**Postconditions**: COnstraints that hold **after** the function is called.
**Modifies**: The objects / variables this function may modify.
**Throws**: Exceptions your function may throw, and conditions under which they are thrown.
**Ensures**: Guaranteed side effects on modified objects.
**Returns**: Describes return value.

```c++
// sumVector.h
#include <vector>
int sumVector(const std::vector<int> & vect);
// Preconditions: vect is a valid vector whose content's sum does not overflow.
// Requires ...
// Modifies ...
// Ensures ...
// Returns ...

int sumVector(const std::vector<int> & vect) {
    int sum = 0;
    for (size_t i = 0; i < vect.size(); ++i) {
        sum += vect[i];
    }
    return sum;
}
```

```c++
class IntStack {
    // Specification Fields:
    // stack
    // top = top element of stack
public:
    IntStack();
    // Ensures: Initializes stack to an empty stack.

    ~IntStack();
    // Modifies: stack.
    // Ensures: stack no longer exists, memory is all freed.

    void push(int elem);
    // Modifies: stack, top.
    // Ensures: stack is appended with elem, top = elem.

    int top();
    // Requires: stack is non-empty.
    // Returns: top.

    void pop();
    // Modifies: stack, top.
    // Ensures: If stack@pre is empty, then stack is empty.
    //          Otherwise, stack = stack@pre with elem removed.
    //          top = remaining top of nothing if stack is empty.
};
```

*Stack* and *top* are **Abstract Specification Data Members**. They don't define the actual structure / fields of our class but rather a way to describe the client's view of the objects state that we can write expressions over.

An **interface specification** describes the behaviour of some software unit (function or class). An implementation **satisfies** a specification if it conforms to the described behaviour.

The **specificand set** of a spec is the set of all conforming implementations. A **strong** specification is more tolerant on inputs, and more demanding on outputs. A **weak** specification is more demanding on inputs, and more tolerant on outputs.

Spec $A$ is stronger than $B$ ($A \ge B$) if and only if.

> 1. $A$'s preconditions are equal to or stronger than $B$'s.
>       - Requires $A$ $\ge$ Requires $B$.
> 2. $A$'s postconditions are stronger or equal to $B$'s.
>       - Requires $B$ $\ge$ (Ensures $A$ $\cap$ Returns $A$) $\ge$ (Ensures $B$ $\cap$ Returns $B$).
> 3. $A$ modifies the same or more objects than $B$.
> 4. $A$ throws the same or fewer exceptions than $B$.

### Preconditions

- The client is responsible for holding preconditions before calling your code.
- Best practice is that if the precondition is easy to check, do so and throw exceptions if violated.

## Handling Exceptions

```c++
#include <stdexcept>

try {
    cout << v.at(100000) << endl;
} catch (out_of_range) {
    cerr << "Range Error." << endl;
}
```

```c++
void f() {
    // out_of_range is a class. out_of_range("f") is a constructor call.
    throw out_of_range("f");
}

void g() {
    f();
}

void h() {
    g();
}

int main() {
    // The exception is propogated if it is not in a try or if there is no matching catch.
    try {
        h();
    } catch (out_of_range ex) {
        cout << ex.what() << endl;
        ...
        throw; // throw s; may cause issues if inheritance in exceptions.
    } catch (...) {
        /// catch (...) will catch everything.
    }
}
```

You can throw anything. You can catch by reference to avoid slicing the object but the static type thrown is what determines what gets caught.

```c++
class BaseExn {};
class DerivedExn : public BaseExn {};

void f() {
    DerivedExn d;
    BaseExn &b = d;
    throw b;
}

void h() {
    DerivedExn d;
    throw d;
}

int main() {
    ...
    try {
        h();
    } catch (BaseExn &h) {
        // This handler will run.
        ...
    } catch (DerivedExn &d) {
        ...
    }
    ...
    try {
        f();
    } catch (DerivedExn &d) {
        ...
    } catch (BaseExn &h) {
        // This handler will run.
        ...
    }
}
```

You should **never** throw an exception in a destructor because exceptions will unwind the stack which will call the destructors for all stack allocated objects. This can cause multiple unhandled exceptions.

### Exception Safety

```c++
void f() {
    MyClass *p = new MyClass;
    MyClass mc;
    g();
    delete P;
}
```

No leaks in the code, but what if $g$ throws? During stack unwinding, $mc$ is popped off the stack and its destructor runs, freeing any resources associated with it. $p$ is a pointer, when it is popped off the stack, no fancy destructor is called, the object it points to is leaked.

Our only guarantee is that stack allocated data will be popped off (objects will have their destructors run).

**C++ Idiom**: Resource acquisition **is** intialization. (*RAII*). Every resource should be wrapped in a stack allocated object upon acquisition, whose destructor will free it.

```c++
#include <memory>
// unique_ptr<T> destructor will delete the pointer.
// std::make_unique<T>();
void f() {
    auto p = std::make_unique<MyClass>();
    MyClass mc;
    g();
}
```

Unique pointers are **unique** so copying is disabled. Moving is allowed. We also have shared pointers for when we want to copy.

```c++
void f() {
    auto p1 = std::make_shared<MyClass>();
    ...
    if (...) {
        auto p2 = p1;
    } // p2 is popped off, but it does not free the memory.
}
```

This can be implemented by having a pointer to a counter (*reference count*). We can increment when copying and decrement when the object no longer points at the same thing. If the reference count drops to 0, the destructor frees the memory.

```c++
MyClass *p = new MyClass;
shared_ptr<MyClass> sp1(p);
if (...) {
    shared_ptr<MyClass> sp2(p);
    ...
} // sp2 goes out of scope and the destructor frees p.
sp1->myFn(); // SegFault.
```

- Error handling itself is an intrinsically non-local problem.
- Consider vector::at, the vector class can detect the error but not decide what to do about it.
- The client knows what they want to do about an error, but may not be able to detect it.
- Throw exceptions when the current context can detect the problem but the problem can't be solved locally.

```c++
void fun_fib(int n) {
    if (n == 0) throw 0;
    if (n == 1) throw 1;

    try {
        fun_fib(n - 1);
    } catch (int a) {
        try {
            fun_fib(n - 2);
        } catch (int b) {
            throw (a + b);
        }
    }
}
```

> This is **very** slow. Orders of magnitude slower than the recursive solution.

In addition to unique and shared pointers, we also have **weak_ptrs**.

- Construct a weak pointer from a shared_ptr.
- Does not act like a regular pointer as shared an unique.
- weak_ptr<T>::lock() returns a shared_ptr to the data that the original shared_ptr pointed at.
- weak_ptr<T>::expired checks whether the reference is still valid.

Weak pointers are typically used to **break cycles in shared pointers**.

There are three levels of exception safety (no safety is not included) for a function $f$.

1. **Basic Guarantee**: Should $f$ terminate due to an exception, the program will be left in a valid but unspecified state.
    - "Valid" means that no resources are leaked and that any class invariants are not broken.
2. **Strong Guarantee**: Should $f$ terminate due to an exception, the program state will be as if $f$ were never called.
3. **No-Throw Guarantee**: $f$ will never throw an exception and always complete its task.

```c++
class A {...};
class B {...};

class C {
    A a;
    B b;

public:
    void f() {
        a.method1(); // Provides strong guarantee.
        b.method2(); // Provides strong guarantee.
    }
};
```

> Does C::f provide a strong guarantee? **No** because a.method1() could succeed and make changes but b.method2() could crash (we would not undo changes).

```c++
class C {
    A a;
    B b;

public:
    void f() {
        A temp_a = a;
        B temp_b = b;
        temp_a.method1();
        temp_b.method2();
        // Copy assignments cannot throw.
        a = temp_a;
        b = temp_b;
    }
}
```

How do we create our objects so copying can't throw?

- These are temp objects so we can treat them how we like.
- A non-copying swap is core to writing exception safe code.

How can we write swaps for objects so that they do not throw?

- Swapping pointers can't throw.
- **Solution**: pImpl idiom!

```c++
class CImpl {
    A a;
    B b;
    friend class C;
};

class C {
    unique_ptr<CImpl> pImpl;
public:
    void f() {
        auto temp = make_unique<CImpl>(*pImpl);
        temp->a.method1();
        temp->b.method2();
        std::swap(pImpl, temp); // No-throw guarantee.
    }
};
```

If a function offers the no-throw guarantee, you should mark it as such with "noexcept" keyword. At the very least, move operators should be noexcept. This allow the compiler to make optimizations (e.g. vector::emplace_back).

**Why is Encapsulation Important?** To hold class invariants.

- Without class invariants, it is hard to logic about a piece of software.
- A representation invariant applies to an entire class, so across objects of that class.
- An abstraction function that maps from legal representations of our data to the actual client facing representation.

When deciding the implementation of a class, we do not necessarily know what is better. We want to be able to swap out representations easily / painlessly. We want out specification and ADT to have **Representation Independence**, chnages to the representation do not affect how the ADT is used.

We define some representation invariants $R$ to help us reason about our class and write good code. Defines what is a legal / valid state for our representation invariants. Similarily, we come up with an **Abstraction Function** $A$ which maps from valid states of representation, to our ADTs possible values.

```c++
class Set {
    int *elements_;
    size_t capacity_;
    size_t size_;

public:
    Set();
    ~Set();
    void insert(int d);
    void remove(int d);
    bool member(int d);
};
```

1. No duplicate elements. $\forall i, j \in \{0 \to size\_ - 1\}$, $i \neq j \Rightarrow elements\_[i] \neq elements\_[j]$.
2. All elements in our set are stored in indices $\{0 \to size\_ - 1\}$ of elements_.

### Methods Need To Preserve Invariants

1. Verify that the constructor establishes invariants.
2. For each method, assume it holds true, prove / verify method does not violate invariant at end.
3. If encapsulation is not broken, representation invariants hold true.

### Representation Example

- If we give access to the representation to the client, they can violate our invariants.

```c++
class Node {
    int data_;
    Node *next_ = nullptr;

public:
    Node(int d, Node *next = nullptr) : data_(d), next_(next) {}
    ~Node() {
        delete next_;
    }

    Node *next() {
        return next_;
    }
};

int main() {
    Node my_list = Node(1, new Node(2, new Node(3)));
    Node my_list_2 = Node(0, &my_list);
}
```

We need $R$.

- next_ is either the nullptr or a valid pointer to a heap allocated Node.
- $\forall o, p \in Nodes$, $o \neq p \land o.next\_ \Rightarrow o.next\_ \neq p.next\_$.

# Iterator Pattern

> We want to be able to iterate over our collection efficiently without exposing the representation.

```c++
class List {
    struct Node;

    Node *list;

    Iterator begin() {
        return Iterator(list);
    }

    Iterator end() {
        return Iterator(nullptr);
    }

public:
    class Iterator {
        friend class List;

        explicit Iterator(Node *p) : p(p) {}

        Node *p;

    public:
        Iterator &operator++() {
            p = p->next();
            return *this;
        }

        bool operator!=(const Iterator &other) {
            return p != other.p;
        }

        bool operator==(const Iterator &other) {
            return p == other.p;
        }

        int &operator*() {
            return p->data;
        }
    }
};
```

# Documenting Representation Invariants

- They do nothing if nobody knows about them.
- Write them as comments in top of your class.

## Determining Representation Invariants

1. Look for invalid values for your representation.
2. Think about what assumptions you make or want to make while writing your code.

## Checking Representation Invariants

- It can be useful for **debugging** purposes to programmatically check our invariants.
- Write a method **check_rep** that asserts all of our invariants hold.
    1. End of constructors.
    2. Before any const methods.
    3. Before and after non-const methods.
    - Generally this should only be used for **debugging** (finding your errors), so remove from production code (preprocessor, build script, etc.).

- **Never** ship code different from what you tested.
- Asserts can be used for check_rep.
    - **Benefits**: Exits the program directly from that location, so it keeps the stack frame / call stack intact.
    - **Negatives**: Exits the program directly from that location, so it does not free up resources and call destructors. The severity of this depends on what resources you are holding.

```c++
class MyClass {
    bool check_rep();

public:
    ...
    void foo() {
        #ifdef MYDEBUG_
        check_rep();
        #endif
    }
};
```

> g++-5 -std=c++14 -DMYDEBUG_ -c MyClass.cc

## Abstraction Function

The abstraction function is not guaranteed to be injective, but it is guaranteed to be surjective. Therefore, it may not have an inverse function.

Example: **Rational r**

> $AF(r) = \frac{r.numerator\_}{r.denominator\_}$     
> $AF(r) = \{elements\_[i] | 0 \le i \le r.size\_\}$    

There is no concrete language for talking about our abstract values.

- It can be defined with maths , if not then we might to define by example.

Example: A set $S$ over the integers in range $0, ..., 255$.

> Bit vector stored in a char $c$, integer $i$ is in set if and only iff c & (1 << i). $AF(r) = \{\forall i \in [0, 255] | c \& (1 << i) \}$

# Models (*UML*)

> An abstraction of something.

- Help to understand something before you build.
- Communicate to others.
- Answer questions about the thing being modelled.
- We are going to mainly focus on UML class diagrams.
- UML consists of ~13 different modelling notations.

## Legend

- +, public
- -, private
- #, protected
- underline, static
- *italics*, pure virtual

> **Note**: We do not use **"in"**. We also do not want to be too specific with types because UML are designed to be language agnostic.

## Associations

An association represents a relationship between two classes, share a physical or conceptual link.

- **Non-transient link**, not just one parameter of a classes member function.
- One class contains another.
- We can name our associations (*optional*).
- We can name the roles of associations.
- Arrows denote who refers to whom.
- Self-association can exist.
- **Multiplicity**, place them on the side of the relationship that they refer to. It can be just a number (0), a variable (p), a range (0..1), or an asterisk (*) to represent **many**.

> Consider marks a student has in a course. To which class should we attribtue marks? Marks should be associated with a pair of (student, course).

- We can create association classes that allow for a unique value for each link. The name of the class is the name of the association.
- Instances of the association class exists only when a link exists between the associated classes.
- Association classes can be used as other classes in your diagram and have associations themselves.

## Relationships

### Composition Relationship

> A specialization of association, where one class **owns** an object(s) of another class.

If A *owns* B, then typically ...

- B has no identity outside of A (no independent existence).
- If A is destroyed / copied, B is destroyed / copied.
- In code, usually represented by one class having an object field of another, or by an **owning** pointer.

Modelled in UML as a solid diamond on the owner connected to the owned.

### Aggregation Relationship

> A specialization of association, where one class **has** objects(s) of a class.

If A *has* B then ...

- B has an identity outside of its association with A.
- If A is destroyed, B is not necessarily destroyed. 
- If A is copied, B is not copied (**shallow copy**).
- In code, usually represented by **non-owning** pointers.

Modelled in UML as a hollow diamond on the owner connected to the owned.

### Generalization / Specialization Relationship

> One class **is** another class.

- Public inheritance.

Modelled in UML as a hollow triangle pointing to the base class.

![](https://i.imgur.com/Zm2Kwcj.jpg?1)

## UML Object Model

- An object model models a runtime instance of class model.
    - Every object in our object model is an instantiation of our particular class.
    - Every link is an instantiation of a specific association.

![](https://i.imgur.com/ypbv44Q.jpg?1)

## UML Sequence Diagram

- Graphical model of communication events between objets as exhibited in one execution.
- Boxes are the execution patterns.

![](https://i.imgur.com/q2TAAbt.jpg?1)

# Design Patterns

- If you have a problem $p$ which is a common problem or simliar to a common problem, then **maybe** design pattern $D$ is a good solution.

## Observer Pattern

> We want to abstract away change.

- Publish and subscribe model.
- You need to maintain / propogate updates from a source to those it affects.
- We have one class called the **publisher** or the **subject** which generates the data.
- One or more classes are our **subscribers** or **observers**. They receive updates and react to it.

Example: Publisher is spreadsheet cells and observers are our generated graphs.

- There can be many different kinds of observers, and the subject should not need to know details about them.

![](https://i.imgur.com/Mr3Seyk.jpg?1)

- The abstract class subject contains all the code common to all subjects, the abstract class observer defines an interface common to all observers for subject to use.

1. Subject's state is updated.
2. Subject::notifyObservers is called, it calls notify() on all its observers.
3. Each observer does their update, which likely involves calling concreteSubject::getState to query the state and react accordingly.

Example: Horse Races. The subject publishes the winning horse, the observers are individual betters who will declare victory if their horse wins.

```c++
class Subject {
    vector<Observer *> observers_;

public:
    void attach(Observer *ob) {
        observers_.emplace_back(ob);
    }
    void detach(Observer *ob);
    void notifyObservers() {
        for (auto &p : observers_) {
            p->notify();
        }
    }
    virtual ~Subject() = 0;
    Subject::Subject() {}
};

class Observer {
public:
    virtual void notify() = 0;
    virtual ~Observer();
};

class Horserace : public Subject {
    ifstream in_;
    string last_winner_;

public:
    Horserace(string source) : in{source} {}
    ~Horserace() {}
    bool runRace() {
        return in_ >> last_winner_;
    }
    string getState() const {
        return last_winner_;
    }
};

class Bettor : public Observer {
    Horserace *subject_;
    string name_, horse_;

public:
    Bettor(...) {
        subject_->attach(this);
    }
    void notify() {
        string winner = subject_->getState();
        cout << (winner == horse_ ? "Win!" : "Lose.") << endl;
    }
};
```

- If you only have one ConcreteSubject, you may consider merging Subject and ConcreteSubject. Don't do so lightly however, if you need to add another subject in the future you will have to refactor.
- If the state is trivial (i.e. getting notified is all the information you need), you may not need getState method.
- If the subject and the observer are the same (e.g. cells in a grid), you could merge these classes.

## Decorator Pattern

Suppose you want to enhance an object (e.g. adding functionality or features).

Example: Windowing System. We start with a basic window, and then add a toolbar, scrollbar, and a menu. We want the user to be able to choose these at runtime.

![](https://i.imgur.com/0tFP1IZ.jpg?1)

- Every Decorator is a component, and every Decorator has a component.
- Example, a window with a scrollbar **is** a window, but it also has a pointer to the underlying plain window.
    - A window with a menu and a scrollbar is a window, but is also has a pointer to the window with a scrollbar. 

Example: Pizza.

```c++
class Pizza {
public:
    virtual float price() const = 0;
    virtual string description() const = 0;
    virtual ~Pizza();
};

class CrustAndSauce : public Pizza {
public:
    float price() const override {
        return 5.99;
    }
    string description() const override {
        return "Pizza";
    }
};

class Decorator : public Pizza {
protected:
    Pizza *component_;

public:
    Decorator(Pizza *p) : component_(p) {}
    virtual ~Decorator() {
        // Depends on whether we have aggregation or composition.
        delete component_;
    }
};

class StuffedCrust : public Decorator {
public:
    StuffedCrust(Pizza *p) : Decorator(p) {}
    float price() const override {
        // Better to have pass-through methods.
        return component_->price() + 2.69;
    }
    string description() const override {
        return component_->description() + " with Stuffed Crust"
    }
};

class Topping : public Decorator {
private:
    string topping_;
public:
    Topping(Pizza *p, string topping) : Decorator(p), topping_(topping) {}
    float price() const override {
        return component_->price() + 0.75;
    }
    string description() const override {
        return component_->description() + " with " + topping_;
    }
};

int main() {
    Pizza *p = new CrustAndSauce;
    p = new Topping(p, "Cheese");
    p = new Topping(p, "Pineapple");
    std::cout << p->description() << std::endl;
    // Pizza with Cheese with Pineapple.
}
```

## Factory Method Pattern

Exampe: We want to write a video game with two kinds of enemies: turtles and bullets. The system randomly sends turtles and bullets, but bullets become more frequent in later levels.

We never know exactly which enemy is going to come next, we (*client*) can't call the constructors directly. Moreover, we dont want to hardcode the policy that decides what comes next, it should be customizable. Instead we add a factory method in Level that creates enemies.

```c++
class Level {
    ...
public:
    // Factory method.
    virtual Enemy *createEnemy() = 0;
    ...
};

class NormalLevel : public Level {
    ...
public:
    Enemy *createEnemy() override {
        // Create enemies, mostly Turtles.
    }
    ...
};

class Castle : public Level {
    ...
public:
    Enemy *createEnemy() override {
        // Create enemies, mostly Bullets.
    }
    ...
};
```

- This pattern is also called the **Virtual Constructor** pattern.

## Template Method Pattern

> Pattern is used when we want subclasses to override some aspects of a superclass method behaviour but not all.

Example: Red-shelled Turtles and Green-shelled Turtles.

```c++
class Turtle {
public:
    void draw() {
        drawHead();
        drawShell();
        drawFeet();
    }

private:
    void drawHead() {
        ...
    }
    void drawFeet() {
        ...
    }
    virtual void drawShell() = 0;
};
```

Subclasses cannot change the way a turtle is drawn, nor can they change how feet or head are drawn, but they can change how shell is drawn.

## Non-Virtual Interface (*NVI*) Idiom

> The NVI idiom extends the template method by wrapping every virtual method with a non-virtual method.

- A public virtual method is really two things.
    - An interface to the client. Indicates provided behaviour, and pre / post conditions, as well as promise representation invariants.
    - An interface (node) for subclasses. A hook for subclasses to insert specialized behaviour.

> Hard to separate these 2 ideas if they're wrapped up in one function declaration.

- What if you want to separate the customizable behaviour into two methods, with some non-customizable steps in between? We don't want to change the public interface.
- How to make sure all derived classes conform to the pre / post conditions that the parent class promises?

The NVI idiom says that all public methods should be **non-virtual**.

All public methods should be non-virtual. All virtual methods should be private, or at the very least protected, with the exception of the destructor.

**Bad Example**

```c++
class DigitalMedia {
public:
    // We cannot have control over play without changing all derived classes.
    virtual void play() = 0;
    virtual ~DigitalMedia();
};
```

**Translated to NVI**

```c++
class DigitalMedia {
    virtual void doPlay() = 0;
public:
    void play() {
        doPlay();
    }
    virtual ~DigitalMedia();
};
```

**Now** if we want to exert extra control over play, we just put the behaviour we want in the superclass play method. We can add more *hooks* by calling more virtual methods.

- It's much easier to keep control of our interface from the beginning than having to refactor after the fact.

## Adapter Pattern

> Solves the problem of interface mismatch between two modules.

- We want to reuse an existing subsystem (class or library) but its interface doesn't match our needs.
- The interface of one of our modules may change and we dont want to make major changes to the existing working code.
- An adapter calss maps one interface (**adaptee**) to another (**target**).

Example: STL Stacks are implemented as an adapter of a container class (usually a deque).

1. **Object Adapater**.
    - Done through composition, the adapter owns an object of adaptee type.
    - Generally preferred, better, and cleaner.
2. **Class Adapter**.
    - Done through inheritance.
    - Should only be used if behaviour needs to be adjusted and it is easier to do so with overriding.

## Facade Pattern

- When subsystem interfaces change, we only need to update Facade.
- Supports teamwork, not everyone needs to dedicate time understanding complex subsystem.
- Reduce code complexity.
- Decoupling subsystem from client code, promotes reuse of subsystems.
- Important to note that original subsystem is still available for the client to use.
    - The major difference between Facade and Adapter.

## Strategy Pattern

> We want to vary an algorithm (*strategy*) at runtime.

We encapsulate the algorithm itself. We define an algorithm as a component object of our class that uses. We will have an ABC for algorithm and use inheritance to specialize.

![](https://i.imgur.com/wxPLhKQ.jpg?1)

- Goal is allowed to switch strategies at runtime. Simply swap strategy pointers.
- Similar to Factory Method.

# Measures of Design Quality

## Coupling

> The degree to which distinct modules interact and rely / **depend** on each other.

- If multiple modules are highly coupled, it is indicative to bad design.

### Severity of Coupling

1. (**Low**) Modules communicate via function calls with basic parameters / results.
2. Modules pass arrays / structs back and forth.
3. Modules affect each other's control flow.
4. Modules share global data.
5. (**High**) Modules share / have access to each other's implementations (*friends*).

### High Coupling

- Bad since changes to one module require greater changes to another.
- Hard to reuse individual modules.

## Cohesion

> How closely elements of a module are related to each other.

### Levels of Cohesion

1. (**Low**) Arbitrary grouping of unrelated elements. Example: utility.
2. Element share a common theme, otherwise unrelated.
3. Elements manipulate the state over the lifetime of an entity.
4. (**High**) Elements cooperate to perform exactly one task.

### Low Cohesion

- Indicates poorly organized code.
- Hard to understand or maintain.

> **Goal**: Low coupling and high cohesion.

# Decoupling the Interface (**MVC**)

```c++
class ChessBoard {
    ...
    cout << "Your Move" << ...
};
```

- This is bad design, inhibits code reuse.
- What if you wanted to reuse ChessBoard class, but not have it communicate through stdout.

```c++
class ChessBoard {
    ostream &out;
    ...
    out << "Your Move" << ...
};
```

- Better, but what if we want a graphical interface?
- ChessBoard should not be communicating at all.
- **"Single Responsibilty Principle"**: A class should only have one reason to change.

## Model-View-Controller

- Separate the distinct notions of data (state), the presentation of the data, and the control of the data.
- **Model**: The main data you are manipulating.
- **View**: How the model is displayed to the user.
- **Controller**: How the model is manipulated.

### Model

- Can have multiple views (e.g. graphical / text).
- Does not need to know about their details.
- Could be implemented as a class observer, or communicate through the controller.

### Controller

- Mediates communication between model and view.
- May encapsulate turn-taking, or full game rules (trade-off with model).
- May communicate with the user, or receive messages from view.

# OO Design Principles

- **Separation of Concerns**, decompose our programs along distinct lines of entities, features, or behaviours.
- **Low Coupling**.
- **Info Hiding**, hide implementation and design details behind an abstraction (our interface).
- Includes knowledge of our complex object's structure (pImpl).
- Least knowledge principle (law of demeter).
- Avoid duplicate code.
    - Shared helper methods.
    - Inherited method swith implementations when applicable.
    - Default parameters.

## Open Closed Principle

> A module should be **open** to extension, but **closed** to modification. Program to an interface and not to an implementation.

The idea is that your client code should depend only on ABC's that can be extended, not on concrete classes (e.g. the **target** interface in Adapter Pattern rather than Client using Adapter directly).

**Suggestion**: All base classes should be ABC's. This implies that you should never inherit from a concrete class.

- We may not know 100% what we need in our interface when starting out but some subscription to the open closed principle is better than none.

## Inheritance or Composition?

> When defining a new class that includes attributes or behaviour from an existing class, do we inherit or compose?

- In general, favour composition over inheritance.
    - Keeps classes focused.
    - Helps maintain encapsulation.
    - Can allow for objects to be swapped out at runtime.
- Use inheritance when you are ...
    - Using **subtyping** (polymorphic behaviour), when the new class should be substitutable for the old class.
    - Use the **entire** interface from the old class.

## Liskov Substitutability Principle (LSP)

> A derived class **must** be substitutable for its base class.

- Objects accept all base class messages.
- Methods must require **no more** than the base class methods.
- Methods promise **no less** than the base class methods.

Example: A BoundedStack is a specialized type of Stack that cannot grow past a certain size. Is a BoundedStack substitutable for a Stack? Assume BoundedStack has a limit of 255 elements.

```c++
Stack *s;
for (size_t i = 0; i < 1000; ++i) {
    s->push(i);
}
```

**No**, a BoundedStack is **not** substitutable for a Stack. Instead, BoundedStack should be **composed** with a Stack.

**Note**: On overriding in c++.

- Parameter types must match exactly.
- Name must match exactly.
- Return type must be the same type **or** be a subtype of the original return type.
- Use **override** keyword to make sure there are no mistakes.

## Law of Demeter

> A class should only talk to its neighbours.

- Method A::m should only call methods on ...
    - A itself.
    - A's data members.
    - m's parameters.
    - Objects constructed by A's methods.

### Advantages

- Reduces complexity sine there is at most 1 level of indirection to follow.
- Interface is easier to understand for outsiders.
- Testing client code and composition object code is easier.

### Disadvantages

- Larger interfaces per class.
- Small performance hit.
    - In general, don't design for performance, design for modularity and cleanly. Then test for bottlenecks and optimize, couple if necessary, those code points.

Examples:

```c++
void A::m1(SomeObj b) {
    b.m2() // Ok. Params.
    this->otherObj.m3(); // Ok. A's data members.
    b.gen().m4(); // Not ok.
    AnotherObj obj{};
    obj.m5(); // Ok. Object constructed by A's methods.
}
```

# Refactoring

> Changing existing code to "clean it up".

- You are not making externally observable changes. **Not** changing behaviour or interface.
- Test suites should be still usable and give the same results after proper refactoring.
- You **are** changing the **design** of your software to improve upon it.
    - Easier to understand and modify, striving for a better, cleaner design.

## Why Refactor?

- Even if you wrote perfectly clean code the first time around (you didn't), better solutions may become apparent.
- Does not happen in reality, *"quick and dirty"* solutions are used all the time to meet deadlines.
- After a while, these sketchy solutions add up and build what is called **"Technical Debt"**.

## When Refactor?

- Upon recognizing a *"bad smell"*.
- When you add a function, it is likely not isolated. We may need to factor to support it.
- Code review.
- When you fix a bug, it may have been caused by bad design.

## When Not To Refactor?

- When a deadline is approaching.
- Invasive changes that will break other engineers' mental model of the code.
- When prohibitively expensive or time consuming.
- Generally, earlier refactoring is less expensive.

## What to Refactor?

- Bad smells (indications of bad design).

### Duplicated Code

- Expressions in different methods of the same class.
- Duplicate / similar expressions in "sibling" subclasses.
- Methods that perform the same function but with different algorithms.

### Long Method

- Best to think carefully about major tasks and how they inter-relate.
    - Often a sign of trying to do too much.
    - Often indicative of poorly thought out abstractions and boundaries.
- **Fowler's Heuristic**: When you see a comment, make a method.

### Large Class

- Too many member variables, may be trying to do too many things.
- Try to eliminate redundancy by gathering codependent pieces and separate into aggregate subparts. Compose yourself of these subparts.

### Long Parameter List

- Again, trying to do too much?
    - Trying to do too much, too far from home with too many subparts? 

### Divergent Changes

- One class commonly refactored / changed in different ways for different reasons.
- Containing too many unrelated subparts.
- Sign of poor cohesion and responsibility creep (poor boundaries).

### Shotgun Surgery

> Opposite of divergent change.

- Often when making a seemingly coherent change, you must make many little changes to many classes.
- Poor cohesion, possibly high coupling.

### Primitive Obsession

- Many member variables all of primitive types.
- Probably have constraints and invariants that apply to these values.
- Perhaps should be pulled out and wrapped up in a value ADT, or some other aggregate type.

### Feature Envy

- Method **A::m** uses other classes' methods, features, and data much more than its own.
    - Consider moving **m** to class B.
    - Some patterns are deliberate exceptions, Strategy, Iterator, Visitor.

### Lazy Class

- A class that doesn't do much different than other classes.
    - Could be vestigial, and should be deprecated then removed.
    - Could be relic from ambitious design hopes.
    - Could have been gutted from previous refactoring.