CS 247
=

```c++
#include <iostream>
using namespace std;

int main() {
    Rational r, s;
    cout << "Enter rational number (a/b): ";
    cin >> r;
    cout << "Enter rational number (a/b): ";
    cin >> s;

    Rational t(r + s);
    cout << r + s << endl;
    cout << r * s << endl;
    cout << r == s << endl;
}
```

- Default / copy constructors.
    ```c++
    // Using MIL (member initialization list).
    Rational::Rational(int num, int den) : numerator_(num), denominator_(den) {
        // !den <=> den == 0
        if (!den) throw "Divide by zero!";
    };

    Rational::Rational(int num) : numerator_(num), denominator_(1) {};

    Rational::Rational() : numerator_(0), denominator_(1) {};

    // But we can instead use default arguments which would look like ...
    class Rational {
    public:
        Rational(int num = 0, int den = 1) : numerator_(num), denominator_(den) {
            if (!den) throw "Divide by zero!";
        };
    };
    // This will allow for implicit conversions which may be unintuitive to the user so we can denote it with "explicit".
    ```
- Operators.
    ```c++
    Rational operator+(const Rational &lhs, const Rational &rhs) {
        // Code for adding two rationals together.
        // Two options. We can write mutators / accessors or friend function.
        return Rational(...);
    }
    ```
    **General rule**: If it doesn't need to be a member function then it shouldnt.

    We passed our operand as a const l-value reference.
    - Behaves like a "const pointer with automatic dereferencing".

### Rules for Function Overloading
- Must differ in type or number of parameters.
- Can't differ by only return type.

**Accessors (*getters*)**: Methods that return the value of a member field.     
**Mutators (*setters*)** :Methods that allow for the setting of member fields.

These restrict the usage of member fields to only those we give access to through the public interface. They also allow usage of member fields only under our ADT's terms / supervision.

### Common Naming Conventions
- attribute, getAttribute(), setAttribute().
- attribute_, attribute(), attributeIs().

## Should it be a member?
> Only if it has to be.
- Constructors, destructors, accessors, mutators.
- Virtual methods.
- Cannot be written with only our ADT's provided public interface (need's access to internals).
    - Could also be a friend. Usually only if it can't be a member function.
- Certain operators (as per C++ standard) must be members.
    - operator=, operator[], operator(), operator->, operator T (where T is a type).
- Certain functions can't / shouldn't be members.
    - Input and output operators.
    ```c++
    class Rational {
        istream &operator>> (istream &in) {
            // Read from in;
            return in;
        }
    };

    int main() {
        Rational r;
        // If we defined operator>> as above.
        r >> cin;
        // We also would not be able to chain reasonably.
        Rational rr;
        rr >> (r >> cin);
        // So we want to stream to be the left-hand side operand.
    }
    ```
    ```c++
    istream &operator>>(istream &in, Rational &r) {
        char slash;
        int n, d;
        in >> n >> slash >> d;
        r.numeratorIs(n);
        r.denominatorIs(d);
        return in;
    }

    ostream &operator<<(ostream &out, const Rational &r) {
        // We need to make sure that the accessors are declared const.
        out << r.numerator() << '/' << r.denominator();
        return out;
    }
    ```
- In general, prefer **non-member**, **non-friend** functions.
    - Offers better encapsulation.
    - Compiler ensures accesses cannot be made to private components.
    - More flexible packaging of data because you can put declarations of standalone functions wherever you want.
- If a member function needs full access and can't be a member function, then make it a **friend**.

Classes can also be friends. This is often used when we have nested classes. Alternatively, if nested class is private, it could just be a struct with full public visibility.

```c++
class Stack {
public:
    Stack();
    ~Stack();
    void push(int n);
    int pop();
    int peek();

    class Node {
        friend class Stack;
    public:
        Node(int data, Node *next);
        Node(const Node& other);
        Node &operator=(const Node &other);
        ~Node();
    private:
        int data_;
        Node *next_;
    };

private:
    Node *top_;
};
```
> Node can be private (and should be in this case) but there are some cases in which the we want the user to access the class but not the constructor (we can just make the constructor private).
```c++
Node::Node(int data, Node *next) : data_(data), next_(next) {}

// Built in copy-constructor copies all values (byte-wise) of built in types and for any object fields, calls copy-constructor. For our case, it would only be a shallow copy (next node would be shared).
Node::Node(const Node &other) : data_{data}, next_{other.next_ ? new Node(*other.next_) : nullptr} {}

Node& Node::operator=(const Node &other) {
    // Self-assignment check.
    if (this == &other) return *this;

    // We need to allocate the memory before just in case new throws an exception.
    Node *tmp = other.next_ ? new Node(*other.next_) : nullptr;

    data_ = other.data_;
    delete next;
    next_ = tmp;

    return *this;
}

Node::~Node() {
    // Calling delete on nullptr is safe
    delete next_;
}
```
## Copy and Swap Idiom
```c++
class Node {
    ...
private:
    void swap(Node &n);
}
```
```c++
#include <utility>

void Node::swap(Node &other) {
    std::swap(data_, other.data_);
    std::swap(next_, other.next_);
}

Node& Node::operator=(const Node &other) {
    // Destructor for tmp will get called which does the clean-up for us.
    Node tmp{other};
    swap(tmp);
    return *this;
}
```

## Lvalue References
```c++
Node plusOne(Node n) {
    for (Node *p = &n; p; p = p->next()) {
        p->dataIs(p->data() + 1);
    }
    return n;
}
int main() {
    Node n = new Node{0, new Node{1, new Node{2, nullptr}}};
    // m will have to be deep copied from plusOne(n).
    Node m = plusOne(n);
}
```
> lvalue is anything with a memory address.     
> rvalues are temporary objects.

To create a reference to an rvalue, you use &&. Now, we have a new important constructor and assignment operator.