<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>ece358</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../pandoc.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="ece-358">ECE 358</h1>
<h1 id="introduction">1: Introduction</h1>
<h2 id="what-is-the-internet">1.1 What <em>is</em> the Internet?</h2>
<p>Millions of connected computing devices.</p>
<ul>
<li><strong>Hosts</strong> = <strong>End systems</strong>.</li>
<li>Running <strong>network apps</strong>.</li>
</ul>
<p><strong>Protocols</strong> define <strong>format</strong>, <strong>order</strong> of messages sent and received among network entities, and <strong>actions taken</strong> on message transmission, receipt.</p>
<h2 id="network-structure">1.2 Network Structure</h2>
<ul>
<li><p><strong>Network Edge</strong>: Hosts (clients and servers). Servers are often in data centers.</p></li>
<li><p><strong>Access Networks, Physical Media</strong>: Wired, wireless communication links.</p></li>
<li><p><strong>Network Core</strong>: Interconnected routers, a network of networks.</p></li>
</ul>
<h3 id="wired-access-networks">Wired Access Networks</h3>
<blockquote>
<p>Shared <em>wireless</em> access network connects end systems to router via a base station (<em>access point</em>).</p>
</blockquote>
<p><strong>Wireless LANs</strong>: Within building (100ft), 802.11 b/g (WiFi), 11 / 54 Mbps transmission rate.</p>
<p><strong>Wide-Area Wireless Access</strong>: Provided by telco (cellular) operator. 1-10 Mbps transmission rate.</p>
<p>Hosts break application message into smaller chunks known as <strong>packets</strong>, of length <span class="math inline">L</span> bits. Packets are transmitted across the network at a transmission rate <span class="math inline">T</span>. The transmission delay is then <span class="math inline">\frac{L}{R}</span>.</p>
<h3 id="physical-media">1.3 Physical Media</h3>
<ul>
<li><strong>Bit</strong>: propagates between transmitter / receiver pairs.</li>
<li><strong>Physical Link</strong>: What lies between the transmitter and receiver.</li>
<li><strong>Guided Media</strong>: Signals propagate in solid media (copper, fiber, coax).
<ul>
<li><strong>Coaxial Cable</strong>: Two concentric copper conductors. Bidirectional. Broadband (multiple channels on cable).</li>
<li><strong>Fiber Optic Cable</strong>: Glass fiber carrying light pulses, each pulse is a bit. High speed point-to-point transmission. Low error rate because repeaters are spaced far apart, and they are immune to electromagnetic noise.</li>
</ul></li>
<li><strong>Unguided Media</strong>: Signals propagate freely (radio).
<ul>
<li><strong>Radio</strong>: Signal carried in electromagnetic spectrum. Propagation environment effects (reflection, obstruction, interference).</li>
</ul></li>
<li><strong>Twisted Pair (<em>TP</em>)</strong>: Two insulated copper wires.</li>
</ul>
<h3 id="network-core">1.4 Network Core</h3>
<blockquote>
<p>Mesh of interconnected routers.</p>
</blockquote>
<h3 id="packet-switching">Packet Switching</h3>
<p>Hosts break application-layer messages into <strong>packets</strong>. Packets are forwarded from one router to the next, across links on a path from source to destination.</p>
<ul>
<li><strong>Store and forward</strong>: Entire packet must arrive at router before it can be transmitted to the next link.</li>
<li><strong>End-end delay</strong>: <span class="math inline">\frac{2L}{R}</span> assuming zero propagation delay.</li>
<li><strong>Queuing and Loss</strong>: If the arrival rate to the link exceeds the transmission rate of the link, packets can be dropped if memory (buffer) fills up.</li>
</ul>
<p>The two key network core functions are <strong>routing</strong> and <strong>forwarding</strong>.</p>
<h4 id="circuit-switching">Circuit Switching</h4>
<ul>
<li>Instead of breaking up packets into smaller messages, divide the end-end resources and assign to “calls” between source and destination.</li>
<li>Circuit segment is idle if it is not used in a call.</li>
<li>Dedicated resources allow for circuit-link (guaranteed) performance.</li>
<li>Commonly used in traditional telephone networks.</li>
</ul>
<h4 id="packet-switching-vs.circuit-switching">Packet Switching vs. Circuit Switching</h4>
<blockquote>
<p>Packet switching allows for more users to use the network.</p>
</blockquote>
<ul>
<li>Great for “bursty” data. There is no call setup, and resources are shared.</li>
<li><strong>Excessive congestion</strong> is possible which could lead to packet delay and loss. There is a need for protocols (reliable data transfer, congestion control).</li>
<li>Bandwidth guarantees are needed for audio / video applications.</li>
</ul>
<h2 id="loss-and-delay-in-networks">1.4 Loss and Delay in Networks</h2>
<blockquote>
<p>Four sources of packet delays.</p>
</blockquote>
<ol type="1">
<li><strong>Nodal Processing</strong>: Checking bit errors, determining the output link. Usually &lt; 1ms.</li>
<li><strong>Queueing Delay</strong>: Time waiting at output link for transmission. Depends on the level of congestion at the router.</li>
<li><strong>Transmission Delay</strong>: <span class="math inline">\frac{L}{R}</span>, where <span class="math inline">L</span> is the packet length and <span class="math inline">R</span> is the link bandwidth.</li>
<li><strong>Propagation Delay</strong>: <span class="math inline">\frac{d}{s}</span> where <span class="math inline">d</span> is the length of the physical link and <span class="math inline">s</span> is the propagation speed in the medium.</li>
</ol>
<p><strong>Throughput</strong>: Rate at which bits are transferred between the sender and receiver.</p>
<h2 id="internet-protocol-stack">Internet protocol stack</h2>
<p><strong>Application</strong>: Running the network applications that you want (HTTP, FTP, SMTP). Implemented using software only.<br />
<strong>Transport</strong>: Responsible for communication of processes between layers (TCP, UDP). Mainly implemented using software.<br />
<strong>Network</strong>: Responsible for routing from source to destination. Implemented using software and hardware.<br />
<strong>Link</strong>: Transferring to data between physically connected (adjacent) hubs (e.g. Computer -&gt; Router, Router -&gt; Router …). Hardware.<br />
<strong>Physical</strong>: How you are transferring physical bits on the wire. Not covered in this course.</p>
<blockquote>
<p>Before the internet, there were two extra section that were planned.</p>
</blockquote>
<p><strong>Presentation</strong>: Applications to interpret meaning of data (e.g. encryption, compression, etc.).<br />
<strong>Session</strong>: Synchronization, checkpointing.</p>
<p>If you want these features, it must be implemented in the application layer.</p>
<h3 id="encapsulation">Encapsulation</h3>
<p><strong>Switch</strong>: Link and physical layers. <strong>Router</strong>: Network, link, and physical layers.</p>
<p>Information is added from the above layer to the lower.</p>
<blockquote>
<p><strong>Transport</strong>: Segment<br />
<strong>Network Layer</strong>: Datagram<br />
<strong>Link Layer</strong>: Frame</p>
</blockquote>
<p>When passing data through, you need to pop the stack (<strong>decapsulation</strong>) and then replace (<strong>encapsulation</strong>).</p>
<h2 id="network-security">Network Security</h2>
<p>Internet was not designed with security in mind. How can bad guys attack and how can we defend? How can we design architectures that are immune to attacks.</p>
<p>In real life: Hackers hack your system and then you fix the error and catch up.</p>
<p><strong>Malware</strong> any harmful software.</p>
<blockquote>
<p><strong>Virus</strong>: Interaction required.<br />
<strong>Worm</strong>: Weakness in application you are already running.<br />
<strong>Spyware</strong>: Record keystrokes, web sites, etc.</p>
</blockquote>
<p>Infected hosts can be enrolled in <strong>botnet</strong> to help in future attacks.</p>
<h3 id="examples-of-attacks">Examples of Attacks</h3>
<p><strong>Denial of Service (DoS)</strong>: Attackers infect local computers with a worm in order to all send messages to the target at the same time. Target will be busy services request so they cannot service normal customers.</p>
<p><strong>Packet “sniffing”</strong>: Passive program that is on the link which listens to and records packets.</p>
<p><strong>IP spoofing</strong>: Send a message with a false source address.</p>
<p><strong>Routers</strong>: Implements the bottom 3 layers (network, data link, physical).</p>
<p><strong>Switches</strong>: Implements the bottom 2 layers (data link, physical).</p>
<h1 id="application-layer">2: Application Layer</h1>
<h2 id="principles-of-network-applications">2.1: Principles of network applications</h2>
<h3 id="creating-a-network-app">Creating a network app</h3>
<p>Only write to run on end systems (not on the internal network). Does not matter if they are servers or clients. We also only care about what we want to do on the application layer and then push to the transport layer which will take care of transmitting the data. This allows for fast development.</p>
<p><strong>Client-Server</strong>: Server is always on with a static IP. Client will communicate with servers (intermittent). Client IP addresses will be dynamic.</p>
<p><strong>P2P</strong>: Arbitrary end systems directly communicate. Peers request service from other peers and provide service in return (<em>self scalability</em>). There is more complex management because there is no central network that controls all uses. Security is also a big issue.</p>
<h3 id="process-communication">Process Communication</h3>
<p><strong>Process</strong>: program running within a host.</p>
<ul>
<li>Within same host, two process communication using <em>inter-process communication</em> defined by the OS.</li>
<li>Processes in different hosts communicate by exchanging messages.</li>
</ul>
<p><strong>Client process</strong>: Process that initiates communication.</p>
<p><strong>Server process</strong>: Process that waits to be contacted.</p>
<h3 id="sockets">Sockets</h3>
<blockquote>
<p>Process sends / recieves messages to / from it’s <strong>socket</strong>.</p>
</blockquote>
<p><strong>Socket</strong>: The gate between the application layer and the transport layer. Sockets are similar to doors. Sending process shoves message out of door and relies on the other side of the door to deliver message to the socket at the receiving process.</p>
<p>Example: Chrome tabs. How do we know which tab to put data? There is an identifier for each socket to route the data to the correct tab (You will always talk to port 80 of a server for HTTP requests but you will use a random port).</p>
<p><strong>Sockets</strong> consists of two parts (for now).</p>
<ol type="1">
<li>Address of host.</li>
<li>Port number.</li>
</ol>
<p>The combination of the two parts will create a <strong>unique identifier</strong> for the socket. Each process has it’s own unique socket (there are over 65k ports).</p>
<h3 id="application-layer-protocol-defines">Application Layer Protocol Defines …</h3>
<blockquote>
<p><strong>Rules</strong> for when and how process send and respond to messages.</p>
</blockquote>
<p><strong>Types of messages exchanged</strong>: Request, response.</p>
<p><strong>Message syntax</strong>: What does each field mean and how fields are delineated.</p>
<p><strong>Message semantics</strong>: What do you want the information in the fields to mean.</p>
<p>Examples of open protocols are <strong>HTTP</strong> and <strong>DNS</strong> which are defined in RFCs (<em>Request For Comments</em> is a formal document from the Internet Engineering Task Force). An example of a proprietary protocol is <strong>Skype</strong>.</p>
<h3 id="what-transport-services-does-an-application-need">What Transport Services Does an Application Need?</h3>
<blockquote>
<p>Will be implemented at the application level.</p>
</blockquote>
<ol type="1">
<li><strong>Data Integrity</strong>. Some applications require 100% data transfer whereas other applications (e.g. audio) can tolerate some loss.</li>
<li><strong>Timing</strong>. Time sensitive applications (e.g. Internet telephone, interactive games) require low delay to be <em>effective</em>.</li>
<li><strong>Throughput</strong> (How fast the data can be transferred). Some applications require a minimum amount to be <em>effective</em>.</li>
<li><strong>Security</strong>. Encryption.</li>
</ol>
<table>
<thead>
<tr class="header">
<th>Application</th>
<th>Data Loss</th>
<th>Throughput</th>
<th>Time Sensitive</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>File Transfer</td>
<td>No</td>
<td>Elastic</td>
<td>No</td>
</tr>
<tr class="even">
<td>E-Mail</td>
<td>No</td>
<td>Elastic</td>
<td>No</td>
</tr>
<tr class="odd">
<td>Web Documents</td>
<td>No</td>
<td>Elastic</td>
<td>No</td>
</tr>
<tr class="even">
<td>Real-Time AV</td>
<td>Tolerant</td>
<td>Minimum requirements</td>
<td>Yes, 100’s ms</td>
</tr>
<tr class="odd">
<td>Stored AV</td>
<td>Tolerance</td>
<td>Minimum requirements</td>
<td>Yes, few seconds</td>
</tr>
<tr class="even">
<td>Interactive Games</td>
<td>Tolerant</td>
<td>Minimum requirements</td>
<td>Yes, 100’s ms</td>
</tr>
<tr class="odd">
<td>Text Messaging</td>
<td>No</td>
<td>Elastic</td>
<td>Yes and No</td>
</tr>
</tbody>
</table>
<h3 id="internet-transport-protocol-services">Internet transport protocol services</h3>
<blockquote>
<p>What is offered by the transport layer? Which protocol should I Use? There are two main protocols …</p>
</blockquote>
<ol type="1">
<li><strong>TCP</strong> (<em>Transport Control Protocol</em>)
<ul>
<li><strong>Reliable transport</strong> between sending and receiving process. Everything will get there without errors and in order.</li>
<li><strong>Flow control</strong>: Sender won’t overwhelm receiver.</li>
<li><strong>Congestion control</strong>: Throttle sender when network is overloaded.</li>
<li><strong>Does not provide</strong>: Timing, minimum throughput guarantee, security.</li>
<li><strong>Connection-oriented</strong>: Setup required between client and server processes.</li>
</ul></li>
<li><strong>UDP</strong> (<em>User Datagram Protocol</em>)
<ul>
<li><strong>Unreliable data transfer</strong>: No data integrity or reliability between sending and receiving process.</li>
<li><strong>Does not provide</strong>: Reliability, flow control, congestion control, timing, throughput guarantee, security, or connection setup.</li>
</ul></li>
</ol>
<p>Why bother with UDP?</p>
<ul>
<li><strong>UDP</strong> is faster than <strong>TCP</strong>. There is no connection setup.</li>
<li>There are no <strong>overhead</strong> bits required.</li>
</ul>
<table>
<thead>
<tr class="header">
<th>Application</th>
<th>Application Protocol</th>
<th>Transport Protocol</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Email</td>
<td>SMTP</td>
<td>TCP</td>
</tr>
<tr class="even">
<td>Remote Terminal Access</td>
<td>Telnet</td>
<td>TCP</td>
</tr>
<tr class="odd">
<td>Web</td>
<td>HTTP</td>
<td>TCP</td>
</tr>
<tr class="even">
<td>File Transfer</td>
<td>FTP</td>
<td>TCP</td>
</tr>
<tr class="odd">
<td>Streaming Multimedia</td>
<td>HTTP, RTP</td>
<td>TCP or UDP (Usually UDP)</td>
</tr>
<tr class="even">
<td>Internet Telephone</td>
<td>SIP, RTP</td>
<td>TCP or UDP</td>
</tr>
</tbody>
</table>
<h3 id="securing-tcp">Securing TCP</h3>
<p><strong>TCP</strong> and <strong>UDP</strong> have no encryption. Plaintext passwords send into sockets.</p>
<p>If you want security, you can use <strong>SSL</strong> (<em>secury socket layer</em>) which provides encryption for <strong>TCP</strong> connection. <strong>SSL</strong> is used at the application layer (need to use a <strong>SSL</strong> library such as OpenSSL).</p>
<h2 id="web-and-http">2.2: Web and HTTP</h2>
<blockquote>
<p>A <em>web page</em> consists of <em>objects</em>. (HTML, JPEG, Java applet, auto file, …).</p>
</blockquote>
<ul>
<li>Web page consists of <strong>base HTML-file</strong> which includes several referenced objects.</li>
<li>Each object is addressable by a <strong>URL</strong> (Uniform Resource Locator).</li>
</ul>
<p><strong>HTTP</strong> (hypertext transfer protocol): We have a client / server model. The client sends requests to the server and the server replies with an HTTP request.</p>
<ol type="1">
<li>HTTP uses TCP. The client initiates TCP connection (creates socket) to server, port 80. (A random port is used on the client side).</li>
<li>Server accepts TCP connection from client.</li>
<li>HTTP messages (application-layer protocol messages) exchanged between browser (HTTP client) and Web server (HTTP server).</li>
<li>TCP connection closed.</li>
</ol>
<p><em>HTTP is “stateless”</em>. The server maintains no information about past client requests.</p>
<blockquote>
<p>Protocols that maintain “state” are complex. Past history must be maintained and if the client / server crashes, their views of the “state” may be inconsistent.</p>
</blockquote>
<h3 id="types-of-http-connections">Types of HTTP Connections</h3>
<ol type="1">
<li><strong>Non-Persistent HTTP</strong>
<ul>
<li>At most one object sent over TCP connection.</li>
<li>Downloading multiple objects requires multiple connections.</li>
<li>Server is free more frequently to server other users.</li>
</ul></li>
<li><strong>Persistent HTTP</strong>
<ul>
<li>Multiple objects sent over a single TCP connection.</li>
<li>Avoid excessive overhead when requesting multiple objects.</li>
</ul></li>
</ol>
<h3 id="response-time">Response Time</h3>
<p><strong>RTT</strong> (<em>Round Trip Time</em>): Time it takes a small packet to travel from client to server and back.</p>
<p><strong>HTTP Response Time</strong></p>
<ul>
<li>One RTT to initiate TCP</li>
<li>One RTT for HTTP request and first few bytes of HTTP response in return.</li>
<li>File transmission time (<em>transmission delay</em>).</li>
</ul>
<blockquote>
<p>Non-Persistent HTTP Response Time = 2RTT + transmission time.<br />
Persistent HTTP Response Time = RTT + n(RTT + transmission time).</p>
</blockquote>
<p>For non-persistent HTTP, we require 2 RTT per object. There is OS overhead for <em>each</em> TCP connection. Browsers often open parallel TCP connections to fetch referenced objects.</p>
<p>For persistent HTTP, subsequent HTTP messages between client / server will be over the same connection so the client will sent requests as soon as it encounters a referenced object. There is as little as on RTT per referenced object.</p>
<h3 id="http-request">HTTP Request</h3>
<p><img src="https://i.imgur.com/loyZ7qQ.png" /></p>
<ul>
<li>Request Line (method URL version).</li>
<li>Header Lines (header_field_name value).</li>
</ul>
<h3 id="http1.0">HTTP/1.0</h3>
<ul>
<li>GET (request data).</li>
<li>POST (send data).</li>
<li>HEAD (leave requested object out of response).</li>
</ul>
<h3 id="http1.1">HTTP/1.1</h3>
<ul>
<li>PUT (uploads file in entry to path specified in URL).</li>
<li>DELETE (delete files specified in URL).</li>
</ul>
<h3 id="http-response">HTTP Response</h3>
<p><img src="https://i.imgur.com/gvVkbUt.png" /></p>
<ul>
<li>Status Line (protocol status_code status_phrase).</li>
<li>Header Lines (content_length).</li>
<li>Data Requested (e.g. HTML file).</li>
</ul>
<h3 id="cookies">Cookies</h3>
<blockquote>
<p>Used to identify users. ID is stored in client side which is sent in the header of subsequent messages.</p>
</blockquote>
<ol type="1">
<li>Cookie header line in HTTP <em>response</em> from server.</li>
<li>Cookie header line in next HTTP <em>request</em> from client.</li>
<li>Cookie file kept client-side.</li>
<li>Back-end database for server.</li>
</ol>
<p>Cookies are used to keep <strong>state</strong>.</p>
<h3 id="web-caches-proxy-server">Web Caches (Proxy Server)</h3>
<blockquote>
<p>Satisfy client request without involving the original server.</p>
</blockquote>
<p>All requests are sent through a proxy server instead which caches requests and responses. If the request is already cached, it does not have to travel all the way to the original server.</p>
<ul>
<li>Typically the cache is installed by ISP.</li>
</ul>
<p>Example:</p>
<blockquote>
<p>Average object size: <span class="math inline">100\ K bits</span>.<br />
Average request rate: <span class="math inline">15\ /\ sec</span>.<br />
RTT from institutional router to original server: <span class="math inline">2\ sec</span><br />
Access link rate: <span class="math inline">1.54\ Mbps</span></p>
<p>We then have LAN utilization: <span class="math inline">\frac{1.5\ Mbps}{1\ Gbps} = 0.15\%</span><br />
Access link utilization: <span class="math inline">\frac{1.5\ Mbps}{1.54\ Mbps} = 97.4\%</span><br />
Total Delay = Internet Delay + Access Delay + LAN Delay<br />
Access Delay: <span class="math inline">\frac{100\ K}{(1 - 0.974)1.54\ Mbps}</span>. (New users can only use whatever is left of the access link).<br />
LAN Delay: <span class="math inline">\frac{100\ K}{(1 - 0.0015)1\ Gbps}</span><br />
Total Delay <span class="math inline">= 2 + 2.5 + 0.0001</span></p>
</blockquote>
<p>Solutions:</p>
<ol type="1">
<li><p>Get a faster access link. If the access link rate was increased to <span class="math inline">154\ Mbps</span>, the access link delay drops to <span class="math inline">0.0007</span> so the total delay is only <span class="math inline">2</span> sec.</p></li>
<li><p>Caching. If the cache hit rate was 0.4, 40% of requests are satisfied at the cache. The data rate to browsers over the access link is <span class="math inline">0.6 \cdot 1.50\ Mbps = 0.9\ Mbps</span>. Utilization becomes <span class="math inline">0.58</span>. Total Delay <span class="math inline">= 0.6 \cdot</span>(delay from original servers) + <span class="math inline">0.4 \cdot</span>(delay when satisfied by the cache) <span class="math inline">= 0.6(2.15) = 1.29\ sec</span>.</p></li>
</ol>
<p><strong>Conditional GET</strong> - If the cache has an up-to-date version, don’t send the object. - The web server sends a conditional get with the <em>If-modified-since</em>. - Response code <strong>304 Not Modified</strong> if the cached version is fine. - Response code <strong>200 OK</strong> will send the updated data.</p>
<h2 id="dns">2.3: DNS</h2>
<blockquote>
<p>Domain Name System.</p>
</blockquote>
<p>Internet uses 32-bit IP address to identify hosts connected to the internet. The public cannot remember the real address so we use easy to remember names.</p>
<ul>
<li><strong>Distributed Database</strong>: Implemented in hierarchy of many <em>name servers</em></li>
<li>Main function is to resolve names into addresses (IP address).</li>
</ul>
<blockquote>
<p>For complex objects, we push complexity to the edge (host systems).</p>
</blockquote>
<h3 id="dns-services">DNS Services</h3>
<ul>
<li>Hostname to IP address translation.</li>
<li>Host aliasing.</li>
<li>Mail server aliasing.</li>
<li>Load distribution.
<ul>
<li>Many IP addresses correspond to the same name.</li>
</ul></li>
</ul>
<h3 id="why-not-centralize-dns">Why Not Centralize DNS?</h3>
<blockquote>
<p>Not scalable.</p>
</blockquote>
<ul>
<li>Single point of failure.</li>
<li>Traffic volume.</li>
<li>Distant centralized database.</li>
<li>Maintenance.</li>
</ul>
<h3 id="hierarchy">Hierarchy</h3>
<ul>
<li>Bottom Tier: amazon.com, umass.edu.</li>
<li>Middle Tier: com DNS servers, edu DNS servers.</li>
<li>Top Tier: Root DNS servers.</li>
</ul>
<p>If the client wants the IP for www.amazon.com.</p>
<blockquote>
<ol type="1">
<li>Queries root domain server to find com DNS server.</li>
<li>Queries .com DNS server to get amazon.com DNS server.</li>
<li>Queries amazon.com DNS server to get IP address for www.amazon.com.</li>
</ol>
</blockquote>
<h3 id="tld-servers">TLD Servers</h3>
<ul>
<li>Responsible for com, org, etc.</li>
<li>Network Solutions maintains servers for .com TLD</li>
<li>Educause for .edu TLD</li>
</ul>
<h3 id="authoritative-dns-servers">Authoritative DNS Servers</h3>
<ul>
<li>Organization’s own DNS server(s), providing authoritative hostname to IP mappings for organization.</li>
</ul>
<h3 id="local-dns-name-server">Local DNS Name Server</h3>
<ul>
<li>Each ISP has one, acts as a proxy and forwards query to hierarchy.</li>
</ul>
<p>If the host at cis.poly.edu wants IP address for gaia.cs.umass.edu.</p>
<blockquote>
<p><strong>Iterated Query</strong>: - Contacted server replies with name of server to contact. - “I don’t know this name, but ask this server”.</p>
<p><strong>Recursive Query</strong>: - Puts burden of name resolution on contacted name server. - Heavy load at upper levels of hierarchy?</p>
</blockquote>
<p>Once (any) name server learns the mapping, it <strong>caches</strong> mapping.</p>
<ul>
<li>Cache entries timeout after some time (TTL).</li>
<li>TLD servers typically cached in local name servers.</li>
<li>Cached entries may be <em>out-of-date</em> until everyone’s TTLs expire.</li>
</ul>
<h3 id="dns-records">DNS Records</h3>
<blockquote>
<p>Distributed database storing resource records (RR).</p>
</blockquote>
<p><strong>RR Format: (Name, Value, Type, TTL).</strong></p>
<ul>
<li>type = A.
<ul>
<li><strong>name</strong> is hostname.</li>
<li><strong>value</strong> is IP address.</li>
<li>(www.amazon.com, 220.180.90.10, A, TTL).</li>
</ul></li>
<li>type = NS.
<ul>
<li><strong>name</strong> is domain (e.g. foo.com).</li>
<li><strong>value</strong> is hostname of authorative name server for this domain.</li>
<li>(uwaterloo.ca, dns.uwaterloo.ca, NS, TTL).</li>
</ul></li>
<li>type = CNAME.
<ul>
<li><strong>name</strong> is alias name for some “canonical” (the real) name.</li>
<li><strong>value</strong> is canonical name.</li>
<li>(www.ibm.com, servereast.backup2.ibm.com, CNAME, TTL).</li>
</ul></li>
<li>type = MX.
<ul>
<li><strong>value</strong> is the name fo mailserver associated with <strong>name</strong>.</li>
</ul></li>
</ul>
<h3 id="dns-protocol-messages">DNS Protocol, Messages</h3>
<blockquote>
<p><em>Query</em> and <em>reply</em> messages have the same <em>message format</em>.</p>
</blockquote>
<p><strong>msg Header</strong>:</p>
<blockquote>
<p>Chapter 2 slides have a better visualization for format.</p>
</blockquote>
<ul>
<li><strong>Identification</strong> (<em>2 bytes</em>)16 bit number for query, reply to user uses the same number.</li>
<li><strong>Flags</strong> (<em>2 bytes</em>):
<ul>
<li>Query or reply.</li>
<li>Recursion desired.</li>
<li>Recursion available.</li>
<li>Reply is authoritative.</li>
</ul></li>
<li><strong>Questions</strong>: Name, type fields for a query.</li>
<li><strong>Answers</strong>: RRs in response to a query.</li>
<li><strong>Authority</strong>: Records for authoritative servers.</li>
<li><strong>Additional Info</strong>: Additional “helpful” info that may be used.</li>
</ul>
<h3 id="attacking-dns">Attacking DNS</h3>
<ol type="1">
<li>DDoS Attacks.
<ul>
<li>Bombard root servers with traffic.
<ul>
<li>Not successful to date.</li>
<li>Traffic filtering (not all traffic provided to root servers).</li>
<li>Local DNS servers cache IPs of TLD servers, allow the root server to be bypassed.</li>
</ul></li>
<li>Bombard TLD servers.
<ul>
<li>Potentially more dangerous.</li>
</ul></li>
</ul></li>
<li>Redirect Attacks.
<ul>
<li>Man-in-middle.
<ul>
<li>Attacker intercepts query and returns a <em>modified</em> response. They can redirect you to their own websites.</li>
</ul></li>
<li>DNS poisoning.
<ul>
<li>Inserts an incorrect record to the DNS server.</li>
</ul></li>
</ul></li>
<li>Exploit DNS for DDoS.
<ul>
<li>Use already existing DNS to attack.</li>
<li>Send a DNS query and claim it is from the victim.
<ul>
<li>The victim is busy processing all of the responses.</li>
</ul></li>
<li>Requires amplification (difficult to launch because you need to query many servers at the same time).</li>
</ul></li>
</ol>
<h1 id="transport-layer">3: Transport Layer</h1>
<h2 id="transport-layer-services">3.1: Transport-Layer Services</h2>
<ul>
<li>Provides <strong>logical communication</strong> between a process on the source to a process on the receiver.</li>
<li>Transport protocols run in end systems.
<ul>
<li>Source side: breaks app messages into <em>segments</em>, passes into network layer.</li>
<li>Receiving side: Reassembles segments into <em>messages</em>, passes to the application layer.</li>
</ul></li>
<li>More than one transport protocol available to apps.
<ul>
<li>Internet: TCP and UDP.</li>
</ul></li>
</ul>
<h3 id="transport-layer-vs.network-layer">Transport Layer vs. Network Layer</h3>
<ul>
<li><strong>Network layer</strong>: Logical communication between hosts.</li>
<li><strong>Transport layer</strong>: Logical communication between processes.
<ul>
<li>Relies on enhanced network layer services.</li>
</ul></li>
</ul>
<p><strong>Household Analogy</strong></p>
<blockquote>
<p>12 kids in Ann’s house sending letters to 12 kids in Bill’s house. - <strong>hosts</strong>: houses. - <strong>processes</strong>: kids. - <strong>app messages</strong>: letters in envelopes. - <strong>transport protocol</strong>: Ann and Bill who demux to in-house siblings. - <strong>network protocol</strong>: postal service.</p>
</blockquote>
<h3 id="internet-transport-layer-protocols">Internet Transport-Layer Protocols</h3>
<ul>
<li>Reliable, in-order delivery (TCP).
<ul>
<li>Congestion control (about the network itself).</li>
<li>Flow control (sender will not overflow the receiver).</li>
<li>Connection setup.</li>
</ul></li>
<li>Unreliable, unordered delivery (UDP).
<ul>
<li>No-frills extension of <em>best-effort</em> IP.</li>
</ul></li>
<li>Services not available are <strong>delay guarantees</strong> and <strong>bandwidth guarantees</strong>.</li>
</ul>
<h2 id="multiplexing-demultiplexing">3.2: Multiplexing / Demultiplexing</h2>
<p><strong>Multiplexing at sender</strong>: Handle data from multiple sockets, add transport header (later used for demultiplexing).</p>
<p><strong>Demultiplexing at receiver</strong>: Use header info to deliver received segments to the correct socket.</p>
<h3 id="how-demultiplexing-works">How Demultiplexing Works</h3>
<ul>
<li>Host receives IP datagrams.
<ul>
<li>Datagram has a source IP address, destination IP address.</li>
<li>Datagram carries one transport-layer segment.</li>
<li>Segment has source, destination port number.</li>
</ul></li>
<li>Host uses <em>IP addresses</em> and <em>port numbers</em> to direct segment to appropriate socket.</li>
</ul>
<h3 id="connectionless-demultiplexing">Connectionless Demultiplexing</h3>
<ul>
<li>When creating a datagram to send into UDP socket, we must specify the destination IP address and port number.</li>
<li>When a host receives a UDP segment, it checks the destination port number and directs the segment to the proper socket.</li>
<li>If IP datagram shave the same destination port but different source IP addresses or source port, numbers will be directed to the <strong>same socket</strong> at the destination.</li>
</ul>
<h3 id="connection-oriented-demux">Connection-oriented Demux</h3>
<ul>
<li>TCP socket identified by a 4 tuple: (source IP address, source port number, destination IP address, destination port number).</li>
<li>Web servers have different sockets for each connecting client.
<ul>
<li>Non-persistent HTTP will have a different socket for each request. Multiple segments will be sent to the host at port 80 but will be demultiplexed to different sockets.</li>
</ul></li>
</ul>
<h2 id="connectionless-transport-udp">3.3 Connectionless Transport: UDP</h2>
<blockquote>
<p>When we want the speed to be as fast as possible and we are loss tolerant.</p>
</blockquote>
<ul>
<li>“No frills”, “bare bones” Internet transport protocol.</li>
<li>“Best effort” service, UDP segments may be lost or delivered out-of-order to app.</li>
<li><strong>Connectionless</strong> meaning that there is no handshaking between UDP sender and receiver. Each UDP segment is handled independently of others.</li>
<li>UDP is used in streaming multimedia apps, DNS, SNPM (Simple Network Management Protocol).</li>
<li>Reliable transfer over UDP can be achieved by adding reliability at the application layer such as application-specific error recovery.</li>
</ul>
<p>UDP adds a segment header of 64 bits. The first 32 are used for the source port number and the destination port number. The next 16 are used for the length in bytes of the segment (including header), and the final 16 are used for <strong>checksum</strong>.</p>
<h3 id="udp-checksum">UDP Checksum</h3>
<blockquote>
<p>We want to detect “errors” (e.g. flipped bits) in transmitted segmet.</p>
</blockquote>
<p>The sender treats the segment’s contents as a sequence of 16-bit integers. The checksum is the addition (one’s complement sum) of segment contents. The receiver then computes their own checksum and compares. (When adding numbers, a carryout from the msb gets re-added to the result).</p>
<h2 id="principles-of-reliable-data-transfer">3.4 Principles of Reliable Data Transfer</h2>
<ul>
<li>When we have a reliable channel, we do not have to worry about reliable data transfer.</li>
<li>Characteristics of unreliable channels will determine the complexity of reliable data transfer protocol (rdt).</li>
</ul>
<p>rdt_send() is called from the application layer whenever we have data to send which passes udt_send() to transfer the packet over the unreliable channel to receiver. It is received by rdt_rcv() which gets passed to the protocol on the transport layer. After some processing, it is passed to the upper application layer through deliver_data().</p>
<h3 id="rdt-1.0-reliable-transfer-over-a-reliable-channel.">RDT 1.0: Reliable transfer over a reliable channel.</h3>
<blockquote>
<p>Underlying channel is perfectly reliable. There are no bit errors and no loss of packets.</p>
</blockquote>
<p>We have separate Finite State Machines (FSMs) for sender, receiver. The sender sends data into the underlying channel and the receiver reads data from the underlying channel.</p>
<h3 id="rdt-2.0-channel-with-bit-errors">RDT 2.0: Channel with Bit Errors</h3>
<blockquote>
<p>Underlying channel may flip bits in packet which is detected by the checksum.</p>
</blockquote>
<ul>
<li><strong>ACKs</strong> (<em>acknowledgements</em>): The receiver explicitly tells sender that the packet was received ok.</li>
<li><strong>NAKs</strong> (<em>negative acknowledgements</em>): The receiver explicitly tells sender that the packet has errors.
<ul>
<li>Sender retransmits packet on receipt of NAK.</li>
</ul></li>
<li>The sender needs to add a checksum to the data and will wait for ACK or NAK.</li>
<li>There is a <strong>fatal flaw</strong> because if ACK / NAK is corrupted, the sender does not know what happened at the receiver.</li>
</ul>
<h4 id="rdt-2.1">RDT 2.1</h4>
<ul>
<li>The sender retransmits the current packet if ACK / NAK is corrupted and adds a <em>sequence number</em> to each packet.
<ul>
<li>We only need 2 sequence numbers (0, 1) so that we can distinguish between consecutive messages.</li>
</ul></li>
<li>The receiver discards duplicate packets.</li>
</ul>
<blockquote>
<p><strong>Stop and Wait</strong> protocol: sender sends 1 packet and then waits for receiver response.</p>
</blockquote>
<h4 id="rdt-2.2-nak-free">RDT 2.2: NAK-free</h4>
<ul>
<li>We can have less state transitions if we only use ACKs.</li>
<li>The receiver can send a packet number as well.</li>
<li>Duplicate ACK at sender results in the same action as NAK: <em>retransmit the current packet</em>.</li>
</ul>
<h3 id="rdt-3.0-channels-with-errors-and-loss">RDT 3.0: Channels with Errors <em>and</em> Loss</h3>
<blockquote>
<p>Now the underlying channel can also lose packets (data, ACKs).</p>
</blockquote>
<ul>
<li>Checksum, sequence number, ACKs, retransmission will be of help … but it is not enough.</li>
</ul>
<blockquote>
<p>The sender will wait a “reasonable” amount of time for ACK. It will retransmit if no ACK is received in time.</p>
</blockquote>
<ul>
<li>If packet of ACK is delayed (not lost), the retransmission would be a duplicate, but we already handle this with sequence numbers.</li>
<li>This approach works but the performance is bad.
<ul>
<li>Example: 1 Gbps link, 15 ms propagation delay, 8000 bit packet.</li>
</ul>
<blockquote>
<p><span class="math inline">D_{trans} = \frac{L}{R} = \frac{8000\ bits}{10^9\ bits/sec} = 8\ \mu s</span>.<br />
<span class="math inline">U_{sender}</span>: <strong>utilization</strong>, the fraction of the time the sender is busy sending.<br />
<span class="math inline">U_{sender} = \frac{L/R}{RTT + L/R} = \frac{0.008}{30.008} = 0.00027</span>.</p>
</blockquote>
<ul>
<li>Throughput is just the utilization multiplied by the link rate.</li>
</ul></li>
<li>The solution is to transfer more packets!</li>
</ul>
<h2 id="pipelined-protocols">Pipelined Protocols</h2>
<blockquote>
<p>Sender allows multiple, “in-flight”, packets. - The range of sequence numbers must be increased. - There is buffering at the sender and / or receiver.</p>
</blockquote>
<h3 id="go-back-n">Go-Back-N</h3>
<ul>
<li>The sender can have up to N unACKed packets in a pipeline.</li>
<li>The receiver only sends a <strong>cumulative ACK</strong> (doesn’t ACK packet if there is a gap).</li>
<li>Sender has a timer for the oldest unACKed packet. When the timer expires, it retransmits <em>all</em> unACKed packets.</li>
<li>Any out of order packet (at the receiver) or duplicate ACK (at the sender) will be discarded.</li>
</ul>
<h3 id="selective-repeat">Selective Repeat</h3>
<ul>
<li>The sender can have up to N unACKed packets in the pipeline.</li>
<li>The receiver sends <strong>individual ACK</strong> for each packet.</li>
<li>Sender maintains a timer for each unACKed packet and only transmits that specific packet when the timer expires.</li>
</ul>
<h4 id="sender">Sender</h4>
<ul>
<li><strong>Data from above</strong>: If next available sequence number in window, send packet.</li>
<li><strong>Timeout(<span class="math inline">n</span>)</strong>: Resent packet <span class="math inline">n</span>, restart timer.</li>
<li><strong>ACK(<span class="math inline">n</span>)</strong> (<span class="math inline">n \in [send\_base, send\_base + N - 1]</span>): Mark packet <span class="math inline">n</span> as received, if <span class="math inline">n</span> is the smallest unACKed packet, advance the window base to the next unACKed sequence number.</li>
</ul>
<h4 id="receiver">Receiver</h4>
<ul>
<li><strong>Packet <span class="math inline">n \in [rcv\_base, rcv\_base + N - 1]</span></strong>: Send ACK(<span class="math inline">n</span>). If <span class="math inline">n</span> is out of order we need to buffer. If <span class="math inline">n</span> is in order, we can deliver until the next not received packet.</li>
<li><strong>Packet <span class="math inline">n \in [rcn\_base - N, rcv\_base - 1]</span></strong>: ACK(<span class="math inline">n</span>) (We need to acknowledge duplicate packets to move the sender’s window).</li>
</ul>
<p><strong>Selective Repeat: Dilemma</strong>: While sliding windows, we may accidentally accept old data as new. The problem is that the receiver knows nothing about the sender. We can <em>fix</em> this by setting the window size to be equal to less than half of the sequence number space.</p>
<h3 id="performance-of-sliding-window">Performance of Sliding Window</h3>
<p><strong>No Errors</strong>: <span class="math inline">\rho = \min(1, \frac{W\frac{L}{C}}{t_T})</span>.</p>
<h2 id="automatic-repeat-request-arq-protocols">Automatic Repeat Request (<em>ARQ</em>) Protocols</h2>
<blockquote>
<p>Applied at the transport and link layers.</p>
</blockquote>
<ol type="1">
<li>Stop-and-Wait Protocol.</li>
<li>Go-Back-N.</li>
<li>Selective Repeat.</li>
</ol>
<h2 id="connection-oriented-transport-tcp">3.5 Connection-Oriented Transport: TCP</h2>
<ul>
<li><strong>Connection-Oriented</strong>: Handshaking (exchanging control messages), initializes sender and receiver state before data exchange.</li>
<li><strong>Point-To-Point</strong>: One sender, one receiver.</li>
<li><strong>Reliable, In-Order <em>Byte</em> Steam</strong>: No “message boundaries”, byte by byte.</li>
<li><strong>Full Duplex Data</strong>: Bidirectional. MSS: Maximum Segment Size.</li>
<li><strong>Pipelined</strong>: TCP congestion and flow control set window size.</li>
<li><strong>Flow Controlled</strong>: Sender will not overwhelm receiver.</li>
</ul>
<h3 id="tcp-segment-structure">TCP Segment Structure</h3>
<ul>
<li>16 bits for source port number, 16 for destination port number.</li>
<li>32 bits for sequence number (for the bytes).</li>
<li>Acknowledgement number (for the bytes).</li>
<li>Header length, not used (URG: urgent data, ACK: ACK # valid, PSH: push data now, RST, SYS, FIN: connection establishment).</li>
<li>Receive window for the number of bytes the receiver is willing to accept.</li>
<li>16 bits for checksum, URG data pointer for the last byte of urgent data (16 bits).</li>
<li>Options (variable length).</li>
<li>Application data (variable length).</li>
</ul>
<p>Default header length is 20 bytes compared to UDP 8 bytes.</p>
<p>Acknowledgements include the sequence number of the next byte expected from the other side (cumulative ACK). The TCP spec doesn’t say how to handle out-of-order segments, it is up to the implementer. There are two choices, discard or buffer. Buffering is used in practice.</p>
<h3 id="tcp-round-trip-time-timeout">TCP Round Trip Time, Timeout</h3>
<blockquote>
<p>How to set TCP timeout value?</p>
</blockquote>
<p>It should be longer than the RTT, but the RTT varies. If it is too short, we will have unnecessary retransmissions. If it is too long, we will have slow reactions to segment loss.</p>
<p>We estimate RTT by sampling from segment transmissions. <span class="math inline">SampleRTT</span> is the measured time from segment transmission to ACK receipt (ignoring retransmissions). We use an exponential weighted moving average, <span class="math inline">EstimatedRTT = (1 - \alpha)\cdot EstimatedRTT + \alpha \cdot SampleRTT</span>. The typical value is <span class="math inline">\alpha = 0.125</span>.</p>
<p>Is this estimation enough? We want to add a <em>safety margin</em> so that a large variation in <span class="math inline">EstimateRTT</span> results in a larger safety margin. We use 4 standard deviations. <span class="math inline">DevRTT = (1 - \beta)\cdot DevRTT + \beta \cdot |SampleRTT - EstimatedRTT|</span>. The typical value is <span class="math inline">\beta = 0.25</span>.</p>
<p>The timeout interval is then <span class="math inline">TimeoutInterval = EstimatedRTT + 4 \cdot DevRTT</span>.</p>
<h3 id="tcp-reliable-data-transfer">TCP Reliable Data Transfer</h3>
<p>TCP Created a RDT service on top of IP’s unreliable service. It uses pipelined segments, cumulative ACKs, and single retransmission timer (similar to Go-Back-N). Retransmission are triggered by timeouts or duplicate ACKs.</p>
<p>Let’s initially consider a simplified TCP sender with no duplicate ACKs and ignoring flow / congestion control.</p>
<h3 id="tcp-sender-events">TCP Sender Events:</h3>
<blockquote>
<p>Three major events in sender.</p>
</blockquote>
<ol type="1">
<li>Data received from application layer.
<ul>
<li>Create segment with sequence number.</li>
<li>Sequence number is byte-stream number of the first data byte in the segment.</li>
<li>Start timer if not already running.</li>
</ul></li>
<li>Timeout.
<ul>
<li>Retransmit segment that caused timeout.</li>
<li>Restart timer.</li>
</ul></li>
<li>ACK received.
<ul>
<li>If ACK acknowledges previously unACKed segments, we update and then start timer if there are still unACKed segments.</li>
</ul></li>
</ol>
<h3 id="tcp-ack-generation">TCP ACK Generation</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Event At Receiver</th>
<th>TCP Receiver Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Arrival of in-order segment with expected sequence number. All data up to the expected sequence number are already ACKed.</td>
<td>Delayed ACK. Wait up to 500ms for the next segment. If no next segment, send ACK.</td>
</tr>
<tr class="even">
<td>Arrival of in-order segment with expected sequence number. One other segment has ACK pending.</td>
<td>Immediately send single cumulative ACK, ACKing both in-order segments.</td>
</tr>
<tr class="odd">
<td>Arrival of out-of-order segment (heigher than expected sequence number). Gap detected.</td>
<td>Immediately send <em>duplicate ACK</em>, indicating sequence number of the next expected byte.</td>
</tr>
<tr class="even">
<td>Arrival of segment that partially or completely fills the gap.</td>
<td>Immediate send ACK, provided that the segment starts at the lower end of the gap.</td>
</tr>
</tbody>
</table>
<h3 id="tcp-fast-retransmit">TCP Fast Retransmit</h3>
<p>If you receive 3 duplicate ACKs, it is an indicator that a packet has been lost. The sender will retransmit immediately instead of waiting for the timeout.</p>
<h3 id="tcp-flow-control">TCP Flow Control</h3>
<blockquote>
<p>Receiver controls sender, so that the sender won’t overflow receiver’s buffer by transmitting too much, too fast.</p>
</blockquote>
<p>Applications may remove data from TCP socket buffers slower than the TCP receiver is delivering (sender is sending).</p>
<ul>
<li>Receiver “advertises” free buffer space by including <strong>rwnd</strong> value in the TCP header of receiver-to-sender segments.
<ul>
<li><strong>RcvBuffer</strong> size is set via socket options (typical default is 4096 bytes).</li>
<li>Many operating systems auto adjust <strong>RcvBuffer</strong>.</li>
</ul></li>
<li>Sender limits the amount of unACKed (<em>in-flight</em>) data to the receiver’s <strong>rwnd</strong> value.</li>
<li>This guarantees that the buffer will not overflow.</li>
</ul>
<h3 id="connection-management">Connection Management</h3>
<blockquote>
<p>Before exchanging data, the sender and receiver “handshake” (agree to establish connection, agree on connection parameters).</p>
</blockquote>
<h2 id="principles-of-congestion-control">3.6 Principles of Congestion Control</h2>
<blockquote>
<p>Too many sources sending too much data too fast for the <strong>network</strong> to handle.</p>
</blockquote>
<ul>
<li>Different from flow control.</li>
<li>Manifests as lost packets (buffer overflow at routers) and long delays (queueing in router buffers).</li>
</ul>
<h3 id="causes-costs-of-congestion">Causes / Costs of Congestion</h3>
<ol type="1">
<li>Infinite buffer, 2 senders and 2 receivers use the same link with an output link capacity of <span class="math inline">R</span>.
<ul>
<li>Maximum per-connection throughput: <span class="math inline">\frac{R}{2}</span>.</li>
<li>Large delay as the arrival rate <span class="math inline">\lambda_{in}</span> approaches <span class="math inline">\frac{R}{2}</span>.</li>
</ul></li>
<li>Finite buffer. Input and output rates are the same.
<ul>
<li>Transport-layer input includes <em>retransmissions</em>: <span class="math inline">\lambda_{in}^\prime \ge \lambda_{in}</span> (<em>offered load</em>).</li>
</ul></li>
<li>Multiple routers.
<ul>
<li>One connection may take up all of the routers’ time.</li>
<li>More routers involved in delivering data means more wasted network efforts. This is the reason for sudden drop on throughput.</li>
<li>When packet is dropped, any “upstream” transmission capacity is wasted!</li>
</ul></li>
</ol>
<h3 id="approaches-to-congestion-control">Approaches to Congestion Control</h3>
<blockquote>
<p>Two broad approaches.</p>
</blockquote>
<ol type="1">
<li>End-End Congestion Control.
<ul>
<li>No explicit feedback from network.</li>
<li>Congestion inferred from end-system observed loss, delay.</li>
<li>Approach taken by TCP.</li>
</ul></li>
<li>Network-Assisted Congestion Control.
<ul>
<li>Routers provide feedback to end systems.
<ul>
<li>Single bit indicating congestion.</li>
<li>Explicit rate for sender to send at.</li>
</ul></li>
</ul></li>
</ol>
<h2 id="tcp-congestion-control">3.7 TCP Congestion Control</h2>
<blockquote>
<p>Additive increase, multiplicative decrease (<strong>AIMD</strong>).</p>
</blockquote>
<ul>
<li>Sender increases transmission rate (window size), probing for usable bandwidth, until loss occurs.
<ul>
<li>Increase <strong>cwnd</strong> by 1 MSS (<em>maximum signal size</em>) every RTT until loss detected.</li>
<li>Cut <strong>cwnd</strong> in half after loss.</li>
</ul></li>
<li>Recall that the sender limits transmission.
<ul>
<li><span class="math inline">LastByteSent - LastByteAcked \le \min(cwn, cwnd)</span>.</li>
</ul></li>
<li>TCP sending rate is roughly sending <strong>cwnd</strong> bytes, then waiting an RTT for ACKs.
<ul>
<li><span class="math inline">\frac{cwnd}{RTT}</span> bytes / sec.</li>
</ul></li>
</ul>
<h3 id="tcp-slow-start">TCP Slow Start</h3>
<ul>
<li>Initially <strong>cwnd</strong> is 1 MSS and is doubled for every RTT.
<ul>
<li>This is done by incrementing <strong>cwnd</strong> for every ACK received.</li>
</ul></li>
<li>Initial rate is slow but ramps up exponentially fast.</li>
</ul>
<h3 id="detecting-reacting-to-loss">Detecting, Reacting to Loss</h3>
<ul>
<li>Loss indicated by timeout.
<ul>
<li><strong>cwnd</strong> set to 1 MSS.</li>
<li>Window then grows exponentially (as in slow start) to the threshold, then grows linearly.</li>
</ul></li>
<li>Loss indicated by 3 duplicate ACKs (<em>TCP RENO</em>).
<ul>
<li>Duplicate ACKs indicate that the network is capable of delivering some segments.</li>
<li><strong>cwnd</strong> is cut in half and then the grows linearly.</li>
</ul></li>
<li>(<em>TCP TAHOE</em>) always sets <strong>cwnd</strong> to 1 (timeout of 3 duplicate ACKs).</li>
</ul>
<h3 id="switching-from-slow-start-to-ca-congestion-avoidance">Switching from Slow Start to CA (<em>Congestion Avoidance</em>)</h3>
<blockquote>
<p>When should the exponential increase switch to linear?<br />
When <strong>cwnd</strong> gets to <span class="math inline">\frac{1}{2}</span> of its value before timeout.</p>
</blockquote>
<p>Implemented with a variable <strong>ssthresh</strong>. On a loss event, <strong>ssthresh</strong> is set to <span class="math inline">\frac{1}{2}</span> of <strong>cwnd</strong> before loss event.</p>
<h3 id="tcp-throughput">TCP Throughput</h3>
<ul>
<li>Average TCP throughput as a function of window size, RTT?
<ul>
<li>Ignore slow start, assume we always have data to send.</li>
</ul></li>
<li>Throughput fluctuates between the max of <span class="math inline">\frac{W}{RTT}</span> (<em>congestion</em>) and <span class="math inline">\frac{W}{2RTT}</span> (<em>after congesion, drop rate</em>).
<ul>
<li>Average window size is <span class="math inline">\frac{3W}{4}</span>.</li>
<li>Average throughput is <span class="math inline">\frac{3W}{4RTT}</span> bytes / sec.</li>
</ul></li>
</ul>
<p>Example: Average Throughput = 10 Gbps, 100ms RTT, 1500 byte segment = 3/4 W/RTT bytes/sec Solve for W, Number of segments is W / 1500</p>
<p>Throughput in terms of segment loss probability <span class="math inline">L = \frac{1.22 \cdot MSS}{RTT \sqrt L}</span>, MSS -&gt; Maximum Segment Size.</p>
<p>To achieve a 10gbps throughput, we need a lost rate of <span class="math inline">L = 2\cdot10^{-10}</span> which is a very small loss rate.</p>
<p>We need a new version of TCP for high-speed. It is hard to implement TCP because there are hardware that implement and are hard to change.</p>
<h3 id="tcp-fairness">TCP Fairness</h3>
<blockquote>
<p><strong>Fairness goal</strong>: If <span class="math inline">K</span> TCP sessions share the same bottleneck link of bandwidth <span class="math inline">R</span>, each should have average rate of <span class="math inline">\frac{R}{K}</span>.</p>
</blockquote>
<p>Two competing sessions will have additive increase which gives slope of 1, as throughput increases. Multiplicative decrease decreases throughput proportionally.</p>
<p><img src="https://i.imgur.com/Ec9MFxB.png" /></p>
<p>Multimedia apps often do not use TCP because they do not want the rate throttled by congestion control. They send audio / video at constant rate, tolerate packet loss.</p>
<p>This is fair over each connection, but you can cheat the system by having multiple TCP connections.</p>
<h1 id="network-layer">4. Network Layer</h1>
<blockquote>
<p>Unlike the application and transport layers, the network layer is implemented <strong>every</strong> host and router.</p>
</blockquote>
<p><strong>Recall</strong>: Transport layer encapsulates the data by breaking it into segments and adding headers.</p>
<p>The network layer further encapsulates segments by adding it’s own headers.</p>
<h2 id="two-key-functions">Two Key Functions</h2>
<ol type="1">
<li><strong>Forwarding</strong>: Move packets from router’s input to appropriate router output.</li>
<li><strong>Routing</strong>: Determining route taken by packets from source to destination.</li>
</ol>
<p>Some network architectures require connection setup. Before datagrams flow, two end hosts <em>and</em> intervening routers establish virtual connection.</p>
<p><strong>Recall</strong>: Network layer connection service is between two hosts (may also involve intervening routers in case of VCs). Transport layer connection service is between two processes.</p>
<h2 id="network-service-model">Network Service Model</h2>
<ul>
<li><strong>Individual datagrams</strong>: Guaranteed delivery with less than 40ms delay.</li>
</ul>
<p><strong>ATM</strong>: Asynchronous Transfer Mode</p>
<p><img src="https://i.imgur.com/w6PLNer.png" /></p>
<p><strong>Datagram</strong> network provides network-layer connectionless service.</p>
<p>Datagrams include the IP address of the receiver. Virtual circuit cells include a virtual circuit number.</p>
<p>ATM, VC forwarding table includes some info specific to the call between sender and receiver.</p>
<h2 id="vc-implementation">VC Implementation</h2>
<ol type="1">
<li>Path from source to destination.</li>
<li>VC numbers, one number for each link along path.
<ul>
<li>VC number can be changed on each link. The new number comes from forwarding table.</li>
</ul></li>
<li>Entries in forwarding tables in routers along path.</li>
</ol>
<p>VC numbers change in order to have unique numbers between each router’s connections.</p>
<h3 id="vc-signaling-protocols">VC: Signaling Protocols</h3>
<ul>
<li>Used to setup, maintain, teardown VC.</li>
<li>Used in ATM, frame-relay, X.25</li>
<li>Not used in today’s Internet.</li>
</ul>
<h3 id="datagram-networks">Datagram Networks</h3>
<blockquote>
<p>Connectionless.</p>
</blockquote>
<ul>
<li>No call setup at network layer.</li>
<li>Routers have no state, they do not know what connection each datagram belongs to.</li>
<li>Packets are forwarding using only destination host address.</li>
</ul>
<h3 id="datagram-forwarding-table">Datagram Forwarding Table</h3>
<ul>
<li>The destination IP address in the arriving packet’s header is compared to the forwarding table. There are too many IP addresses, so rather than listing individual destination addresses, we list <em>ranges</em>.</li>
</ul>
<blockquote>
<p>What happens when the ranges don’t divide up nicely?</p>
</blockquote>
<p><strong>Longest Prefix Match</strong>: Match the IP address to an entry in the forwarding table based on the longest prefix that matches.</p>
<h2 id="datagram-or-vc-network">Datagram or VC Network?</h2>
<h3 id="datagram-internet">Datagram (Internet)</h3>
<ul>
<li>Data exchange among computers. &quot;Elastic service, no string timing requirements.</li>
<li>Many different link types with different characteristics.</li>
<li>End systems are smart so we push complexity.</li>
</ul>
<h3 id="vc-atm">VC (ATM)</h3>
<ul>
<li>Evolved from telephone.</li>
<li>Strict timing requirements, reliability requirements.</li>
<li>“Dumb” end systems and complexity is pushed to network.</li>
</ul>
<h2 id="router">4.3 Router</h2>
<blockquote>
<p>Input ports, output ports, high-seed switching fabric, routing processor.</p>
</blockquote>
<ol type="1">
<li>Running routing algorithms / protocol (RIP, OSPF, BFP).
<ul>
<li>Routing processor.</li>
<li>Update forwarding table as a result which is pushed to the input ports.</li>
</ul></li>
<li>Forward datagrams from incoming to outgoing link.
<ul>
<li>Hardware.</li>
</ul></li>
</ol>
<p><strong>Every</strong> router has three layers (network, link, physical).</p>
<h3 id="input-port-functions">Input Port Functions</h3>
<blockquote>
<p>Line termination -&gt; Link layer protocol -&gt; Lookup, forwarding, queueing.</p>
</blockquote>
<ul>
<li>Physical layer: bit-level reception.</li>
<li>Data link layer: e.g. Internet</li>
<li>Decentralized switching:</li>
</ul>
<h3 id="switching-fabrics">Switching Fabrics</h3>
<ul>
<li>Switching rate: rate at which packets can be transferred from inputs to outputs.
<ul>
<li><span class="math inline">N</span> inputs, switching rate <span class="math inline">N</span> times line rate is desirable to avoid buffering.</li>
</ul></li>
<li>Three types of switching fabrics (memory, bus, crossbar).</li>
</ul>
<h3 id="switching-via-memory">Switching via Memory</h3>
<blockquote>
<p>First generation routers.</p>
</blockquote>
<ul>
<li>Traditional computers with switching under direct control of CPU.</li>
<li>Packet copied to system’s memory.</li>
<li>Speed limited to memory bandwidth (only 2 bus crossings per datagram).
<ul>
<li>One packet maximum on the bus at a time.</li>
</ul></li>
</ul>
<h3 id="switching-via-bus">Switching via Bus</h3>
<ul>
<li>Datagram from input port memory to output port memory via a shared bus.</li>
<li><strong>Bus contention</strong>: Switching speed is limited by bus bandwidth.</li>
<li>32 Gbps bus, Cisco 5600, sufficient speed for access and enterprise routers.</li>
</ul>
<p>We can still only send one packet on the bus at a time.</p>
<h3 id="switching-via-interconnection-network">Switching via Interconnection Network</h3>
<ul>
<li>Overcome bus bandwidth limitations.</li>
<li>Banyan networks, crossbar, or other interconnected nets initially developed to connect processors in multiprocessor.</li>
<li>Advanced design, fragmenting data into fixed length cells, switch cells through the fabric.</li>
<li>Cisco 12000 switches 60 Gpbs through the interconnection network.</li>
</ul>
<h3 id="output-ports">Output Ports</h3>
<ul>
<li><strong>Buffering</strong> required if the fabric has a faster rate than the output line speed. Datagram can be lost due to congestion, lack of buffers.</li>
<li><strong>Scheduling</strong> datagrams, priority scheduling, who gets best performance, network neutrality.</li>
</ul>
<h3 id="how-much-buffering">How Much Buffering?</h3>
<ul>
<li>RFC 3439 rule of thumb is that the average buffering should be equal to “typical” RTT multiplied by the link capacity <span class="math inline">C</span>.
<ul>
<li>This is the absolute maximum amount of packets you can receive.</li>
</ul></li>
<li><p>Recent recommendation says that with <span class="math inline">N</span> flows, buffering should be equal to <span class="math inline">\frac{RTT \cdot C}{\sqrt N}</span>.</p></li>
<li><p><strong>Head-of-the-Line (<em>HOL</em>) Blocking</strong>: Queued datagram at the front of the queue prevents others in the queue from moving forward.</p>
<p><img src="https://i.imgur.com/NqVg2Pf.png" /></p></li>
</ul>
<h2 id="ip-internet-protocol">4.4 IP: Internet Protocol</h2>
<p>In the network layer, we have routing protocols, IP protocol, and ICMP protocol (<em>error reporting and router signalling</em>).</p>
<h3 id="ip-datagram-format">IP Datagram Format</h3>
<p><img src="https://i.imgur.com/3MCcdEZ.png" /></p>
<h3 id="ip-fragmentation-reassembly">IP Fragmentation, Reassembly</h3>
<ul>
<li>Each network link has a maximum transfer size (<em>MTU</em>).
<ul>
<li>Different link types, different MTUs.</li>
</ul></li>
<li>Large IP Datagram is divided within the network and <em>reassembled</em> only at the final destination.</li>
<li>IP header bits are used to identify and order related fragments.
<ul>
<li>Every fragment belonging to a datagram will have the same 16-bit id. Offset is measured in chunks of 8 bytes.</li>
</ul></li>
</ul>
<h3 id="ipv4-addressing">IPV4 Addressing</h3>
<ul>
<li><strong>IP Address</strong>: 32-bit identifier for host, router interface. <span class="math inline">(X.X.X.X)</span>, <span class="math inline">X \in [0, 256)</span>.</li>
<li><strong>Interface</strong>: Connection between host / router and physical link.
<ul>
<li>Routers typically have multiple interfaces.</li>
<li>Host typically has one or two interfaces (e.g. wired Ethernet, wireless 802.11).</li>
</ul></li>
</ul>
<h3 id="subnets">Subnets</h3>
<ul>
<li><strong>IP Address</strong>.
<ul>
<li>Subnet part, high order bits.</li>
<li>Host part, low order bits.</li>
</ul></li>
<li>Devices that have the same subnet part can physically reach each other <strong>without</strong> the need for a router.</li>
<li>To determine the subnets, detach each interface from its host or router and find the disjoint networks.</li>
<li>Subnets used to be classified into <span class="math inline">A</span>, <span class="math inline">B</span>, and <span class="math inline">C</span> where the subnet has <span class="math inline">8</span>, <span class="math inline">16</span>, and <span class="math inline">24</span> bits respectively.</li>
</ul>
<h3 id="cidr-classless-interdomain-routing">CIDR (<strong>C</strong>lassless <strong>I</strong>nter<strong>D</strong>omain <strong>R</strong>outing)</h3>
<ul>
<li>Subnet portion of an address has an arbitrary length.</li>
<li>Address format is <span class="math inline">a.b.c.d/x</span>, where <span class="math inline">x</span> is the number of bits in the subnet portion of address.</li>
<li>In every subnet, we need to <strong>reserve</strong> two special IP addresses, when the host part is all 0s or all 1s.
<ul>
<li><strong>All 0s</strong>, identifier, acts as a wildcard for clients who do not have an IP address yet.</li>
<li><strong>All 1s</strong>, broadcast.</li>
</ul></li>
</ul>
<h3 id="ip-address-how-to-get-one">IP Address: How To Get One?</h3>
<ul>
<li>Hard-coded by the system admin in a file.</li>
<li><strong>DHCP</strong> (<em><strong>D</strong>ynamic <strong>H</strong>ost <strong>C</strong>onfiguration <strong>P</strong>rotocol</em>), dynamically get address from a server.
<ul>
<li>“Plug-and-play”.</li>
</ul></li>
</ul>
<h2 id="dhcp-overview">DHCP Overview</h2>
<ul>
<li>Host broadcasts <strong>DHCP discover</strong> message (<em>optional</em>).</li>
<li>DHCP server responds with <strong>DHCP offer</strong> message (<em>optional</em>).</li>
<li>Host requires IP address, <strong>DHCP request</strong>.</li>
<li>DHCP server sends address, <strong>DHCP ack</strong>.</li>
<li>Client sends to port 67, server sends to port 68.</li>
</ul>
<p>DHCP can return more than just the allocated IP address on subnet.</p>
<ul>
<li>Address of first-hop router for client.</li>
<li>Name and IP address of DNS server.</li>
<li>Network mark (indicating network versus host portion of address).</li>
</ul>
<p><img src="https://i.imgur.com/84O81pw.png" /></p>
<p>By doing bitwise &amp; between a host IP address and subnet mask, you will get the subnet portion of the host IP address.</p>
<p>How does <em>network</em> get subnet part of IP address? It gets an allocated portion of its provider ISP’s address space.</p>
<p><img src="https://i.imgur.com/sHUVbUj.png" /></p>
<h2 id="heirarchical-addressing">Heirarchical Addressing</h2>
<p>Hierarchical addressing allows for efficient advertisement of routing information. Longest prefix match is used.</p>
<p>How does an ISP get a block of addresses? <strong>ICANN (I</strong>nternet <strong>C</strong>orporation for <strong>A</strong>ssigned <strong>N</strong>ames and <strong>N</strong>umbers) allocates addresses, manages DNS, assigns domain names, and resolves disputes.</p>
<h2 id="nat-network-address-translation">NAT (<em>Network Address Translation</em>)</h2>
<p>Households with one router only has one IP address. There may be multiple devices that need to connect, so the router does translation between local IP addresses and the outside world.</p>
<p><strong>All</strong> datagrams <strong>leaving</strong> the network have same single source NAT IP address.</p>
<p><strong>Motivation</strong>: local network uses just one IP address as far as the outside world is concerned.</p>
<ul>
<li>Range of addresses is not needed from ISP.</li>
<li>Local network addresses can be changed without notifying the outside world.</li>
<li>ISP can be changed without changing addresses of devices in local network.</li>
<li>Devices inside local network are not explicitly addressable which is a security plus.</li>
</ul>
<p><strong>Implementation</strong>: a NAT router must.</p>
<ul>
<li><strong>Outgoing datagrams: replace</strong> (source IP address, port number) of every outgoing datagram to (NAT IP address, new port number).</li>
<li><strong>Remember (<em>in NAT translation table</em>)</strong> every (source IP address, port number) to (NAT IP address, new port number) translation pair.</li>
<li><strong>Incoming datagrams: replace</strong> (NAT IP address, new port number) in destination fields of every incoming datagram with corresponding (source IP address, port number) sorted in NAT table.</li>
</ul>
<p>NAT has a 16-bit port number field which allows for 60000 simultaneous connections with a single LAN-side address!</p>
<p>NAT is <strong>controversial</strong>.</p>
<ul>
<li>Routers should only process up to layer 3.</li>
<li>Violates end-to-end argument.
<ul>
<li>NAT possibility must be taken into account by application designers, e.g. P2P applications.</li>
</ul></li>
<li>Address shortage should instead be solved by IPv6.</li>
</ul>
<h3 id="nat-traversal-problem">NAT Traversal Problem</h3>
<p><img src="https://i.imgur.com/725Ax3e.png" /></p>
<ul>
<li>Client wants to connect to server with address <span class="math inline">X</span>.
<ul>
<li>Server address local to LAN.</li>
<li>Only one externally visible NATed address.</li>
</ul></li>
<li><strong>Solution 1</strong>: Statically configure NAT to forward incoming connection requests at given port to server.</li>
<li><strong>Solution 2</strong>: Universal Plug and Play (UPnP) Internet Gateway Device (IGD) Protocol. Allows NATed host to.
<ul>
<li>Learn public IP address.</li>
<li>Add / remove port mappings with lease times.</li>
</ul></li>
<li><strong>Solution 3</strong> (used in Skype).
<ul>
<li>NATed client establishes connection to replay.</li>
<li>External client connects to relay.</li>
<li>Relay bridges packets between connections.</li>
</ul></li>
</ul>
<h2 id="icmp-internet-control-message-protocol">ICMP (<em>Internet Control Message Protocol</em>)</h2>
<ul>
<li>Used by hosts and routers to communicate network level information such as error reporting.</li>
<li>Network-layer is “above” IP, ICMP messages are carried in IP datagrams.</li>
<li><strong>ICMP Message</strong>: type, code plus first 8 bytes of IP datagram causing error.</li>
</ul>
<p><img src="https://i.imgur.com/0Wr8QXg.png" /></p>
<h3 id="traceroute-and-icmp">Traceroute and ICMP</h3>
<blockquote>
<p>We want to know which router I go through and the delays.</p>
</blockquote>
<ul>
<li>Source sends a series of UDP segments to dest.
<ul>
<li>First set has <span class="math inline">TTL = 1</span></li>
<li>Second set has <span class="math inline">TTL = 2</span>, etc.</li>
<li>Unlikely port number is used.</li>
</ul></li>
<li>When the <span class="math inline">n</span>th set of datagrams arrives to the <span class="math inline">n</span>th router.
<ul>
<li>Router discards datagrams and sends source ICMP messages (type 11, code 0).</li>
<li>ICMP messages include name of router and IP address.</li>
</ul></li>
<li>When ICMP messages arrive, source records RTTs.</li>
</ul>
<p><strong>Stopping Criteria</strong>:</p>
<ul>
<li>UDP segment eventually arrives at destination host.</li>
<li>Destination returns ICMP “<em>port unreachable</em>” message (type 3, code 3).</li>
<li>Source stops.</li>
</ul>
<h3 id="ipv6">IPv6</h3>
<ul>
<li><strong>Initial motivation</strong>: 32-bit address space is soon to be completely allocated (assigned in 2013).
<ul>
<li>Additionally, header format helps to speed processing / forwarding and header changes to facilitate QoS.</li>
</ul></li>
</ul>
<h4 id="ipv6-datagram-format">IPv6 Datagram Format</h4>
<ul>
<li>Fixed-length 40 byte header.
<ul>
<li>128-bit addressing, enough for every grain of sand to have an IP address.</li>
</ul></li>
<li>No fragmentation allowed.</li>
</ul>
<p><img src="https://i.imgur.com/YcQtRpt.png" /></p>
<ul>
<li><strong>Priority</strong>: identify priority among datagrams in flow.</li>
<li><strong>Flow Label</strong>: identify datagram in same “flow” (concept of <em>flow</em> is not well defined).</li>
<li><strong>Next Header</strong>: identify upper layer protocol for data.</li>
</ul>
<h4 id="changes-from-ipv4">Changes from IPv4</h4>
<ul>
<li><strong>Checksum</strong>: removed entirely to reduce processing time at each hop. We already have error detection at the transport and link layers.</li>
<li><strong>Options</strong>: allowed, but outside of header, indicated by “<em>Next Header</em>” field.</li>
<li><strong>ICMPv6</strong>: new version of ICMP.
<ul>
<li>Additional message types such as “Packet Too Big”.</li>
<li>Multicast group management functions.</li>
</ul></li>
</ul>
<h4 id="transition-from-ipv4-to-ipv6">Transition from IPv4 to IPv6</h4>
<ul>
<li>Not all routers can be upgraded simultaneously. How will networks operate with mixed IPv4 and IPv6 routers?</li>
<li><strong>Tunnelling</strong>: IPv6 datagram carried as <em>payload</em> in IPv4 datagram among IPv4 routers.</li>
</ul>
<p><img src="https://i.imgur.com/s3r53n7.png" /></p>
<h4 id="ipv6-adoption">IPv6 Adoption</h4>
<ul>
<li>US National Institutes of Standards estimate (2013):
<ul>
<li>3% of industry IP routers.</li>
<li>11% of US government routers.</li>
</ul></li>
<li>It takes a long time to update, because we would need to replace every router on the Internet.</li>
</ul>
<h2 id="routing-algorithms">4.5 Routing Algorithms</h2>
<blockquote>
<p>Routing algorithm determines end-end path through the network. Forwarding table determines local forwarding at this router.</p>
</blockquote>
<h3 id="routing-algorithm-classification">Routing Algorithm Classification</h3>
<p><strong>Global</strong>: All routers have complete topology and cost information (<em>link state</em> algorithms).</p>
<p><strong>Decentralized</strong>: Router knows only physically-connected neighbours. There is a iterative process of computation (<em>distance vector</em> algorithms).</p>
<p><strong>Static</strong>: Routes change slowly over time.</p>
<p><strong>Dynamic</strong>: Periodic updates in response to link cost changes.</p>
<h3 id="link-state-routing-algorithm">Link-State Routing Algorithm</h3>
<p><strong>Dijkstra’s algorithm</strong> is used to compute least cost paths from one node (<em>source</em>) to all other nodes. Tracing predecessor nodes gives a <strong>forwarding table</strong> for that node.</p>
<p><img src="https://i.imgur.com/qsSMBN0.png" /></p>
<h4 id="link-state-problems">Link-State Problems</h4>
<p><strong>Oscillations</strong> are possible, when the support link cost is equal to the amount of carried traffic.</p>
<h3 id="distance-vector-routing-algorithm">Distance Vector Routing Algorithm</h3>
<p><strong>Bellman-Ford equation</strong> is used to compute least cost paths at each node. The node <span class="math inline">v</span> that achieves the minimum cost for <span class="math inline">y</span> is the next-hop in the <strong>forwarding table</strong>.</p>
<p><span class="math display"> d_x(y) = \min_v\{c(x, v) + d_v(y)\}</span></p>
<p>Each node <span class="math inline">x</span> knows the cost to each neighbour <span class="math inline">v</span> and maintains its neighbours distance vectors. For each neighbour <span class="math inline">v</span>, <span class="math inline">x</span> maintains <span class="math inline">\mathbf{D}_v = [D_v(y), y \in N]</span>. <span class="math inline">x</span> also maintains a distance vector for itself.</p>
<p>From time-to-time, each node sends its own distance vector estimate to its neighbours. When <span class="math inline">x</span> receives a new distance vector estimate from a neighbour, it updates its own distance vector using the Bellman-Ford equation. Under minor, natural conditions, the estimate <span class="math inline">D_x(y)</span> will <strong>converge to the actual least cost <span class="math inline">d_x(y)</span></strong>.</p>
<p><span class="math display">D_x(y) = \min_v\{c(x, y) + D_v(y)\}, \text{ for each node } y \in N</span></p>
<ol type="1">
<li><strong>Iterative, Asynchronous</strong>: Local iterations are caused by.
<ul>
<li>Local link cost change.</li>
<li>Distance vector update message from neighbour.</li>
</ul></li>
<li><strong>Distributed</strong>: Each node notifies neighbours <em>only</em> when its distance vector changes.</li>
</ol>
<p><img src="https://i.imgur.com/wj4TIZx.png" /></p>
<h4 id="distance-vector-problems">Distance Vector Problems</h4>
<p>When <strong>link cost</strong> changes, the node needs to update routing information, and recalculate the distance vector. If the distance vector changes, it must notify neighbours.</p>
<p><strong>Bad news travels slow</strong>. There can be a routing loop between two nodes if a cost update reverses the minimum cost path. In order to broadcast the distance vector to its neighbours, nodes will keep passing information back to each other and updating distance vectors. <strong>Counting to infinity problem</strong>.</p>
<p>We used <strong>poisoned reverse</strong> in order to solve the problem of routing loops. If <span class="math inline">Z</span> routes through <span class="math inline">Y</span> to get to <span class="math inline">X</span>, <span class="math inline">Z</span> tells <span class="math inline">Y</span> that <span class="math inline">D_y(x) = \infty</span>. This does not completely solve the problem, we need to poison every node from source to destination.</p>
<h3 id="link-state-vs.distance-vector">Link-State vs. Distance Vector</h3>
<ul>
<li><strong>Message Complexity</strong>.
<ul>
<li><strong>LS</strong>: with <span class="math inline">n</span> nodes, <span class="math inline">E</span> links, <span class="math inline">O(nE)</span> messages sent.</li>
<li><strong>DV</strong>: Exchange between neighbours only.</li>
</ul></li>
<li><strong>Speed of Convergence</strong>.
<ul>
<li><strong>LS</strong>: <span class="math inline">O(n^2)</span> algorithm which requires <span class="math inline">O(nE)</span> messages. There may be oscillations.</li>
<li><strong>DV</strong>: Convergence time varies. There may be routing loops and count-to-infinity problems.</li>
</ul></li>
<li><strong>Robustness</strong> (router <em>malfunction</em>).
<ul>
<li><strong>LS</strong>: Nodes can advertise incorrect <em>link</em> costs. Each node only computes its <em>own</em> table.</li>
<li><strong>DV</strong>: Nodes can only advertise incorrect <em>path</em> costs. Each node’s table is used by others, so errors will propagate through the network.</li>
</ul></li>
</ul>
<h3 id="heirarchical-routing">Heirarchical Routing</h3>
<blockquote>
<p>In real life, all routers are not identical, and the network is not <em>flat</em>.</p>
</blockquote>
<p>With 600 million destinations, storing all destinations in routing tables would not be <strong>scalable</strong>. Routing table exchange would swamp links.</p>
<p>The internet is a network of networks, and each network admin may want to control routing in its own network.</p>
<ul>
<li>Aggregate routers into regions, <strong>autonomous systems (<em>AS</em>)</strong>.</li>
<li>Routers in AS run same routing protocol (<em>intra-AS</em> routing protocol).
<ul>
<li>Routers in different AS can run different protocols / algorithms.</li>
</ul></li>
<li><strong>Gateway routers</strong> are at the <em>edge</em> of its own AS and has links to routers in other AS.</li>
<li>The forwarding table is updated by both Intra-AS and Inter-AS routing algorithms.</li>
</ul>
<h4 id="inter-as-tasks">Inter-AS Tasks</h4>
<p><img src="https://i.imgur.com/nIIb3oV.png" /></p>
<p>Example: Single AS.</p>
<ul>
<li>Suppose router in AS1 receives a datagram destined outside of AS1. The router should forward packet to a gateway router, but which one?</li>
<li>AS1 must learn which destinations are reachable through AS2, and which are reachable through AS3. AS1 must propogate this reachability information to all routers in AS1.</li>
</ul>
<p>Example: Multiple ASes.</p>
<ul>
<li>Now suppose AS1 learns from the inter-AS protocol that subnet <span class="math inline">x</span> is reachable from both AS2 <strong>and</strong> AS3.</li>
<li>To configure the forwarding table, router 1d must determine which gateway it should forward packets to.
<ul>
<li>This is also the job of inter-AS routing protocol.</li>
</ul></li>
</ul>
<p><strong>Hot Potato Routing</strong>: We want to get rid of our package as fast as possible, so we choose the gateway that has the lowest local cost.</p>
<h2 id="routing-in-the-internet">4.6 Routing in the Internet</h2>
<h3 id="intra-as-routing">Intra-AS Routing</h3>
<blockquote>
<p><strong>Interior Gateway Protocols (<em>IGP</em>)</strong>.</p>
</blockquote>
<ul>
<li><strong>RIP</strong>: Routing Information Protocol.</li>
<li><strong>OSPF</strong>: Open Shortest Path First.</li>
<li><strong>IGRP</strong>: Interior Gateway Routing Protocol (Cisco proprietary)&gt;</li>
</ul>
<h4 id="rip-routing-information-protocol">RIP (<em>Routing Information Protocol</em>)</h4>
<ul>
<li>Distance vector algorithm except the distance is measured by the number of hops (edge cost of 1), with a maximum of 15 hops.</li>
<li>DVs are exchanged every 30s in response messages (<strong>advertisements</strong>).
<ul>
<li>Up to 25 destination <strong>subnets</strong> in each advertisement.</li>
</ul></li>
</ul>
<p>If no advertisement is heard after 180s, the neighbour / link is declared dead.</p>
<ul>
<li>Routes via neighbour are invalidated.</li>
<li>New advertisements send to neighbours.
<ul>
<li>Neighbours in turn send out new advertisements (if tables are changed).</li>
</ul></li>
<li>We use <strong>poison reverse</strong> to prevent ping-pong loops.
<ul>
<li>Infinite distance is 16 hops.</li>
</ul></li>
</ul>
<p>RIP routing tables are managed by <strong>application-level</strong> process called route-d (daemon).</p>
<ul>
<li>Routers need more than the bottom 3 layers to run RIP.</li>
<li>Advertisements are sent in UDP packets, periodically repeated.</li>
</ul>
<h4 id="ospf-open-shortest-path-first">OSPF (<em>Open Shortest Path First</em>)</h4>
<ul>
<li>“<strong>Open</strong>”: Publicly available.</li>
<li>Uses link state algorithm.
<ul>
<li>LS packet dissemination.</li>
<li>Topology map at each node.</li>
<li>Route computation using Dijkstra’s algorithm.</li>
</ul></li>
<li>OSPF advertisement carries one entry per neighbours.</li>
<li>Advertisements are flooded to the <strong>entire</strong> AS.
<ul>
<li>Carried in OSPF messages directly over IP rather than TCP or UDP.</li>
</ul></li>
<li><strong>IS-IS Routing Protocol</strong>: Nearly identical to OSPF.</li>
<li><strong>Security</strong>: All messages are authenticated to prevent malicious intrusion.</li>
<li><strong>Multi</strong>ple same-cost <strong>path</strong>s are allowed. Allows for load balancing.</li>
<li>For each link, multiple cost metrics for different <strong>TOS</strong>.</li>
<li><strong>Unicast</strong> and <strong>multicast</strong> support. Unicast is 1-to-1, multicast is 1-to-many.</li>
<li>Allows for <strong>hierarchical</strong> OSPF in large domains.</li>
</ul>
<h4 id="hierarchical-ospf">Hierarchical OSPF</h4>
<ul>
<li><strong>Two-level hierarchy</strong>: Local area, backbone.
<ul>
<li>Link-state advertisements only done in areas.</li>
<li>Each node has detailed area topology, only knows direction to networks in other areas.</li>
</ul></li>
<li><strong>Area border routers</strong>: <em>“Summarize”</em> distances to nets in own area, and advertise to other area border routers.</li>
<li><strong>Backbone routers</strong>: Run OSPF limited to backbone.</li>
<li><strong>Boundary routers</strong>: Connect to others AS’s.</li>
</ul>
<h3 id="inter-as-routing-bgp">Inter-AS Routing (BGP)</h3>
<blockquote>
<p>Border Gateway Protocol. De facto inter-domain routing protocol, the glue that holds the Internet together.</p>
</blockquote>
<ul>
<li><strong>eBGP</strong> (<em>external</em>): Obtains subnet reachability from neighbouring ASs.</li>
<li><strong>iBGP</strong> (<em>internal</em>): Propagate reachability information to all AS-internal routers.</li>
<li>Determines <em>good</em> routes to other networks based on reachability information and policy.</li>
</ul>
<h4 id="bgp-messages">BGP Messages</h4>
<ul>
<li>Exchanged between peers over TCP connection.</li>
<li><strong>OPEN</strong>: Opens TCP connection to peer and authenticates sender.</li>
<li><strong>UPDATE</strong>: Advertise new path or withdraw old.</li>
<li><strong>KEEPALIVE</strong>: Keep connection alive, ACKs OPEN requests.</li>
<li><strong>NOTIFICATION</strong>: Reports errors in previous messages, also used to close connections.</li>
</ul>
<h4 id="path-attributes-and-bgp-routers">Path Attributes and BGP Routers</h4>
<ul>
<li>Advertised prefix includes BGP attributes.</li>
<li><strong>AS-PATH</strong>: Contains ASs through which prefix advertisement has passed.</li>
<li><strong>NEXT-HOP</strong>: Indicates specific internal-AS router to next-hop AS.</li>
<li>Gateway router receiving route advertisement uses <strong>import policy</strong> to accept / decline.</li>
</ul>
<h4 id="bgp-route-selection">BGP Route Selection</h4>
<p>We only continue to the next step if there are still ties.</p>
<ol type="1">
<li>Local preference value attribute, policy decision.</li>
<li>Shortest AS-PATH.</li>
<li>Closest NEXT-HOP (OSPF).</li>
<li>Additional criteria.</li>
</ol>
<h4 id="bgp-routing-policy">BGP Routing Policy</h4>
<ul>
<li>Customers will not advertise worse paths for themselves.</li>
<li>Providers will not advertise links to competitors because they only want to route to / from its customers.</li>
</ul>
<h3 id="why-intra-as-and-inter-as-routing">Why Intra-AS <strong>and</strong> Inter-AS Routing?</h3>
<ul>
<li><strong>Policy</strong>: Inter admins wants to control how traffic is routed, intra is a single admin, so no policy decisions are needed.</li>
<li><strong>Scale</strong>: Hierarchical routing saves table slides, reduced update traffic.</li>
<li><strong>Performance</strong>: Intra will focus on performance, but inter may be dominated by policy.</li>
</ul>
<h3 id="entry-in-forwarding-table">Entry in Forwarding Table</h3>
<ol type="1">
<li>Router becomes aware of prefix.
<ul>
<li>BGP message contains <strong>“routes”</strong>. Route is a prefix and attributes, AS-PATH, NEXT-HOP, …</li>
<li>Router may receive multiple routes for the <strong>same</strong> prefix. We must select one route using the routine above.</li>
<li>Use selected route’s NEXT-HOP attribute.</li>
</ul></li>
<li>Router determines output port for prefix.
<ul>
<li>Use BGP route selection to find the best inter-AS route.</li>
<li>Use OSPF to find the best intra-AS route.</li>
<li>Router identify router port for that best route.</li>
</ul></li>
<li>Router enters prefix-port in forwarding table.</li>
</ol>
<h2 id="broadcast-routing">4.7 Broadcast Routing</h2>
<ul>
<li>A simple approach is to transmit <span class="math inline">N</span> copies to the <span class="math inline">N</span> destinations using unicast routing. <strong>N-way-unicast</strong>.</li>
<li><strong>Uncontrolled flooding</strong>: When a node receives a broadcast, it sends a copy to all neighbours (except the one who send the packet).
<ul>
<li><strong>Cycles</strong>: Endless cycling of one clockwise, one counterclockwise.</li>
<li><strong>Broadcast Storm</strong>: When a node is connected to more than two other nodes, it will create and forward multiple copies of the broadcast packet, endless multiplication of broadcast packets.</li>
</ul></li>
</ul>
<h3 id="controller-flooding">Controller Flooding</h3>
<blockquote>
<p>Node only broadcasts packet if it has not broadcasted the same packet before.</p>
</blockquote>
<ul>
<li><strong>Sequence-number-controlled Flooding</strong>: Source nodes put <strong>address</strong> as well as <strong>broadcast sequence number</strong> into a broadcast packet.</li>
<li>Each node maintains a <strong>list</strong> to the source address and sequence number of each broadcast packet.</li>
<li>When a node receives a broadcast packet, if it has already been seen, then it is dropped. If not, the packet is duplicated and sent to all relevant neighbours.</li>
<li><strong>Reverse Path Forwarding (<em>RPF</em>)</strong>: Only forward packet if it arrived on the shortest path between the node and source.</li>
<li>RPF does not require that a router know the compute shortest path, only local shortest.</li>
<li><strong>Spanning Tree</strong>: Construct spanning tree and then only forward / make copies along it. Creation is done by having nodes in the network send unicast <strong>join</strong> messages to the center node and tracking the path until a node already belonging to the spanning tree.</li>
</ul>
<h1 id="link-layer">5: Link Layer</h1>
<blockquote>
<p>Responsible for transferring datagram from one node to <strong>physically adjacent</strong> node over a link.</p>
</blockquote>
<ul>
<li>Host and routers: <strong>nodes</strong>.</li>
<li>Communication channels that connect adjacent nodes across communication path: <strong>links</strong>.
<ul>
<li>Wired, wireless, LANs.</li>
</ul></li>
<li>Layer-2 packet: <strong>frame</strong>, encapsulates datagram.</li>
</ul>
<h2 id="link-layer-services">Link Layer Services</h2>
<ul>
<li><strong>Framing, link access</strong>.
<ul>
<li>Encapsulates datagram into frame, adding header and trailer.</li>
<li>Channel access if shared medium.</li>
<li><strong>“MAC”</strong> address used in frame headers to identify source, destination. This is different from IP address!</li>
</ul></li>
<li><strong>Reliable delivery between adjacent nodes</strong>.
<ul>
<li>Chapter 3. (Go-Back-N, Selective Repeat, …).</li>
<li>Seldom used on low bit-error link such as fiber.</li>
<li>Wireless links have higher error rates.</li>
</ul></li>
<li><strong>Flow Control</strong>.
<ul>
<li>Pacing between adjacent sending and receiving nodes.</li>
</ul></li>
<li><strong>Error Detection</strong>.
<ul>
<li>Errors caused by signal attenuation, noise.</li>
<li>Receiver detects presence of errors and signals sender for retransmission or drops frame.</li>
</ul></li>
<li><strong>Error Correction</strong>.
<ul>
<li>Receiver identifies and <strong>corrects</strong> bit errors without resorting to retransmission.</li>
</ul></li>
<li><strong>Half-Duplex and Full-Duplex</strong>.
<ul>
<li>With half duplex, nodes at both ends of the link can transmit, but not at the same time.</li>
</ul></li>
</ul>
<h2 id="where-is-link-layer">Where is Link Layer?</h2>
<ul>
<li>In each and every host.</li>
<li>Link layer implemented in <strong>“adaptor”</strong>, also known as <strong>NIC</strong> (<em>network interface card</em>), or on a chip.
<ul>
<li>Ethernet card, 802.11 card. Ethernet chipset.</li>
<li>Implements link, physical layer.</li>
</ul></li>
<li>Attaches into host’s system buses.</li>
<li>Combination of hardware, software, firmware.</li>
</ul>
<h2 id="error-detection-and-correction">5.2 Error Detection and Correction</h2>
<ul>
<li>EDC = Error Detection and Correction bits.</li>
<li>D = Data protected by error checking, may include header fields.</li>
<li>Error detection is not 100% reliable.
<ul>
<li>Protocol may miss some errors, but rarely.</li>
<li>Larger EDC field yields better detection and correction.</li>
</ul></li>
</ul>
<h3 id="parity-checking">Parity Checking</h3>
<blockquote>
<p>Detect and correct single bit errors.</p>
</blockquote>
<ul>
<li><strong>Single bit parity</strong>: store the parity of the <span class="math inline">d</span> data bits.</li>
<li><strong>Two-dimensional bit parity</strong>. Store the parity of rows and columns for the <span class="math inline">d</span> data bits (group into words of <span class="math inline">j</span> bits). Find where errors should lie by analyzing single bit parity errors across all rows and columns.</li>
</ul>
<h3 id="internet-checksum-review">Internet Checksum (<em>Review</em>)</h3>
<h3 id="cyclic-redundancy-check">Cyclic Redundancy Check</h3>
<ul>
<li>More powerful error-detection coding.</li>
<li>View data bits, <span class="math inline">D</span>, as a binary number.</li>
<li>Choose <span class="math inline">r+1</span> bit pattern (generator), <span class="math inline">G</span>.</li>
<li>Goal: choose <span class="math inline">r</span> CRC bits, <span class="math inline">R</span>, such that …
<ul>
<li>&lt;D, R&gt; exactly divisible by <span class="math inline">G \mod 2</span>.</li>
<li>Receiver knows <span class="math inline">G</span>, divides &lt;D, R&gt; by <span class="math inline">G</span>. If non-zero remainder, error detected!</li>
<li>Can detect all burst errors less than <span class="math inline">r+1</span> bits.</li>
</ul></li>
<li>Widely used in practice.</li>
</ul>
<p>Example: <span class="math inline">D = 101110</span>, <span class="math inline">G = 1001</span>.</p>
<blockquote>
<p><span class="math inline">|G| = 4 = r + 1</span>. Shift <span class="math inline">D</span> left by <span class="math inline">r</span>, <span class="math inline">101110000</span>.</p>
<p><img src="https://i.imgur.com/9FGGvhB.png" /></p>
</blockquote>
<h2 id="multiple-access-protocols">5.3 Multiple Access Protocols</h2>
<ol type="1">
<li><strong>Point-to-Point</strong>.
<ul>
<li>PPP for dial-up access.</li>
<li>Link between Ethernet switch, host.</li>
</ul></li>
<li><strong>Broadcast</strong>.
<ul>
<li>Old-fashioned Ethernet.</li>
<li>Upstream HFC.</li>
<li>802.11 wireless LAN.</li>
</ul></li>
</ol>
<h3 id="multiple-access-protocol">Multiple Access Protocol</h3>
<blockquote>
<p>Distributed algorithm that can determine how nodes share channel, determine when node can transmit.</p>
</blockquote>
<ul>
<li>Single shared broadcast channel.</li>
<li>Two or more simultaneous transmissions by nodes can cause a <strong>collision</strong> if the node receives two or more signals at the same time.</li>
</ul>
<h3 id="ideal-protocol">Ideal Protocol</h3>
<blockquote>
<p>Given a broadcast channel rate <span class="math inline">R</span> bps.</p>
</blockquote>
<ol type="1">
<li>When one node wants to transmit, it can send at rate <span class="math inline">R</span>.</li>
<li>When <span class="math inline">M</span> nodes want to transmit, each can send at average rate <span class="math inline">\frac{R}{M}</span>.</li>
<li><p>Fully decentralized.</p>
<ul>
<li>No special node to coordinate transmissions.</li>
<li>No synchronization of clocks, slots.</li>
</ul></li>
<li><p>Simple.</p></li>
</ol>
<h3 id="mac-protocol-taxonomy">MAC Protocol Taxonomy</h3>
<blockquote>
<p>Three broad classes.</p>
</blockquote>
<ol type="1">
<li><strong>Channel Partitioning</strong>.</li>
<li><strong>Random Access</strong>.</li>
<li><strong>Taking Turns</strong>.</li>
</ol>
<h3 id="channel-partitioning">Channel Partitioning</h3>
<ol type="1">
<li><p><strong>TDMA</strong>: Time Division Multiple Access.</p>
<ul>
<li>Access to channel in <em>rounds</em>.</li>
<li>Each station gets a fixed length slot in each round. Unused slots go idle.</li>
<li><strong>Advantages</strong>: Fair, collision free.</li>
<li><strong>Disadvantages</strong>: Waste of bandwidth, unnecessary waiting.</li>
</ul></li>
<li><p><strong>FDMA</strong>: Frequency Division Multiple Access.</p>
<ul>
<li>Channel spectrum divided into frequency bands.</li>
<li>Each station assigned fixed frequency band. Unused bands go idle.</li>
<li>Similar advantages and disadvantages as TDMA.</li>
</ul></li>
<li><p><strong>CDMA</strong>: Code Division Multiple Access.</p>
<ul>
<li>Each user is allocated a unique code to transmit.</li>
</ul></li>
</ol>
<h3 id="random-access-protocols">Random Access Protocols</h3>
<ul>
<li>When node has a packet to send, it transmits at full channel data rate <span class="math inline">R</span>.</li>
<li><strong>Random Access MAC Protocol</strong> specifies how to detect collisions and how to record from collisions.</li>
<li>Slotted ALOHA, ALOHA, CSMA, CSMA/CD, CSMA/CA.</li>
</ul>
<h4 id="slotted-aloha">Slotted ALOHA</h4>
<blockquote>
<p>Collisions can be detected in physical medium based on superposition.</p>
</blockquote>
<p><strong>Assumptions</strong>.</p>
<ul>
<li>All frames are the same size.</li>
<li>Time divided into equal size slots.</li>
<li>Nodes start to transmit only at slot beginning.</li>
<li>Nodes are synchronized.</li>
<li>If 2 or more nodes transmit in slot, all nodes detect collision.</li>
</ul>
<p><strong>Operation</strong>.</p>
<ul>
<li>When a node obtains a fresh frame, transmit in next slot.</li>
<li>If there is no collision, we send new frame in next slot.</li>
<li>If there is a collision, we retransmit frame in each subsequent slot with probability <span class="math inline">p</span> until success.
<ul>
<li>Each one picks a different probability.</li>
</ul></li>
</ul>
<p><strong>Pros</strong>.</p>
<ul>
<li>Single active node can continuously transmit at full rate.</li>
<li>Highly decentralized, only slots in nodes need to be in sync.</li>
<li>Simple.</li>
</ul>
<p><strong>Cons</strong>.</p>
<ul>
<li>Collisions, wasting slots.</li>
<li>Idle slots.</li>
<li>Nodes may be able to detect collision in less than time to transit packet. If they detect collisions, they must continue to transmit for the entire time slot.</li>
<li>Clock synchronization.</li>
</ul>
<p>The <strong>efficiency</strong> is the long-run fraction of successful slots.</p>
<ul>
<li>Probability that a given node has success in a slot is <span class="math inline">p(1-p)^{N-1}</span>.</li>
<li>Probability that <em>any</em> node has a success is <span class="math inline">Np(1-p)^{N-1}</span>.</li>
<li><strong>Max efficiency</strong> is <span class="math inline">p^*</span> which maximizes <span class="math inline">Np(1-p)^{N-1}</span>.</li>
<li>As <span class="math inline">N \to \infty</span>, the max efficiency is <span class="math inline">\frac{1}{e} = 0.37</span>.</li>
</ul>
<h4 id="pure-unslotted-aloha.">Pure (Unslotted) ALOHA.</h4>
<blockquote>
<p>No synchronization between nodes.</p>
</blockquote>
<ul>
<li>When a frame first arrives, we immediately transmit.</li>
<li>Collision probability increases, frame sent at <span class="math inline">t_0</span> collides with any other frames sent in <span class="math inline">[t_0 - 1, t_0 + 1]</span>.</li>
<li>Calculating the efficiency will lead to <span class="math inline">\frac{1}{2e}</span>, which is <strong>worse</strong> than slotted ALOHA.</li>
</ul>
<h4 id="csma-carrier-sense-multiple-access">CSMA (Carrier Sense Multiple Access)</h4>
<blockquote>
<p>Listen before retransmit.</p>
</blockquote>
<ul>
<li>If channel sensed idle, transmit the entire frame.</li>
<li>If channel sensed busy, defer transmission.</li>
<li><strong>Collisions <em>can</em> still occur</strong>, mainly due to propagation delays.
<ul>
<li>Entire packet transmission time wasted.</li>
<li>Distance and propagation delay play a role in determining collision probability.</li>
</ul></li>
</ul>
<h4 id="csmacd-collision-detection">CSMA/CD (Collision Detection)</h4>
<ul>
<li>Colliding transmissions are aborted, reducing channel wastage.</li>
<li>Easy in wired LANs, measure signal strengths, compare transmitted, received signals.</li>
<li>Difficult in wireless LANs, received signal strength overwhelmed by local transmission strength.</li>
</ul>
<ol type="1">
<li>NIC (Network Interface Card) receives datagram, encapsulates into creates frame.</li>
<li>If NIC senses channel is busy, waits until idle, then transmits.</li>
<li>If NIC transmits entire frame without detecting another transmission, then we are done.</li>
<li>If NIC detects another transmission, abort and send a jam signal.</li>
<li><p>After aborting NIC enters <strong>binary (<em>exponential</em>) backoff</strong>.</p>
<ul>
<li>Maintain a counter for collisions, after the <span class="math inline">m</span>th collision, pick a <span class="math inline">K</span> randomly from ${0, 1, …, 2^{m} - 1} $. NIC waits for <span class="math inline">K \cdot 512</span> bit times, then returns to step 2. Counter is reset upon successful transmission.</li>
<li>Longer backoff interval with more collisions.</li>
</ul></li>
</ol>
<ul>
<li>Medium sensing is done for 96 bit times.</li>
<li>Jamming signal length is 48 bits.</li>
<li>The maximum amount of collisions is set to 10. Any more will generate an error.</li>
</ul>
<p>Assume that <span class="math inline">T_{prop}</span> is the maximum propagation delay between 2 nodes in LAN, and <span class="math inline">t_{trans}</span> is the time to transmit a max-size frame.</p>
<p><span class="math display">\text{efficiency} = \frac{1}{1 + 5\frac{t_{prop}}{t_{trans}}}</span></p>
<ul>
<li><p><strong>Efficiency</strong> <span class="math inline">\to 1</span> as <span class="math inline">t_{prop} \to 0</span> or <span class="math inline">t_{trans} \to \infty</span>.</p>
<blockquote>
<p>Do <strong>not</strong> need to memorize efficiency formulas, just which is better and why).</p>
</blockquote></li>
<li><p>Better performance than ALOHA, simple, cheap, decentralized!</p></li>
</ul>
<h3 id="taking-turns">Taking Turns</h3>
<blockquote>
<p>We look for the best mix of channel partitioning and random access.</p>
</blockquote>
<ol type="1">
<li><strong>Polling</strong>.
<ul>
<li>Master node <em>invites</em> slave nodes to transmit in turn by polling.</li>
<li>Typically used with <em>dumb</em> slave devices.</li>
<li>No collisions and no empty slots.</li>
<li>Concerns with polling overhead, latency, and single point of failure.</li>
</ul></li>
<li><strong>Token Passing</strong>.
<ul>
<li>Control <strong>token</strong> passed from one node to next sequentially.</li>
<li>Token message.</li>
<li>Concerns with token overhead, latency, and single point of failure (token).</li>
</ul></li>
</ol>
<h3 id="cable-access-network">Cable Access Network</h3>
<blockquote>
<p>An example of how we can use multiple access.</p>
</blockquote>
<ul>
<li>Two channels, upstream and downstream.
<ul>
<li>Downstream has only one sender (CMTS / IP), so we do not need multiple access.</li>
<li>Upstream requires multiple access since we have multiple senders.</li>
</ul></li>
<li><strong>DOCSIS</strong>: Data Over Cable Service Interface Spec.
<ul>
<li>FDM over upstream, downstream frequency channels.</li>
<li>TDM upstream, some slots assigned, some have contention.
<ul>
<li>Downstream MAP frame assigns upstream slots.</li>
<li>Request for upstream slots (and data) transmitted random access (binary backoff) in selected slots.</li>
</ul></li>
<li>Visualized as FDM split up into time slots similar to TDM.</li>
</ul></li>
</ul>
<h2 id="lans">5.4 LANs</h2>
<h3 id="mac-addresses-and-arp">MAC Addresses and ARP</h3>
<blockquote>
<p><strong>Analogy</strong>: MAC address like SSN, IP address like postal address.</p>
</blockquote>
<ul>
<li>Used <strong>locally</strong> to get frame from one interface to another physically-connected interface (same network, in IP-addressing).
<ul>
<li>48 bit MAC address (for most LANs) burned in NIC ROM, also sometimes software settable.</li>
<li>Hexadecimal notation.</li>
</ul></li>
</ul>
<h3 id="lan-addresses">LAN Addresses</h3>
<ul>
<li>Each adapter on LAN has a unique <strong>LAN</strong> address.</li>
<li>MAC address allocation administered by IEEE.</li>
<li>Flat address allows for portability, we can move from one LAN card to another.</li>
</ul>
<h3 id="arp-address-resolution-protocol">ARP (Address Resolution Protocol)</h3>
<blockquote>
<p>How to determine interface’s MAC address, knowing its IP address.</p>
</blockquote>
<p><strong>ARP Table</strong>: Each IP node (host, router) on LAN has table.</p>
<ul>
<li>IP to MAC address mappings for some LAN nodes.</li>
<li>TTL time after which address mapping will be forgotten (typically 20 min).</li>
</ul>
<p>Consider <span class="math inline">A</span> wants to send a datagram to <span class="math inline">B</span> but <span class="math inline">B</span>’s MAC address is not in <span class="math inline">A</span>’s ARP table.</p>
<ul>
<li><span class="math inline">A</span> <strong>broadcasts</strong> ARP query packet, containing <span class="math inline">B</span>’s IP address.
<ul>
<li>Destination MAC address set to FF-FF-FF-FF.</li>
<li>All nodes on LAN receive ARP query.</li>
</ul></li>
<li><span class="math inline">B</span> receives ARP packet, replies to <span class="math inline">A</span> with its MAC address (unicast to <span class="math inline">A</span>’s MAC address).</li>
<li><span class="math inline">A</span> caches IP to MAC address pair in its ARP table until the information becomes old.</li>
<li>ARP is <strong>“plug-and-play”</strong>. Nodes create their ARP tables <em>without intervention from network administrator</em>.</li>
</ul>
<p>Example: Sending a datagram from <span class="math inline">A</span> to <span class="math inline">B</span> via <span class="math inline">R</span>. Assume that <span class="math inline">A</span> knows <span class="math inline">B</span>’s IP address, IP address of first hop router <span class="math inline">R</span> (DHCP), and <span class="math inline">R</span>’s MAC address (ARP).</p>
<blockquote>
<p><img src="https://i.imgur.com/i7E8K6A.png" /> - A creates IP datagram with IP source <span class="math inline">A</span>, destination <span class="math inline">B</span>. - A creates link-layer frame with <span class="math inline">R</span>’s MAC address at destination, frame contains <span class="math inline">A</span>-to-<span class="math inline">B</span> IP datagram. - Frame sent from <span class="math inline">A</span> to <span class="math inline">R</span>, upon arrival, datagram is removed and passed up to IP. - <span class="math inline">R</span> forwards datagram with IP source <span class="math inline">A</span>, destination <span class="math inline">B</span>. - <span class="math inline">R</span> creates link-layer frame with <span class="math inline">B</span>’s MAC address as destination, frame contains <span class="math inline">A</span>-to-<span class="math inline">B</span> IP datagram.</p>
</blockquote>
<h3 id="ethernet">Ethernet</h3>
<blockquote>
<p>“Dominant” wired LAN technology. Family of protocols.</p>
</blockquote>
<ul>
<li>First widely used LAN technology.</li>
<li>Simpler, cheap than token LANs and ATM.</li>
</ul>
<h4 id="physical-topology">Physical Topology</h4>
<ul>
<li><strong>Bus</strong>, popular through the mid 90s. All nodes are in the same collision domain.</li>
<li><strong>Star</strong>, prevails today. Active <strong>switch</strong> is in the center, and each “spoke” runs a separate Ethernet protocol (nodes do not collide with each other).</li>
</ul>
<h4 id="frame-structure">Frame Structure</h4>
<p>Sending adapter encapsulates IP datagram (or other network layer protocol packet) in <strong>Ethernet frame</strong>.</p>
<ul>
<li><strong>Preamble</strong>. 7 bytes with pattern <span class="math inline">10101010</span> followed by one byte with pattern <span class="math inline">10101011</span> (wake up bytes). Used to synchronize receiver to the clock of the sender.</li>
<li><strong>Addresses</strong>, 6 byte source, destination MAC addresses.</li>
<li><strong>Type</strong>, indicates higher layer protocol (mostly IP).</li>
<li><strong>CYC</strong>, cyclic redundancy check at receiver.</li>
</ul>
<p>Ethernet is unreliable, connectionless.</p>
<ul>
<li><strong>Connectionless</strong>, no handshaking between sending and receiving NICs.</li>
<li><strong>Unreliable</strong>, receiving NIC doesnt send ACKs or NACKs to sending NIC.
<ul>
<li>Data in dropped frames recovered only if initial sender uses higher layer rdt, otherwise dropped data is lost.</li>
</ul></li>
<li>Ethernet’s MAC protocol, unslotted <strong>CSMA/CD with binary backoff</strong>.</li>
</ul>
<p>There are <strong>many</strong> difference Ethernet standards. They each have common MAC protocol and frame format. Offer different speeds, and different physical layer media.</p>
<h3 id="ethernet-switches">Ethernet Switches</h3>
<blockquote>
<p>Implement the bottom two levels.</p>
</blockquote>
<ul>
<li><strong>Link-layer device, takes an <em>active</em> role</strong>.
<ul>
<li>Store, <strong>forward</strong>, Ethernet frames.</li>
<li>Examine incoming frame’s MAC address, <strong>selectively</strong> forward frame to one-or-more outgoing links when frame is to be forwarded on segment, uses CSMA/CD to access segment.</li>
</ul></li>
<li><strong>Transparent</strong>. Hosts are unaware of the presence of switches.</li>
<li><strong>Plug-and-play, self-learning</strong>. Switches to not have to be configured.</li>
</ul>
<p>Switches allow for <em>multiple</em> simultaneous transmissions.</p>
<p><img src="https://i.imgur.com/jyYDbBE.png" /></p>
<ul>
<li>Hosts have dedicated, direct connection to switch.</li>
<li>Switches buffer packets.</li>
<li>Ethernet protocol used on <em>each</em> incoming link, but no collisions. Full duplex.
<ul>
<li>Each link is in its own collision domain.</li>
</ul></li>
<li><strong>Switching</strong> can transmit <span class="math inline">A</span>-to-<span class="math inline">A^\prime</span> and <span class="math inline">B</span>-to-<span class="math inline">B^\prime</span> simultaneously, without collisions.</li>
</ul>
<h4 id="switch-forwarding-table">Switch Forwarding Table</h4>
<blockquote>
<p>How does the switch know <span class="math inline">A^\prime</span> is reachable via interface 4, etc.</p>
</blockquote>
<ul>
<li>Each switch has a <strong>switch table</strong>, similar to routing table but for MAC address.
<ul>
<li>(MAC address of host, interface to reach host, timestamp).</li>
</ul></li>
</ul>
<blockquote>
<p>How are entries created and maintained in the switch table?</p>
</blockquote>
<ul>
<li>Switch <strong>learns</strong> which hosts can be reached through which interfaces.
<ul>
<li>When frame received, switch <strong>learns</strong> location of sender, incoming LAN segment.</li>
<li>Records sender, location pair in switch table.</li>
</ul></li>
<li><p>When a frame is received at switch.</p>
<ol type="1">
<li>Record incoming link, MAC address of sending host.</li>
<li>Index switch table using MAC destination address.</li>
<li>If the entry is not found for the destination, then we flood. If the destination is on the segment that the frame arrived, drop it.</li>
</ol></li>
</ul>
<h4 id="interconnecting-switches">Interconnecting Switches</h4>
<blockquote>
<p>Switches can be connected in order to create a hierarchy.</p>
</blockquote>
<ul>
<li>Very similar to other hierarchies that we have studied.</li>
<li>Self learning (flooding) is still used, exactly the same as in the single-switch case.</li>
</ul>
<p><img src="https://i.imgur.com/dfYdiql.png" /></p>
<h4 id="switches-vs.routers">Switches vs. Routers</h4>
<p>Both are <strong>store-and-forward</strong>.</p>
<ul>
<li><strong>Routers</strong>: Network-layer devices.
<ul>
<li><strong>Advantages</strong>: Hierarchical addressing, traffic isolation. We can send information within subnets without worrying about information leaking to the outside.</li>
<li><strong>Disadvantages</strong>: Large processing time, needs IP configuration.</li>
</ul></li>
<li><strong>Switches</strong>: Link-layer devices.
<ul>
<li><strong>Advantages</strong>: Fast plug-and-play.</li>
<li><strong>Disadvantages</strong>: Broadcast storm if loops exist, large ARP table for large network.</li>
</ul></li>
</ul>
<p>Both have <strong>forwarding tables</strong>.</p>
<ul>
<li><strong>Routers</strong>: Compute tables using routing algorithms, IP addresses.</li>
<li><strong>Switches</strong>: Learn forwarding table using flooding, learning, MAC addresses.</li>
</ul>
<p><strong>A router has multiple IP addresses</strong>. There is one for every interface.</p>
<h3 id="vlans">VLANS</h3>
<ul>
<li>Consider a CS user who moves office to ECE, but still wants to connect to the CS switch?</li>
<li>Single broadcast domain.
<ul>
<li>All layer-2 broadcast traffic (ARP, DHCP, etc.) must cross entire LAN.</li>
<li>Security / privacy, efficiency issue.</li>
</ul></li>
</ul>
<blockquote>
<p>We want to achieve some sort of <strong>traffic isolation</strong>. Switch(es) supporting VLAN capabilities can be configured to define multiple <strong>virtual</strong> LANS over single physical LAN infrastructure.</p>
</blockquote>
<h4 id="port-based-vlan">Port-based VLAN</h4>
<blockquote>
<p>Switch ports grouped (by switch management software) that a <strong>single</strong> physical switch operates as <strong>multiple</strong> virtual switches.</p>
</blockquote>
<ul>
<li><strong>Traffic Isolation</strong>: Frames to / from ports 1-8 can <em>only</em> reach ports 1-8. VLAN can also be based on MAC addresses of endpoints, rather than switch ports.</li>
<li><strong>Dynamic Membership</strong>: Ports can be dynamically assigned among VLANs.</li>
<li><strong>Forwarding between VLANs</strong>: Done via routing (just as with separate switches).
<ul>
<li>In practice, vendors sell combined switches plus routers.</li>
</ul></li>
<li><strong>Trunk Port</strong>: Carries frames between VLANs defined over multiple physical switches.
<ul>
<li>Frames forwarded within VLAN between switches can’t be vanilla 802.1 frames. They must carry VLAN ID info.</li>
<li>802.1q protocol adds / removed additional header fields for frames forwarded between trunk ports.</li>
</ul>
<img src="https://i.imgur.com/hkyMOVj.png" /></li>
</ul>
<h2 id="link-virtualization-mpls">5.5 Link Virtualization MPLS</h2>
<blockquote>
<p><strong>Multiprotocol Label Switching</strong>.</p>
</blockquote>
<ul>
<li>Initial goal is high-speed IP forwarding using fixed length label (instead of IP address).
<ul>
<li>Fast lookup using fixed length identifier rather than longest prefix matching.</li>
<li>Borrowing ideas from Virtual Circuit (VC) approach.</li>
<li>But IP datagram still keeps IP address!</li>
</ul></li>
<li>We add in a MPLS header, which contains a 20 bit label.</li>
</ul>
<h3 id="mpls-capable-routers">MPLS Capable Routers</h3>
<blockquote>
<p>Label-switched router.</p>
</blockquote>
<ul>
<li>Forward packets to outgoing interface based only on label value and does not check IP address.
<ul>
<li>MPLS forwarding table distinct from IP forwarding table.</li>
</ul></li>
<li><strong>Flexibility</strong>: MPLS forwarding decision can <em>differ</em> from those of IP.
<ul>
<li>Use of destination <em>and</em> source address to tour flows to same destination differently (traffic engineering).</li>
<li>Re-route flows quickly if link fails using pre-computed backup paths (useful for VoIP).</li>
</ul></li>
</ul>
<h4 id="mpls-signaling">MPLS Signaling</h4>
<ul>
<li>Modify OSPF (<em>Open Shortest Path First</em>), IS-IS link-state flooding protocols to carry info used by MPLS routing.
<ul>
<li>Link bandwidth, amount of “reserved” link bandwidth.</li>
</ul></li>
<li>Entry MPLS router uses RSVP-TE signalling protocol to set up MPLS forwarding at downstream routers.</li>
</ul>
<p><img src="https://i.imgur.com/Rey7ngq.png" /></p>
<h2 id="data-center-networking">5.6 Data Center Networking</h2>
<ul>
<li>10s to 100s of thousands of hosts, often closely coupled, in close proximity.
<ul>
<li>e.g. Amazon, Google.</li>
</ul></li>
<li><strong>Challenges</strong>.
<ul>
<li>Multiple applications, each serving massive numbers of clients.</li>
<li>Managing / balancing load, avoiding processing, networking, data bottlenecks.</li>
</ul></li>
<li><strong>Load Balancing</strong>: Application-layer routing.
<ul>
<li>Receives external client requests.</li>
<li>Directs workload within data center.</li>
<li>Returns result to external client (hiding data center internals from client).</li>
<li>Firewall.</li>
</ul></li>
<li>Redundant connections must be used in order to reduce chances of faliure.
<ul>
<li>Expenses for maintaining data centers ~ millions per week.</li>
</ul></li>
</ul>
<h2 id="web-request-example">5.7 Web Request Example</h2>
<blockquote>
<p>A student attaches a laptop to a campus network, requests / receives www.google.com.</p>
</blockquote>
<p><img src="https://i.imgur.com/OSgXP2Q.png" /></p>
<ul>
<li>Connecting laptop needs to get its own IP address, address of first-hop router, address of DNS server. <strong>DHCP</strong>.</li>
<li>DHCP request <strong>encapsulated</strong> in <em>UDP</em>, encapsulated in <em>IP</em>, encapsulated in 802.3 Ethernet.
<ul>
<li>IP source (0.0.0.0), IP destination (255.255.255.255).</li>
<li>Need the MAC address of the source (physically set by NIC manufacturer). Destination MAC address is broadcast address (FFFF…)</li>
<li>Switch learns the &lt;MAC, Interface&gt; mapping for the new client.</li>
</ul></li>
<li>Ethernet frame <em>broadcast</em> on LAN, received at router running <em>DHCP</em> server.</li>
<li>Ethernet <em>demuxed</em> to IP demuxed, UDP demuxed to DHCP.</li>
<li>DHCP server formulates <strong>DHCP ACK</strong> containing client’s IP address, IP address of first-hop router for client, name &amp; IP address of DNS server.</li>
<li>Encapsulation at DHCP server, frame forwarded (<em>switch learning</em>) through LAN, demultiplexing at client.</li>
<li>DHCP client receives DHCP ACK reply.</li>
</ul>
<p>Client now has IP address, knows name and address of DNS server, and the IP address of its first-hop router.</p>
<ul>
<li>Before sending <em>HTTP</em> request, need the IP address of www.google.com. Communicate with <strong>DNS</strong>.</li>
<li>We need the MAC address of the router, <strong>ARP</strong>. ARP query broadcasted to the router, ARP reply with the MAC address of the router.</li>
<li>Client now knows MAC address of first hop router, so can now send frame containing DNS query.</li>
</ul>
<p><img src="https://i.imgur.com/hlwdNkU.png" /></p>
<ul>
<li>IP datagram containing DNS query forwarded via LAN switch from client to first-hop router.</li>
<li>IP datagram forwarded from campus network into comcast network, router (tables created by <strong>RIP, OSPF, IS-IS and / or BGP</strong> routing protocols) to DNS server.</li>
<li>Demuxed to DNS server.</li>
<li>DNS server replies to client with IP address of www.google.com.</li>
<li>To send a HTTP request, client first opens a <strong>TCP socket</strong> to web server.</li>
<li>TCP <strong>SYN segment</strong> (3-way handshake) <em>inter-domain routed</em> to web server.</li>
<li>Web server responds with <strong>TCP SYNACK</strong>.</li>
<li>TCP connection established!</li>
<li><strong>HTTP request</strong> sent into TCP socket.</li>
<li>IP datagram containing HTTP request routed to google.com.</li>
<li>Web server responds with <strong>HTTP reply</strong> containing web page.</li>
<li>IP datagram containing HTTP reply routed back to client.</li>
</ul>
</body>
</html>
