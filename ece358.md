ECE 358
=

# 1: Introduction
## 1.1 What *is* the internet?

Millions of connected computing devices.
- **hosts** = **end systems**
- running **network apps**

## Internet protocol stack
**Application**: Running the network applications that you want (HTTP, FTP, SMTP). Implemented using software only.   
**Transport**: Responsible for communication of processes between layers. Mainly implemented using software.  
**Network**: Responsible for routing from source to destination. Implemented using software and hardware.     
**Link**: Transfering to data between physically connected (adjacent) hubs (e.g. Computer -> Router, Router -> Router ...). Hardware.    
**Physical**: How you are transfering physical bits on the wire. Not coverted in this course.

> Before the internet, there were two extra section that were planned.

**Presentation**: Applications to interpret meaning of data (e.g. encryption, compression, etc.).   
**Session**: Synchronization, checkpointing.

If you want these features, it must be implemented in the application layer.

### Encapsulation
**Switch**: Link and physical layers.
**Router**: Network, link, and physical layers.

Information is added from the above layer to the lower.

> **Transport**: Segment  
> **Network Layer**: Datagram     
> **Link Layer**: Frame   

When passing data through, you need to pop the stack (**decapsulation**) and then replace (**encapsulation**).

## Network Security

Internet was not desigend with security in mind. How can bad guys attack and how can we defend? How can we design architechtures that are immune to attacks.

In real life: Hackers hack your system and then you fix the error and catch up.

**Malware** any harmful software.   
> **Virus**: Interaction required.  
> **Worm**: Weakness in application you are already running.    
> **Spyware**: Record keystrokes, web sites, etc.

Infected hosts can be enrolled in **botnet** to help in future attacks.

### Examples of Attacks

**Denial of Service (DoS)**: Attackers infect local computers with a worm in order to all send messages to the target at the same time. Target will be busy services request so they cannot service normal customers.

**Packet "sniffing"**: Passive program that is on the link which listens to and records packets. 

**IP spoofing**: Send a message with a false source address.

# 2: Application Layer

## 2.1: Principles of network applications

### Creating a network app

Only write to run on end systems (not on the internal network). Does not matter if they are servers or clients. We also only care about what we want to do on the application layer and then push to the transport layer which will take care of transmitting the data. This allows for fast developement.

**Client-Server**: Server is always on with a static IP. Client will communicate with servers (intermittent). Client IP addresses will be dynamic.  
**P2P**: Arbitrary end systems directly communicate. Peers request service from other peers and provice service in return (*self scalability*). There is more complex management because there is no central network that controls all uses. Security is also a big issue.

### Process communication
**Process**: program running within a host.
- Within same host, two process communication using *inter-process communication* defined by the OS.
- Processes in different hosts communicate by exchaning messages.

**Client process**: Process that initiates communication.   
**Server process**: Process that waits to be contacted.

Process sends / recieves messages to / from it's **socket**.    
**Socket**: The gate between the application layer and the transport layer. Sockets are similar to doors. Sending process shoves message out of door and relies on the other side of the door to deliver message to the socket at the recieving process.

Example: Chrome tabs. How do we know which tab to put data? There is an identifier for each socket to route the data to the correct tab (You will always talk to port 80 of a server for HTTP requests but you will use a random port).

**Sockets** consists of two parts (for now).
1. Address of host.
2. Port number.

The combination of the two parts will create a **unique identifier** for the socket. Each process has it's own unique socket (there are over 65k ports).

### Application layer protocol defines ...

> **Rules** for when and how process send and respond to messages.

**Types of messages exchanged**: Request, response.     
**Message syntax**: What does each field mean and how fields are delineated.    
**Message semantics**: What do you want the information in the fields to mean.

Examples of open protocols are **HTTP** and **DNS** which are defined in RFCs (*Request For Comments* is a formal document from the Internet Engineering Task Force). An example of a proprietary protocol is **Skype**.

### What transport services does an application need?

> Will be implemented at the application level.

1. **Data Integrity**. Some applications require 100% data transfer whereas other applications (e.g. audio) can tolerate some loss.
2. **Timing**. Time sensitive applications (e.g. Internet telephone, interactive games) require low delay to be *effective*.
3. **Throughput** (How fast the data can be transfered). Some applications require a minimum amount to be *effective*.
4. **Security**. Encryption.

Application | Data Loss | Throughput | Time Sensitive
---|---|---|---
File Transfer | No | Elastic | No
E-Mail | No | Elastic | No
Web Documents | No | Elastic | No
Real-Time AV | Tolerant | Minimum requirements | Yes, 100's ms
Stored AV | Tolerance | Minimum requirements | Yes, few seconds
Interactive Games | Tolerant | Minimum requirements | Yes, 100's ms
Text Messaging | No | Elastic | Yes and No

### Internet transport protocol services

> What is offered by the transport layer? Which protocol should I Use? There are two main protocols ...

1. **TCP** (*Transport Control Protocol*)
    - **Reliable transport** between sending and recieving process. Everything will get there without errors and in order.
    - **Flow control**: Sender won't overwhelm reciever.
    - **Congestion control**: Throttle sender when network is overloaded.
    - **Does not provide**: Timing, minimum throughput guarantee, security.
    - **Connection-oriented**: Setup required between client and server processes.
2. **UDP** (*User Datagram Protocol*)
    - **Unreliable data transfer**: No data integrity or reliability between sending and recieving process.
    - **Does not provide**: Reliability, flow control, congestion control, timing, throughput guarantee, security, or connection setup.

Why bother with UDP?
- **UDP** is faster than **TCP**. There is no connection setup.
- There are no **overhead** bits required.

Application | Application Protocol | Transport Protocol
---|---|---
Email | SMTP | TCP
Remote Terminal Access | Telnet | TCP
Web | HTTP | TCP
File Transfer | FTP | TCP
Streaming Multimedia | HTTP, RTP | TCP or UDP (Usually UDP)
Internet Telephone | SIP, RTP | TCP or UDP

### Securing TCP

**TCP** and **UDP** have no encryption. Plaintext passwords send into sockets.

If you want security, you can use **SSL** (*secury socket layer*) which provices encryption for **TCP** connection. **SSL** is used at the application layer (need to use a **SSL** library such as OpenSSL).

## 2.2: Web and HTTP

> A *web page* consists of *objects*. (HTML, JPEG, Java applet, auto file, ...).
- Web page consists of **base HTML-file** which includes several referenced objects.
- Each object is addressable by a **URL** (Uniform Resource Locator).

**HTTP** (hypertext transfer protocol): We have a client / server model. The client sends requests to the server and the server replies with an HTTP request.

1. HTTP uses TCP. The client initiates TCP connection (creates socket) to server, port 80. (A random port is used on the client side).
2. Server accepts TCP connection from client.
3. HTTP messages (application-layer protocol messages) exchanged between browser (HTTP client) and Web server (HTTP server).
4. TCP connection closed.

*HTTP is "stateless"*. The server maintains no information about past client requests.
> Protocols that maintain "state" are complex. Past history must be maintained and if the client / server crashes, their views of the "state" may be inconsistent.

### Types of HTTP Connections
1. **Non-Persistent HTTP**
    - At most one object sent over TCP connection.
    - Downloading multiple objects requires multiple connections.
    - Server is free more frequently to server other users.
2. **Persistent HTTP**
    - Multiple objects sent over a single TCP connection.
    - Avoid eccessive overhead when requesting multiple objects.

Example: www.someschool.edu/
// TODO - Add it all in

### Response Time
**RTT** (*Round Trip Time*): Time it takes a small packet to travel from client to server and back.

**HTTP Response Time**
- One RTT to initiate TCP
- One RTT for HTTP request and first few bytes of HTTP response in return.
- File transmition time (*transmission delay*).
> Non-Persistent HTTP Response Time = RTT + n(2RTT + file transmission time).    
> Persistent HTTP Response Time = RTT + n(RTT + file transmission time).

For non-persistent HTTP, we require 2 RTT per object. There is OS overhead for *each* TCP connection. Browsers often open parallel TCP connections to fetch referenced objects.

For persistent HTTP, subsequent HTTP messages between client / server will be over the same connection so the client will sent requests as soon as it encounters a referenced object. There is as little as on RTT per referenced object.

### HTTP Request
1. Request Line (method URL version).
    > GET /index.html HTTP/1.1\r\n
2. Header Lines (header_field_name value).
    > Host: www-net.cs.umass.edu\r\n    
    > User-Agent: Firefox/3.6.10\r\n    
    > Keep-Alive: 115\r\n   
    > Connection: keep-alive\r\n (requesting *persistent*)  
    > \r\n (carriage return, line feed at start of line indicates end of header lines)
3. Body.

### HTTP/1.0
- GET (request data).
- POST (send data).
- HEAD (leave requested object out of response).

### HTTP/1.1
- PUT (uploads file in entry to path specified in URL).
- DELETE (delete files specified in URL).

### HTTP Response
1. Status Line (protocol status_code status_phrase).
2. Header Lines (content_length).
3. Data Requested (e.g. HTML file).

### Cookies
> Used to identify users. ID is stored in client side which is sent in the header of subsequent messages.
1. Cookie header line in HTTP *response* from server.
2. Cookie hedaer line in next HTTP *request* from client.
3. Cookie file kept client-side.
4. Back-end database for server.

Cookies are used to keep **state**.

### Web Caches (Proxy Server)
> Satisfy client request without involving the original server.

All requests are sent through a proxy server instead which caches requests and responses. If the request is already cached, it does not have to travel all the way to the original server.
- Typically the cache is insalled by ISP.

Example:
> Average object size: $100\ K bits$.   
> Average request rate: $15\ /\ sec$.     
> RTT from insitutional router to original server: $2\ sec$     
> Access link rate: $1.54\ Mbps$   
>
> We then have LAN utilization: $\frac{1.5\ Mbps}{1\ Gbps} = 0.15\%$   
> Access link utilization: $\frac{1.5\ Mbps}{1.54\ Mbps} = 97.4\%$    
> Total Delay = Internet Delay + Access Delay + LAN Delay   
> Access Delay: $\frac{100\ K}{(1 - 0.974)1.54\ Mbps}$. (New users can only use whatever is left of the access link).   
> LAN Delay: $\frac{100\ K}{(1 - 0.0015)1\ Gbps}$   
> Total Delay $= 2 + 2.5 + 0.0001$

Solutions:
1. Get a faster access link. If the access link rate was increased to $154\ Mbps$, the access link delay drops to $0.0007$ so the total delay is only $2$ sec.

2. Caching. If the cache hit rate was 0.4, 40% of requests are satisfied at the cache. The data rate to browsers over the access link is $0.6 \cdot 1.50\ Mbps = 0.9\ Mbps$. Utilization becomes $0.58$. Total Delay $= 0.6 \cdot$(delay from original servers) + $0.4 \cdot$(delay when satisfied by the cache) $= 0.6(2.15) = 1.29\ sec$.
## 2.3: DNS