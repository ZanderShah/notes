<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>cs247</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="pandoc.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/contrib/auto-render.min.js"></script><script>document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body);
  });</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="cs-247">CS 247</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">using</span> <span class="kw">namespace</span> std;</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    Rational r, s;</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    cout &lt;&lt; <span class="st">&quot;Enter rational number (a/b): &quot;</span>;</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    cin &gt;&gt; r;</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    cout &lt;&lt; <span class="st">&quot;Enter rational number (a/b): &quot;</span>;</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    cin &gt;&gt; s;</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    Rational t(r + s);</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    cout &lt;&lt; r + s &lt;&lt; endl;</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">    cout &lt;&lt; r * s &lt;&lt; endl;</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">    cout &lt;&lt; r == s &lt;&lt; endl;</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">}</a></code></pre></div>
<ul>
<li><p>Default / copy constructors.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">// Using MIL (member initialization list).</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">Rational::Rational(<span class="dt">int</span> num, <span class="dt">int</span> den) : <span class="va">numerator_</span>(num), <span class="va">denominator_</span>(den) {</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="co">// !den &lt;=&gt; den == 0</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    <span class="cf">if</span> (!den) <span class="cf">throw</span> <span class="st">&quot;Divide by zero!&quot;</span>;</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">};</a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">Rational::Rational(<span class="dt">int</span> num) : <span class="va">numerator_</span>(num), <span class="va">denominator_</span>(<span class="dv">1</span>) {};</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">Rational::Rational() : <span class="va">numerator_</span>(<span class="dv">0</span>), <span class="va">denominator_</span>(<span class="dv">1</span>) {};</a>
<a class="sourceLine" id="cb2-10" data-line-number="10"></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="co">// But we can instead use default arguments which would look like ...</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="kw">class</span> Rational {</a>
<a class="sourceLine" id="cb2-13" data-line-number="13"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">    Rational(<span class="dt">int</span> num = <span class="dv">0</span>, <span class="dt">int</span> den = <span class="dv">1</span>) : <span class="va">numerator_</span>(num), <span class="va">denominator_</span>(den) {</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">        <span class="cf">if</span> (!den) <span class="cf">throw</span> <span class="st">&quot;Divide by zero!&quot;</span>;</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">    };</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">};</a>
<a class="sourceLine" id="cb2-18" data-line-number="18"><span class="co">// This will allow for implicit conversions which may be unintuitive to the user so we can denote it with &quot;explicit&quot;.</span></a></code></pre></div></li>
<li><p>Operators.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" data-line-number="1">Rational <span class="kw">operator</span>+(<span class="at">const</span> Rational &amp;lhs, <span class="at">const</span> Rational &amp;rhs) {</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    <span class="co">// Code for adding two rationals together.</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    <span class="co">// Two options. We can write mutators / accessors or friend function.</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="cf">return</span> Rational(...);</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">}</a></code></pre></div>
<p><strong>General rule</strong>: If it doesn’t need to be a member function then it shouldnt.</p>
<p>We passed our operand as a const l-value reference.</p>
<ul>
<li>Behaves like a “const pointer with automatic dereferencing”.</li>
</ul></li>
</ul>
<h3 id="rules-for-function-overloading">Rules for Function Overloading</h3>
<ul>
<li>Must differ in type or number of parameters.</li>
<li>Can’t differ by only return type.</li>
</ul>
<p><strong>Accessors (<em>getters</em>)</strong>: Methods that return the value of a member field.<br />
<strong>Mutators (<em>setters</em>)</strong> :Methods that allow for the setting of member fields.</p>
<p>These restrict the usage of member fields to only those we give access to through the public interface. They also allow usage of member fields only under our ADT’s terms / supervision.</p>
<h3 id="common-naming-convention">Common Naming Convention</h3>
<p>s - attribute, getAttribute(), setAttribute(). - attribute_, attribute(), attributeIs().</p>
<h2 id="should-it-be-a-member">Should it be a member?</h2>
<blockquote>
<p>Only if it has to be.</p>
</blockquote>
<ul>
<li>Constructors, destructors, accessors, mutators.</li>
<li>Virtual methods.</li>
<li>Cannot be written with only our ADT’s provided public interface (need’s access to internals).
<ul>
<li>Could also be a friend. Usually only if it can’t be a member function.</li>
</ul></li>
<li>Certain operators (as per C++ standard) must be members.
<ul>
<li>operator=, operator[], operator(), operator-&gt;, operator T (where T is a type).</li>
</ul></li>
<li>Certain functions can’t / shouldn’t be members.
<ul>
<li>Input and output operators.</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">class</span> Rational {</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    istream &amp;<span class="kw">operator</span>&gt;&gt; (istream &amp;in) {</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">        <span class="co">// Read from in;</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">        <span class="cf">return</span> in;</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    }</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">};</a>
<a class="sourceLine" id="cb4-7" data-line-number="7"></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">    Rational r;</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">    <span class="co">// If we defined operator&gt;&gt; as above.</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">    r &gt;&gt; cin;</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    <span class="co">// We also would not be able to chain reasonably.</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">    Rational rr;</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">    rr &gt;&gt; (r &gt;&gt; cin);</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">    <span class="co">// So we want to stream to be the left-hand side operand.</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">}</a></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" data-line-number="1">istream &amp;<span class="kw">operator</span>&gt;&gt;(istream &amp;in, Rational &amp;r) {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    <span class="dt">char</span> slash;</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="dt">int</span> n, d;</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    in &gt;&gt; n &gt;&gt; slash &gt;&gt; d;</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    r.numeratorIs(n);</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    r.denominatorIs(d);</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    <span class="cf">return</span> in;</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">ostream &amp;<span class="kw">operator</span>&lt;&lt;(ostream &amp;out, <span class="at">const</span> Rational &amp;r) {</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    <span class="co">// We need to make sure that the accessors are declared const.</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    out &lt;&lt; r.numerator() &lt;&lt; <span class="ch">&#39;/&#39;</span> &lt;&lt; r.denominator();</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    <span class="cf">return</span> out;</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">}</a></code></pre></div></li>
<li>In general, prefer <strong>non-member</strong>, <strong>non-friend</strong> functions.
<ul>
<li>Offers better encapsulation.</li>
<li>Compiler ensures accesses cannot be made to private components.</li>
<li>More flexible packaging of data because you can put declarations of standalone functions wherever you want.</li>
</ul></li>
<li>If a member function needs full access and can’t be a member function, then make it a <strong>friend</strong>.</li>
</ul>
<p>Classes can also be friends. This is often used when we have nested classes. Alternatively, if nested class is private, it could just be a struct with full public visibility.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">class</span> Stack {</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    Stack();</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    ~Stack();</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="dt">void</span> push(<span class="dt">int</span> n);</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="dt">int</span> pop();</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="dt">int</span> peek();</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    <span class="kw">class</span> Node {</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">        <span class="kw">friend</span> <span class="kw">class</span> Stack;</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">        Node(<span class="dt">int</span> data, Node *next);</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">        Node(<span class="at">const</span> Node&amp; other);</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">        Node &amp;<span class="kw">operator</span>=(<span class="at">const</span> Node &amp;other);</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">        ~Node();</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">    <span class="kw">private</span>:</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">        <span class="dt">int</span> <span class="va">data_</span>;</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">        Node *<span class="va">next_</span>;</a>
<a class="sourceLine" id="cb6-19" data-line-number="19">    };</a>
<a class="sourceLine" id="cb6-20" data-line-number="20"></a>
<a class="sourceLine" id="cb6-21" data-line-number="21"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb6-22" data-line-number="22">    Node *<span class="va">top_</span>;</a>
<a class="sourceLine" id="cb6-23" data-line-number="23">};</a></code></pre></div>
<blockquote>
<p>Node can be private (and should be in this case) but there are some cases in which the we want the user to access the class but not the constructor (we can just make the constructor private).</p>
</blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" data-line-number="1">Node::Node(<span class="dt">int</span> data, Node *next) : <span class="va">data_</span>(data), <span class="va">next_</span>(next) {}</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="co">// Built in copy-constructor copies all values (byte-wise) of built in types and for any object fields, calls copy-constructor. For our case, it would only be a shallow copy (next node would be shared).</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">Node::Node(<span class="at">const</span> Node &amp;other) : <span class="va">data_</span>{data}, <span class="va">next_</span>{other.<span class="va">next_</span> ? <span class="kw">new</span> Node(*other.<span class="va">next_</span>) : <span class="kw">nullptr</span>} {}</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">Node&amp; Node::<span class="kw">operator</span>=(<span class="at">const</span> Node &amp;other) {</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    <span class="co">// Self-assignment check.</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">    <span class="cf">if</span> (<span class="kw">this</span> == &amp;other) <span class="cf">return</span> *<span class="kw">this</span>;</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    <span class="co">// We need to allocate the memory before just in case new throws an exception.</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">    Node *tmp = other.<span class="va">next_</span> ? <span class="kw">new</span> Node(*other.<span class="va">next_</span>) : <span class="kw">nullptr</span>;</a>
<a class="sourceLine" id="cb7-12" data-line-number="12"></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">    <span class="va">data_</span> = other.<span class="va">data_</span>;</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">    <span class="kw">delete</span> next;</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">    <span class="va">next_</span> = tmp;</a>
<a class="sourceLine" id="cb7-16" data-line-number="16"></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">    <span class="cf">return</span> *<span class="kw">this</span>;</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">}</a>
<a class="sourceLine" id="cb7-19" data-line-number="19"></a>
<a class="sourceLine" id="cb7-20" data-line-number="20">Node::~Node() {</a>
<a class="sourceLine" id="cb7-21" data-line-number="21">    <span class="co">// Calling delete on nullptr is safe</span></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">    <span class="kw">delete</span> <span class="va">next_</span>;</a>
<a class="sourceLine" id="cb7-23" data-line-number="23">}</a></code></pre></div>
<h2 id="copy-and-swap-idiom">Copy and Swap Idiom</h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">class</span> Node {</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    ...</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    <span class="dt">void</span> swap(Node &amp;n);</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">}</a></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;utility&gt;</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="dt">void</span> Node::swap(Node &amp;other) {</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    <span class="bu">std::</span>swap(<span class="va">data_</span>, other.<span class="va">data_</span>);</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    <span class="bu">std::</span>swap(<span class="va">next_</span>, other.<span class="va">next_</span>);</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb9-7" data-line-number="7"></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">Node&amp; Node::<span class="kw">operator</span>=(<span class="at">const</span> Node &amp;other) {</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">    <span class="co">// Destructor for tmp will get called which does the clean-up for us.</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">    Node tmp{other};</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    swap(tmp);</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">    <span class="cf">return</span> *<span class="kw">this</span>;</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">}</a></code></pre></div>
<h2 id="lvalue-references">Lvalue References</h2>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" data-line-number="1">Node plusOne(Node n) {</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">    <span class="cf">for</span> (Node *p = &amp;n; p; p = p-&gt;next()) {</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">        p-&gt;dataIs(p-&gt;data() + <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    }</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    <span class="cf">return</span> n;</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    Node n = <span class="kw">new</span> Node{<span class="dv">0</span>, <span class="kw">new</span> Node{<span class="dv">1</span>, <span class="kw">new</span> Node{<span class="dv">2</span>, <span class="kw">nullptr</span>}}};</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    <span class="co">// m will have to be deep copied from plusOne(n).</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">    Node m = plusOne(n);</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">}</a></code></pre></div>
<blockquote>
<p>lvalue is anything with a memory address.<br />
rvalues are temporary objects.</p>
</blockquote>
<p>To create a reference to an rvalue, you use &amp;&amp;. Now, we have a new important constructor and assignment operator.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">class</span> Node {</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">    ...</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    Node(Node &amp;&amp;other);</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    Node &amp;<span class="kw">operator</span>=(Node &amp;&amp;other);</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">};</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">Node::Node(Node &amp;&amp;other) : <span class="va">data_</span>(other.<span class="va">data_</span>), <span class="va">next_</span>(other.<span class="va">next_</span>) {</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">    <span class="co">// Need to set to nullptr so that the destructor doesn&#39;t destroy the data we stole.</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    other.<span class="va">next_</span> = <span class="kw">nullptr</span>;</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">}</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">Node &amp; Node::<span class="kw">operator</span>=(Node &amp;&amp;other) {</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">    swap(other);</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">    <span class="cf">return</span> *<span class="kw">this</span>;</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">}</a></code></pre></div>
<h2 id="c-gives-you">C++ Gives You</h2>
<ol type="1">
<li>Default constructor (<em>disappears as soon as any other constructor is written</em>).</li>
<li>Copy constructor (<em>copies all fields</em>).</li>
<li>Destructor (<em>does nothing</em>).</li>
<li>Copy assignment operator (<em>copy assign all fields</em>).</li>
<li>Move constructor (<em>identical to built in copy constructor, disappears if you write a copy constructor</em>).</li>
<li>Move assignment operator (<em>same thing but with copy assignment operator</em>).</li>
</ol>
<h2 id="when-are-defaults-insufficient">When Are Defaults Insufficient?</h2>
<ul>
<li>When you own a resource.</li>
<li>You have logical / semantic meaning to these operations / your objects.</li>
<li><strong>Big 5</strong>: {copy constructor, move constructor, copy assignment operator, move assignment operator, destructor};
<ul>
<li>Rule of thumb is that if you need 1, you need all 5.</li>
</ul></li>
</ul>
<p>Compilers can leave out copy / move constructors and call the basic constructor in the right memory location.</p>
<h2 id="entity-vs.value-objects">Entity vs. Value Objects</h2>
<blockquote>
<p>Does the object represent something in the real world or is it just an attribute that describes the state?</p>
</blockquote>
<h3 id="entity-object">Entity Object</h3>
<ul>
<li>Computer embodiment of a real world entity.</li>
<li>Each object has a distinct entity.</li>
<li>Objects with same attribute values does not imply they are the same.</li>
</ul>
<p>Examples:</p>
<blockquote>
<p><strong>Physical objects</strong>: airplane, runway, taxiway.<br />
<strong>People</strong>: passengers, booking attendant.<br />
<strong>Records</strong>: customer info, flight schedule, boarding pass.<br />
<strong>Transactions</strong>: reservations, cancellations, reciepts.</p>
</blockquote>
<h3 id="value-object">Value Object</h3>
<ul>
<li>Value objects simply represent a value in our ADT.</li>
<li>Value objects with same attribute values are considered to be identical.</li>
</ul>
<p>Example: Consider a video blackgack game. Which of the following should be implemented as entity or value objects?</p>
<ul>
<li><strong>Card</strong>: Entity</li>
<li><strong>Deck</strong>: Entity</li>
<li><strong>Hand</strong>: Entity</li>
<li><strong>Player</strong>: Entity</li>
<li><strong>Score</strong>: Value</li>
</ul>
<p>The distinction between entity and value objects is important because it defines how we use the object, and in turn, how we write the class.</p>
<h3 id="design-of-entity-adts">Design of Entity ADTs</h3>
<p>An operation on an entity object should represent a real life event.</p>
<ul>
<li>Prohibit copy construtor.</li>
<li>Prohibit assignment.</li>
<li>Prohibit type conversions.</li>
<li>Avoid equality (except of attributes).</li>
<li>Clone operation may be useful.</li>
<li>Computations on entities are generally not meaningful.</li>
<li>Think twice about overloading operators for your entity classes other than new and delete.</li>
<li>operator&lt; may be useful if it operates on name or some unique id.</li>
<li>Refer to entity objects through pointer or reference.</li>
<li>May allow moves …</li>
<li>Construction of a new object should reflect a new object in real life.</li>
</ul>
<h3 id="prohibiting-copy-constructor">Prohibiting Copy Constructor</h3>
<ul>
<li>Previous to c++11, declare private and don’t implement.</li>
<li>From c++11 onwards, we can delete it.</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">class</span> X {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    X(<span class="at">const</span> &amp; x) = <span class="kw">delete</span>;</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    X &amp; <span class="kw">operator</span>=(<span class="at">const</span> &amp; x) = <span class="kw">delete</span>;</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">};</a></code></pre></div>
<h3 id="design-of-value-adts">Design of Value ADTs</h3>
<ul>
<li>Equality <strong>is</strong> important in value types.
<ul>
<li>May be non-trivial (e.g. Matrix).</li>
</ul></li>
<li>Copy constructor, assignment operator.</li>
<li>Virtual methods / inheritance is uncommon.</li>
</ul>
<h2 id="mutable-vs.immutable">Mutable vs. Immutable</h2>
<ul>
<li>Mutable objects can cause problems when they are referenced by more than one variables.</li>
</ul>
<p>Entity objects are usually mutable. Their attributes can change via mutators.</p>
<p>Value based objects should be immutable. Instead, variables of the ADT are assigned to different objects (reassignment). All field types should be primitive or immutable types.</p>
<h3 id="writing-immutable-adts">Writing Immutable ADTs</h3>
<ul>
<li><strong>No</strong> mutators.</li>
<li>Fields should be private.</li>
<li>Make sure methods don’t get overwritten or class at all.</li>
<li>Declare class <em>final</em> (strong immutability).
<ul>
<li>Or declare methods <em>final</em>.</li>
</ul></li>
</ul>
<h2 id="static-members">Static Members</h2>
<ul>
<li>You can declare fields of a class and methods static.</li>
<li>Shared across objects of that class, tied / global to class scope.</li>
</ul>
<h1 id="singleton-design-anti-pattern">Singleton Design (Anti) Pattern</h1>
<ul>
<li>The singleton pattern is used when we have a class for which we only ever want one instance of that class and the object is used across much of the system.
<ul>
<li>Valid example would be a settings class for an application / game.</li>
</ul></li>
<li>It is better design to just pass the class around where it is needed.</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">class</span> Egg {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">    <span class="at">static</span> Egg e; <span class="co">// Singleton Object.</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    Egg(<span class="dt">int</span> ii) : i(ii) {} <span class="co">// Private Constructor.</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6"></a>
<a class="sourceLine" id="cb13-7" data-line-number="7"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">    <span class="at">static</span> Egg &amp; instance() {</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">        <span class="cf">return</span> e;</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb13-11" data-line-number="11"></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">    <span class="dt">int</span> val() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">        <span class="cf">return</span> i;</a>
<a class="sourceLine" id="cb13-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb13-15" data-line-number="15"></a>
<a class="sourceLine" id="cb13-16" data-line-number="16">    Egg(<span class="at">const</span> &amp; Egg) = <span class="kw">delete</span>;</a>
<a class="sourceLine" id="cb13-17" data-line-number="17">    Egg &amp; <span class="kw">operator</span>=(<span class="at">const</span> Egg &amp;) = <span class="kw">delete</span>;</a>
<a class="sourceLine" id="cb13-18" data-line-number="18">};</a>
<a class="sourceLine" id="cb13-19" data-line-number="19"></a>
<a class="sourceLine" id="cb13-20" data-line-number="20">Egg Egg::e(<span class="dv">42</span>); <span class="co">// How you initialize the singleton egg.</span></a></code></pre></div>
<h1 id="compilation-and-linking">Compilation and Linking</h1>
<p>If we need to change the size of a class because we need a new variable, all clients must recompile.</p>
<h2 id="pimpl-idiom-pointer-to-implementation">pImpl Idiom (<em>Pointer to Implementation</em>)</h2>
<ul>
<li>Only the pointer class needs to recompile, the rest just need to relink.</li>
</ul>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="co">// XWindow Impl.cc</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="pp">#include </span><span class="im">&lt;xll/xlib.h&gt;</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="kw">struct</span> XWindowImpl {</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    Display *d;</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    Window w;</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    <span class="dt">int</span> s;</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">    GC gc;</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">    <span class="dt">unsigned</span> <span class="dt">long</span> colours[<span class="dv">10</span>];</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">}</a></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">// XWindow.h</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="kw">class</span> XWindow {</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    XWindowImpl * pImpl;</a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    <span class="co">// Same as before.</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">}</a></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">// XWindow.cc</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">XWindow::XWindow(...) : pImpl(<span class="kw">new</span> XWindowImpl(...)) {}</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="co">// All other members, usages of d, w, s, ... become pImpl-&gt;d ...</span></a></code></pre></div>
<h1 id="namespaces-and-directives">Namespaces and Directives</h1>
<ul>
<li><strong>Never</strong> place a using statement in a header file.</li>
<li><strong>Never</strong> place a using statement before an include.</li>
</ul>
<p>Defining your own namespace may be used for subdividing global namespace into named space. Within a namespace, you can refer to other members by their local names.</p>
<ul>
<li>Namespaces can be defined at a global scope or within another class.</li>
</ul>
<p><strong>Module</strong>: A software component that encapsulates some design decision.</p>
<h2 id="interface">Interface</h2>
<blockquote>
<p>Abstraction public description of some module.</p>
</blockquote>
<ul>
<li>Supports the hiding of information.</li>
<li>Reduces information overload on the client programmers.</li>
</ul>
<h2 id="benefits-of-modularity">Benefits of Modularity</h2>
<ul>
<li>Simplifies development.</li>
<li>Supports teamwork.</li>
<li>Facilitates change because it consolidates all information required for a module in one place and allows for the implementation to change as long as the interface is identical.</li>
</ul>
<h2 id="interface-specification">Interface Specification</h2>
<blockquote>
<p>Defines what the unit requires, in the way of services of assumptions for it to work correctly.</p>
</blockquote>
<h3 id="cs-247-interface-specification">CS 247 Interface Specification</h3>
<p><strong>Precondition</strong>: Constraints that must hold <strong>before</strong> the function is called. <strong>Postconditions</strong>: COnstraints that hold <strong>after</strong> the function is called. <strong>Modifies</strong>: The objects / variables this function may modify. <strong>Throws</strong>: Exceptions your function may throw, and conditions under which they are thrown. <strong>Ensures</strong>: Guaranteed side effects on modified objects. <strong>Returns</strong>: Describes return value.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="co">// sumVector.h</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="dt">int</span> sumVector(<span class="at">const</span> <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; &amp; vect);</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="co">// Preconditions: vect is a valid vector whose content&#39;s sum does not overflow.</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5"><span class="co">// Requires ...</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6"><span class="co">// Modifies ...</span></a>
<a class="sourceLine" id="cb17-7" data-line-number="7"><span class="co">// Ensures ...</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8"><span class="co">// Returns ...</span></a>
<a class="sourceLine" id="cb17-9" data-line-number="9"></a>
<a class="sourceLine" id="cb17-10" data-line-number="10"><span class="dt">int</span> sumVector(<span class="at">const</span> <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; &amp; vect) {</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">    <span class="dt">int</span> sum = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">    <span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; vect.size(); ++i) {</a>
<a class="sourceLine" id="cb17-13" data-line-number="13">        sum += vect[i];</a>
<a class="sourceLine" id="cb17-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb17-15" data-line-number="15">    <span class="cf">return</span> sum;</a>
<a class="sourceLine" id="cb17-16" data-line-number="16">}</a></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">class</span> IntStack {</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">    <span class="co">// Specification Fields:</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">    <span class="co">// stack</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    <span class="co">// top = top element of stack</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    IntStack();</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">    <span class="co">// Ensures: Initializes stack to an empty stack.</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8"></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">    ~IntStack();</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">    <span class="co">// Modifies: stack.</span></a>
<a class="sourceLine" id="cb18-11" data-line-number="11">    <span class="co">// Ensures: stack no longer exists, memory is all freed.</span></a>
<a class="sourceLine" id="cb18-12" data-line-number="12"></a>
<a class="sourceLine" id="cb18-13" data-line-number="13">    <span class="dt">void</span> push(<span class="dt">int</span> elem);</a>
<a class="sourceLine" id="cb18-14" data-line-number="14">    <span class="co">// Modifies: stack, top.</span></a>
<a class="sourceLine" id="cb18-15" data-line-number="15">    <span class="co">// Ensures: stack is appended with elem, top = elem.</span></a>
<a class="sourceLine" id="cb18-16" data-line-number="16"></a>
<a class="sourceLine" id="cb18-17" data-line-number="17">    <span class="dt">int</span> top();</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">    <span class="co">// Requires: stack is non-empty.</span></a>
<a class="sourceLine" id="cb18-19" data-line-number="19">    <span class="co">// Returns: top.</span></a>
<a class="sourceLine" id="cb18-20" data-line-number="20"></a>
<a class="sourceLine" id="cb18-21" data-line-number="21">    <span class="dt">void</span> pop();</a>
<a class="sourceLine" id="cb18-22" data-line-number="22">    <span class="co">// Modifies: stack, top.</span></a>
<a class="sourceLine" id="cb18-23" data-line-number="23">    <span class="co">// Ensures: If stack@pre is empty, then stack is empty.</span></a>
<a class="sourceLine" id="cb18-24" data-line-number="24">    <span class="co">//          Otherwise, stack = stack@pre with elem removed.</span></a>
<a class="sourceLine" id="cb18-25" data-line-number="25">    <span class="co">//          top = remaining top of nothing if stack is empty.</span></a>
<a class="sourceLine" id="cb18-26" data-line-number="26">};</a></code></pre></div>
<p><em>Stack</em> and <em>top</em> are <strong>Abstract Specification Data Members</strong>. They don’t define the actual structure / fields of our class but rather a way to describe the client’s view of the objects state that we can write expressions over.</p>
<p>An <strong>interface specification</strong> describes the behaviour of some software unit (function or class). An implementation <strong>satisfies</strong> a specification if it conforms to the described behaviour.</p>
<p>The <strong>specificand set</strong> of a spec is the set of all conforming implementations. A <strong>strong</strong> specification is more tolerant on inputs, and more demanding on outputs. A <strong>weak</strong> specification is more demanding on inputs, and more tolerant on outputs.</p>
<p>Spec <span class="math inline">\(A\)</span> is stronger than <span class="math inline">\(B\)</span> (<span class="math inline">\(A \ge B\)</span>) if and only if.</p>
<blockquote>
<ol type="1">
<li><span class="math inline">\(A\)</span>’s preconditions are equal to or stronger than <span class="math inline">\(B\)</span>’s.
<ul>
<li>Requires <span class="math inline">\(A\)</span> <span class="math inline">\(\ge\)</span> Requires <span class="math inline">\(B\)</span>.</li>
</ul></li>
<li><span class="math inline">\(A\)</span>’s postconditions are stronger or equal to <span class="math inline">\(B\)</span>’s.
<ul>
<li>Requires <span class="math inline">\(B\)</span> <span class="math inline">\(\ge\)</span> (Ensures <span class="math inline">\(A\)</span> <span class="math inline">\(\cap\)</span> Returns <span class="math inline">\(A\)</span>) <span class="math inline">\(\ge\)</span> (Ensures <span class="math inline">\(B\)</span> <span class="math inline">\(\cap\)</span> Returns <span class="math inline">\(B\)</span>).</li>
</ul></li>
<li><span class="math inline">\(A\)</span> modifies the same or more objects than <span class="math inline">\(B\)</span>.</li>
<li><span class="math inline">\(A\)</span> throws the same or fewer exceptions than <span class="math inline">\(B\)</span>.</li>
</ol>
</blockquote>
<h3 id="preconditions">Preconditions</h3>
<ul>
<li>The client is responsible for holding preconditions before calling your code.</li>
<li>Best practice is that if the precondition is easy to check, do so and throw exceptions if violated.</li>
</ul>
<h2 id="handling-exceptions">Handling Exceptions</h2>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;stdexcept&gt;</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"></a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="cf">try</span> {</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    cout &lt;&lt; v.at(<span class="dv">100000</span>) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">} <span class="cf">catch</span> (out_of_range) {</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">    cerr &lt;&lt; <span class="st">&quot;Range Error.&quot;</span> &lt;&lt; endl;</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">}</a></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="dt">void</span> f() {</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">    <span class="co">// out_of_range is a class. out_of_range(&quot;f&quot;) is a constructor call.</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">    <span class="cf">throw</span> out_of_range(<span class="st">&quot;f&quot;</span>);</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb20-5" data-line-number="5"></a>
<a class="sourceLine" id="cb20-6" data-line-number="6"><span class="dt">void</span> g() {</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    f();</a>
<a class="sourceLine" id="cb20-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb20-9" data-line-number="9"></a>
<a class="sourceLine" id="cb20-10" data-line-number="10"><span class="dt">void</span> h() {</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">    g();</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb20-13" data-line-number="13"></a>
<a class="sourceLine" id="cb20-14" data-line-number="14"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">    <span class="co">// The exception is propogated if it is not in a try or if there is no matching catch.</span></a>
<a class="sourceLine" id="cb20-16" data-line-number="16">    <span class="cf">try</span> {</a>
<a class="sourceLine" id="cb20-17" data-line-number="17">        h();</a>
<a class="sourceLine" id="cb20-18" data-line-number="18">    } <span class="cf">catch</span> (out_of_range ex) {</a>
<a class="sourceLine" id="cb20-19" data-line-number="19">        cout &lt;&lt; ex.what() &lt;&lt; endl;</a>
<a class="sourceLine" id="cb20-20" data-line-number="20">        ...</a>
<a class="sourceLine" id="cb20-21" data-line-number="21">        <span class="cf">throw</span>; <span class="co">// throw s; may cause issues if inheritance in exceptions.</span></a>
<a class="sourceLine" id="cb20-22" data-line-number="22">    } <span class="cf">catch</span> (...) {</a>
<a class="sourceLine" id="cb20-23" data-line-number="23">        <span class="co">/// catch (...) will catch everything.</span></a>
<a class="sourceLine" id="cb20-24" data-line-number="24">    }</a>
<a class="sourceLine" id="cb20-25" data-line-number="25">}</a></code></pre></div>
<p>You can throw anything. You can catch by reference to avoid slicing the object but the static type thrown is what determines what gets caught.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">class</span> BaseExn {};</a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="kw">class</span> DerivedExn : <span class="kw">public</span> BaseExn {};</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="dt">void</span> f() {</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">    DerivedExn d;</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">    BaseExn &amp;b = d;</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">    <span class="cf">throw</span> b;</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb21-9" data-line-number="9"></a>
<a class="sourceLine" id="cb21-10" data-line-number="10"><span class="dt">void</span> h() {</a>
<a class="sourceLine" id="cb21-11" data-line-number="11">    DerivedExn d;</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">    <span class="cf">throw</span> d;</a>
<a class="sourceLine" id="cb21-13" data-line-number="13">}</a>
<a class="sourceLine" id="cb21-14" data-line-number="14"></a>
<a class="sourceLine" id="cb21-15" data-line-number="15"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb21-16" data-line-number="16">    ...</a>
<a class="sourceLine" id="cb21-17" data-line-number="17">    <span class="cf">try</span> {</a>
<a class="sourceLine" id="cb21-18" data-line-number="18">        h();</a>
<a class="sourceLine" id="cb21-19" data-line-number="19">    } <span class="cf">catch</span> (BaseExn &amp;h) {</a>
<a class="sourceLine" id="cb21-20" data-line-number="20">        <span class="co">// This handler will run.</span></a>
<a class="sourceLine" id="cb21-21" data-line-number="21">        ...</a>
<a class="sourceLine" id="cb21-22" data-line-number="22">    } <span class="cf">catch</span> (DerivedExn &amp;d) {</a>
<a class="sourceLine" id="cb21-23" data-line-number="23">        ...</a>
<a class="sourceLine" id="cb21-24" data-line-number="24">    }</a>
<a class="sourceLine" id="cb21-25" data-line-number="25">    ...</a>
<a class="sourceLine" id="cb21-26" data-line-number="26">    <span class="cf">try</span> {</a>
<a class="sourceLine" id="cb21-27" data-line-number="27">        f();</a>
<a class="sourceLine" id="cb21-28" data-line-number="28">    } <span class="cf">catch</span> (DerivedExn &amp;d) {</a>
<a class="sourceLine" id="cb21-29" data-line-number="29">        ...</a>
<a class="sourceLine" id="cb21-30" data-line-number="30">    } <span class="cf">catch</span> (BaseExn &amp;h) {</a>
<a class="sourceLine" id="cb21-31" data-line-number="31">        <span class="co">// This handler will run.</span></a>
<a class="sourceLine" id="cb21-32" data-line-number="32">        ...</a>
<a class="sourceLine" id="cb21-33" data-line-number="33">    }</a>
<a class="sourceLine" id="cb21-34" data-line-number="34">}</a></code></pre></div>
<p>You should <strong>never</strong> throw an exception in a destructor because exceptions will unwind the stack which will call the destructors for all stack allocated objects. This can cause multiple unhandled exceptions.</p>
<h3 id="exception-safety">Exception Safety</h3>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="dt">void</span> f() {</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">    MyClass *p = <span class="kw">new</span> MyClass;</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    MyClass mc;</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">    g();</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    <span class="kw">delete</span> P;</a>
<a class="sourceLine" id="cb22-6" data-line-number="6">}</a></code></pre></div>
<p>No leaks in the code, but what if <span class="math inline">\(g\)</span> throws? During stack unwinding, <span class="math inline">\(mc\)</span> is popped off the stack and its destructor runs, freeing any resources associated with it. <span class="math inline">\(p\)</span> is a pointer, when it is popped off the stack, no fancy destructor is called, the object it points to is leaked.</p>
<p>Our only guarantee is that stack allocated data will be popped off (objects will have their destructors run).</p>
<p><strong>C++ Idiom</strong>: Resource acquisition <strong>is</strong> intialization. (<em>RAII</em>). Every resource should be wrapped in a stack allocated object upon acquisition, whose destructor will free it.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;memory&gt;</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="co">// unique_ptr&lt;T&gt; destructor will delete the pointer.</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="co">// std::make_unique&lt;T&gt;();</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4"><span class="dt">void</span> f() {</a>
<a class="sourceLine" id="cb23-5" data-line-number="5">    <span class="kw">auto</span> p = <span class="bu">std::</span>make_unique&lt;MyClass&gt;();</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">    MyClass mc;</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">    g();</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">}</a></code></pre></div>
<p>Unique pointers are <strong>unique</strong> so copying is disabled. Moving is allowed. We also have shared pointers for when we want to copy.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="dt">void</span> f() {</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">    <span class="kw">auto</span> p1 = <span class="bu">std::</span>make_shared&lt;MyClass&gt;();</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    ...</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    <span class="cf">if</span> (...) {</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">        <span class="kw">auto</span> p2 = p1;</a>
<a class="sourceLine" id="cb24-6" data-line-number="6">    } <span class="co">// p2 is popped off, but it does not free the memory.</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">}</a></code></pre></div>
<p>This can be implemented by having a pointer to a counter (<em>reference count</em>). We can increment when copying and decrement when the object no longer points at the same thing. If the reference count drops to 0, the destructor frees the memory.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb25-1" data-line-number="1">MyClass *p = <span class="kw">new</span> MyClass;</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">shared_ptr&lt;MyClass&gt; sp1(p);</a>
<a class="sourceLine" id="cb25-3" data-line-number="3"><span class="cf">if</span> (...) {</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">    shared_ptr&lt;MyClass&gt; sp2(p);</a>
<a class="sourceLine" id="cb25-5" data-line-number="5">    ...</a>
<a class="sourceLine" id="cb25-6" data-line-number="6">} <span class="co">// sp2 goes out of scope and the destructor frees p.</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7">sp1-&gt;myFn(); <span class="co">// SegFault.</span></a></code></pre></div>
<ul>
<li>Error handling itself is an intrinsically non-local problem.</li>
<li>Consider vector::at, the vector class can detect the error but not decide what to do about it.</li>
<li>The client knows what they want to do about an error, but may not be able to detect it.</li>
<li>Throw exceptions when the current context can detect the problem but the problem can’t be solved locally.</li>
</ul>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="dt">void</span> fun_fib(<span class="dt">int</span> n) {</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="cf">if</span> (n == <span class="dv">0</span>) <span class="cf">throw</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    <span class="cf">if</span> (n == <span class="dv">1</span>) <span class="cf">throw</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb26-4" data-line-number="4"></a>
<a class="sourceLine" id="cb26-5" data-line-number="5">    <span class="cf">try</span> {</a>
<a class="sourceLine" id="cb26-6" data-line-number="6">        fun_fib(n - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb26-7" data-line-number="7">    } <span class="cf">catch</span> (<span class="dt">int</span> a) {</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">        <span class="cf">try</span> {</a>
<a class="sourceLine" id="cb26-9" data-line-number="9">            fun_fib(n - <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb26-10" data-line-number="10">        } <span class="cf">catch</span> (<span class="dt">int</span> b) {</a>
<a class="sourceLine" id="cb26-11" data-line-number="11">            <span class="cf">throw</span> (a + b);</a>
<a class="sourceLine" id="cb26-12" data-line-number="12">        }</a>
<a class="sourceLine" id="cb26-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb26-14" data-line-number="14">}</a></code></pre></div>
<blockquote>
<p>This is <strong>very</strong> slow. Orders of magnitude slower than the recursive solution.</p>
</blockquote>
<p>In addition to unique and shared pointers, we also have <strong>weak_ptrs</strong>.</p>
<ul>
<li>Construct a weak pointer from a shared_ptr.</li>
<li>Does not act like a regular pointer as shared an unique.</li>
<li>weak_ptr<T>::lock() returns a shared_ptr to the data that the original shared_ptr pointed at.</li>
<li>weak_ptr<T>::expired checks whether the reference is still valid.</li>
</ul>
<p>Weak pointers are typically used to <strong>break cycles in shared pointers</strong>.</p>
<p>There are three levels of exception safety (no safety is not included) for a function <span class="math inline">\(f\)</span>.</p>
<ol type="1">
<li><strong>Basic Guarantee</strong>: Should <span class="math inline">\(f\)</span> terminate due to an exception, the program will be left in a valid but unspecified state.
<ul>
<li>“Valid” means that no resources are leaked and that any class invariants are not broken.</li>
</ul></li>
<li><strong>Strong Guarantee</strong>: Should <span class="math inline">\(f\)</span> terminate due to an exception, the program state will be as if <span class="math inline">\(f\)</span> were never called.</li>
<li><strong>No-Throw Guarantee</strong>: <span class="math inline">\(f\)</span> will never throw an exception and always complete its task.</li>
</ol>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">class</span> A {...};</a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="kw">class</span> B {...};</a>
<a class="sourceLine" id="cb27-3" data-line-number="3"></a>
<a class="sourceLine" id="cb27-4" data-line-number="4"><span class="kw">class</span> C {</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">    A a;</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">    B b;</a>
<a class="sourceLine" id="cb27-7" data-line-number="7"></a>
<a class="sourceLine" id="cb27-8" data-line-number="8"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb27-9" data-line-number="9">    <span class="dt">void</span> f() {</a>
<a class="sourceLine" id="cb27-10" data-line-number="10">        a.method1(); <span class="co">// Provides strong guarantee.</span></a>
<a class="sourceLine" id="cb27-11" data-line-number="11">        b.method2(); <span class="co">// Provides strong guarantee.</span></a>
<a class="sourceLine" id="cb27-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb27-13" data-line-number="13">};</a></code></pre></div>
<blockquote>
<p>Does C::f provide a strong guarantee? <strong>No</strong> because a.method1() could succeed and make changes but b.method2() could crash (we would not undo changes).</p>
</blockquote>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">class</span> C {</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">    A a;</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    B b;</a>
<a class="sourceLine" id="cb28-4" data-line-number="4"></a>
<a class="sourceLine" id="cb28-5" data-line-number="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb28-6" data-line-number="6">    <span class="dt">void</span> f() {</a>
<a class="sourceLine" id="cb28-7" data-line-number="7">        A temp_a = a;</a>
<a class="sourceLine" id="cb28-8" data-line-number="8">        B temp_b = b;</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">        temp_a.method1();</a>
<a class="sourceLine" id="cb28-10" data-line-number="10">        temp_b.method2();</a>
<a class="sourceLine" id="cb28-11" data-line-number="11">        <span class="co">// Copy assignments cannot throw.</span></a>
<a class="sourceLine" id="cb28-12" data-line-number="12">        a = temp_a;</a>
<a class="sourceLine" id="cb28-13" data-line-number="13">        b = temp_b;</a>
<a class="sourceLine" id="cb28-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb28-15" data-line-number="15">}</a></code></pre></div>
<p>How do we create our objects so copying can’t throw?</p>
<ul>
<li>These are temp objects so we can treat them how we like.</li>
<li>A non-copying swap is core to writing exception safe code.</li>
</ul>
<p>How can we write swaps for objects so that they do not throw?</p>
<ul>
<li>Swapping pointers can’t throw.</li>
<li><strong>Solution</strong>: pImpl idiom!</li>
</ul>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">class</span> CImpl {</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">    A a;</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">    B b;</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">    <span class="kw">friend</span> <span class="kw">class</span> C;</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">};</a>
<a class="sourceLine" id="cb29-6" data-line-number="6"></a>
<a class="sourceLine" id="cb29-7" data-line-number="7"><span class="kw">class</span> C {</a>
<a class="sourceLine" id="cb29-8" data-line-number="8">    unique_ptr&lt;CImpl&gt; pImpl;</a>
<a class="sourceLine" id="cb29-9" data-line-number="9"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb29-10" data-line-number="10">    <span class="dt">void</span> f() {</a>
<a class="sourceLine" id="cb29-11" data-line-number="11">        <span class="kw">auto</span> temp = make_unique&lt;CImpl&gt;(*pImpl);</a>
<a class="sourceLine" id="cb29-12" data-line-number="12">        temp-&gt;a.method1();</a>
<a class="sourceLine" id="cb29-13" data-line-number="13">        temp-&gt;b.method2();</a>
<a class="sourceLine" id="cb29-14" data-line-number="14">        <span class="bu">std::</span>swap(pImpl, temp); <span class="co">// No-throw guarantee.</span></a>
<a class="sourceLine" id="cb29-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb29-16" data-line-number="16">};</a></code></pre></div>
<p>If a function offers the no-throw guarantee, you should mark it as such with “noexcept” keyword. At the very least, move operators should be noexcept. This allow the compiler to make optimizations (e.g. vector::emplace_back).</p>
<p><strong>Why is Encapsulation Important?</strong> To hold class invariants.</p>
<ul>
<li>Without class invariants, it is hard to logic about a piece of software.</li>
<li>A representation invariant applies to an entire class, so across objects of that class.</li>
<li>An abstraction function that maps from legal representations of our data to the actual client facing representation.</li>
</ul>
<p>When deciding the implementation of a class, we do not necessarily know what is better. We want to be able to swap out representations easily / painlessly. We want out specification and ADT to have <strong>Representation Independence</strong>, chnages to the representation do not affect how the ADT is used.</p>
<p>We define some representation invariants <span class="math inline">\(R\)</span> to help us reason about our class and write good code. Defines what is a legal / valid state for our representation invariants. Similarily, we come up with an <strong>Abstraction Function</strong> <span class="math inline">\(A\)</span> which maps from valid states of representation, to our ADTs possible values.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">class</span> Set {</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">    <span class="dt">int</span> *<span class="va">elements_</span>;</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">    <span class="dt">size_t</span> <span class="va">capacity_</span>;</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">    <span class="dt">size_t</span> <span class="va">size_</span>;</a>
<a class="sourceLine" id="cb30-5" data-line-number="5"></a>
<a class="sourceLine" id="cb30-6" data-line-number="6"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb30-7" data-line-number="7">    Set();</a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    ~Set();</a>
<a class="sourceLine" id="cb30-9" data-line-number="9">    <span class="dt">void</span> insert(<span class="dt">int</span> d);</a>
<a class="sourceLine" id="cb30-10" data-line-number="10">    <span class="dt">void</span> remove(<span class="dt">int</span> d);</a>
<a class="sourceLine" id="cb30-11" data-line-number="11">    <span class="dt">bool</span> member(<span class="dt">int</span> d);</a>
<a class="sourceLine" id="cb30-12" data-line-number="12">};</a></code></pre></div>
<ol type="1">
<li>No duplicate elements. <span class="math inline">\(\forall i, j \in \{0 \to size\_ - 1\}\)</span>, <span class="math inline">\(i \neq j \Rightarrow elements\_[i] \neq elements\_[j]\)</span>.</li>
<li>All elements in our set are stored in indices <span class="math inline">\(\{0 \to size\_ - 1\}\)</span> of elements_.</li>
</ol>
<h3 id="methods-need-to-preserve-invariants">Methods Need To Preserve Invariants</h3>
<ol type="1">
<li>Verify that the constructor establishes invariants.</li>
<li>For each method, assume it holds true, prove / verify method does not violate invariant at end.</li>
<li>If encapsulation is not broken, representation invariants hold true.</li>
</ol>
<h3 id="representation-example">Representation Example</h3>
<ul>
<li>If we give access to the representation to the client, they can violate our invariants.</li>
</ul>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">class</span> Node {</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">    <span class="dt">int</span> <span class="va">data_</span>;</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">    Node *<span class="va">next_</span> = <span class="kw">nullptr</span>;</a>
<a class="sourceLine" id="cb31-4" data-line-number="4"></a>
<a class="sourceLine" id="cb31-5" data-line-number="5"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">    Node(<span class="dt">int</span> d, Node *next = <span class="kw">nullptr</span>) : <span class="va">data_</span>(d), <span class="va">next_</span>(next) {}</a>
<a class="sourceLine" id="cb31-7" data-line-number="7">    ~Node() {</a>
<a class="sourceLine" id="cb31-8" data-line-number="8">        <span class="kw">delete</span> <span class="va">next_</span>;</a>
<a class="sourceLine" id="cb31-9" data-line-number="9">    }</a>
<a class="sourceLine" id="cb31-10" data-line-number="10"></a>
<a class="sourceLine" id="cb31-11" data-line-number="11">    Node *next() {</a>
<a class="sourceLine" id="cb31-12" data-line-number="12">        <span class="cf">return</span> <span class="va">next_</span>;</a>
<a class="sourceLine" id="cb31-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb31-14" data-line-number="14">};</a>
<a class="sourceLine" id="cb31-15" data-line-number="15"></a>
<a class="sourceLine" id="cb31-16" data-line-number="16"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb31-17" data-line-number="17">    Node my_list = Node(<span class="dv">1</span>, <span class="kw">new</span> Node(<span class="dv">2</span>, <span class="kw">new</span> Node(<span class="dv">3</span>)));</a>
<a class="sourceLine" id="cb31-18" data-line-number="18">    Node my_list_2 = Node(<span class="dv">0</span>, &amp;my_list);</a>
<a class="sourceLine" id="cb31-19" data-line-number="19">}</a></code></pre></div>
<p>We need <span class="math inline">\(R\)</span>.</p>
<ul>
<li>next_ is either the nullptr or a valid pointer to a heap allocated Node.</li>
<li><span class="math inline">\(\forall o, p \in Nodes\)</span>, <span class="math inline">\(o \neq p \land o.next\_ \Rightarrow o.next\_ \neq p.next\_\)</span>.</li>
</ul>
<h1 id="iterator-pattern">Iterator Pattern</h1>
<blockquote>
<p>We want to be able to iterate over our collection efficiently without exposing the representation.</p>
</blockquote>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="kw">class</span> List {</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">    <span class="kw">struct</span> Node;</a>
<a class="sourceLine" id="cb32-3" data-line-number="3"></a>
<a class="sourceLine" id="cb32-4" data-line-number="4">    Node *list;</a>
<a class="sourceLine" id="cb32-5" data-line-number="5"></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">    Iterator begin() {</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">        <span class="cf">return</span> Iterator(list);</a>
<a class="sourceLine" id="cb32-8" data-line-number="8">    }</a>
<a class="sourceLine" id="cb32-9" data-line-number="9"></a>
<a class="sourceLine" id="cb32-10" data-line-number="10">    Iterator end() {</a>
<a class="sourceLine" id="cb32-11" data-line-number="11">        <span class="cf">return</span> Iterator(<span class="kw">nullptr</span>);</a>
<a class="sourceLine" id="cb32-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb32-13" data-line-number="13"></a>
<a class="sourceLine" id="cb32-14" data-line-number="14"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb32-15" data-line-number="15">    <span class="kw">class</span> Iterator {</a>
<a class="sourceLine" id="cb32-16" data-line-number="16">        <span class="kw">friend</span> <span class="kw">class</span> List;</a>
<a class="sourceLine" id="cb32-17" data-line-number="17"></a>
<a class="sourceLine" id="cb32-18" data-line-number="18">        <span class="kw">explicit</span> Iterator(Node *p) : p(p) {}</a>
<a class="sourceLine" id="cb32-19" data-line-number="19"></a>
<a class="sourceLine" id="cb32-20" data-line-number="20">        Node *p;</a>
<a class="sourceLine" id="cb32-21" data-line-number="21"></a>
<a class="sourceLine" id="cb32-22" data-line-number="22">    <span class="kw">public</span>:</a>
<a class="sourceLine" id="cb32-23" data-line-number="23">        Iterator &amp;<span class="kw">operator</span>++() {</a>
<a class="sourceLine" id="cb32-24" data-line-number="24">            p = p-&gt;next();</a>
<a class="sourceLine" id="cb32-25" data-line-number="25">            <span class="cf">return</span> *<span class="kw">this</span>;</a>
<a class="sourceLine" id="cb32-26" data-line-number="26">        }</a>
<a class="sourceLine" id="cb32-27" data-line-number="27"></a>
<a class="sourceLine" id="cb32-28" data-line-number="28">        <span class="dt">bool</span> <span class="kw">operator</span>!=(<span class="at">const</span> Iterator &amp;other) {</a>
<a class="sourceLine" id="cb32-29" data-line-number="29">            <span class="cf">return</span> p != other.p;</a>
<a class="sourceLine" id="cb32-30" data-line-number="30">        }</a>
<a class="sourceLine" id="cb32-31" data-line-number="31"></a>
<a class="sourceLine" id="cb32-32" data-line-number="32">        <span class="dt">bool</span> <span class="kw">operator</span>==(<span class="at">const</span> Iterator &amp;other) {</a>
<a class="sourceLine" id="cb32-33" data-line-number="33">            <span class="cf">return</span> p == other.p;</a>
<a class="sourceLine" id="cb32-34" data-line-number="34">        }</a>
<a class="sourceLine" id="cb32-35" data-line-number="35"></a>
<a class="sourceLine" id="cb32-36" data-line-number="36">        <span class="dt">int</span> &amp;<span class="kw">operator</span>*() {</a>
<a class="sourceLine" id="cb32-37" data-line-number="37">            <span class="cf">return</span> p-&gt;data;</a>
<a class="sourceLine" id="cb32-38" data-line-number="38">        }</a>
<a class="sourceLine" id="cb32-39" data-line-number="39">    }</a>
<a class="sourceLine" id="cb32-40" data-line-number="40">};</a></code></pre></div>
<h1 id="documenting-representation-invariants">Documenting Representation Invariants</h1>
<ul>
<li>They do nothing if nobody knows about them.</li>
<li>Write them as comments in top of your class.</li>
</ul>
<h2 id="determining-representation-invariants">Determining Representation Invariants</h2>
<ol type="1">
<li>Look for invalid values for your representation.</li>
<li>Think about what assumptions you make or want to make while writing your code.</li>
</ol>
<h2 id="checking-representation-invariants">Checking Representation Invariants</h2>
<ul>
<li>It can be useful for <strong>debugging</strong> purposes to programmatically check our invariants.</li>
<li>Write a method <strong>check_rep</strong> that asserts all of our invariants hold.
<ol type="1">
<li>End of constructors.</li>
<li>Before any const methods.</li>
<li>Before and after non-const methods.</li>
</ol>
<ul>
<li>Generally this should only be used for <strong>debugging</strong> (finding your errors), so remove from production code (preprocessor, build script, etc.).</li>
</ul></li>
<li><strong>Never</strong> ship code different from what you tested.</li>
<li>Asserts can be used for check_rep.
<ul>
<li><strong>Benefits</strong>: Exits the program directly from that location, so it keeps the stack frame / call stack intact.</li>
<li><strong>Negatives</strong>: Exits the program directly from that location, so it does not free up resources and call destructors. The severity of this depends on what resources you are holding.</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="kw">class</span> MyClass {</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">    <span class="dt">bool</span> check_rep();</a>
<a class="sourceLine" id="cb33-3" data-line-number="3"></a>
<a class="sourceLine" id="cb33-4" data-line-number="4"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb33-5" data-line-number="5">    ...</a>
<a class="sourceLine" id="cb33-6" data-line-number="6">    <span class="dt">void</span> foo() {</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">        <span class="pp">#ifdef MYDEBUG_</span></a>
<a class="sourceLine" id="cb33-8" data-line-number="8">        check_rep();</a>
<a class="sourceLine" id="cb33-9" data-line-number="9">        <span class="pp">#endif</span></a>
<a class="sourceLine" id="cb33-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb33-11" data-line-number="11">};</a></code></pre></div>
<blockquote>
<p>g++-5 -std=c++14 -DMYDEBUG_ -c MyClass.cc</p>
</blockquote>
<h2 id="abstraction-function">Abstraction Function</h2>
<p>The abstraction function is not guaranteed to be injective, but it is guaranteed to be surjective. Therefore, it may not have an inverse function.</p>
<p>Example: <strong>Rational r</strong></p>
<blockquote>
<p><span class="math inline">\(AF(r) = \frac{r.numerator\_}{r.denominator\_}\)</span><br />
<span class="math inline">\(AF(r) = \{elements\_[i] | 0 \le i \le r.size\_\}\)</span></p>
</blockquote>
<p>There is no concrete language for talking about our abstract values.</p>
<ul>
<li>It can be defined with maths , if not then we might to define by example.</li>
</ul>
<p>Example: A set <span class="math inline">\(S\)</span> over the integers in range <span class="math inline">\(0, ..., 255\)</span>.</p>
<blockquote>
<p>Bit vector stored in a char <span class="math inline">\(c\)</span>, integer <span class="math inline">\(i\)</span> is in set if and only iff c &amp; (1 &lt;&lt; i). <span class="math inline">\(AF(r) = \{\forall i \in [0, 255] | c \&amp; (1 &lt;&lt; i) \}\)</span></p>
</blockquote>
<h1 id="models-uml">Models (<em>UML</em>)</h1>
<blockquote>
<p>An abstraction of something.</p>
</blockquote>
<ul>
<li>Help to understand something before you build.</li>
<li>Communicate to others.</li>
<li>Answer questions about the thing being modelled.</li>
<li>We are going to mainly focus on UML class diagrams.</li>
<li>UML consists of ~13 different modelling notations.</li>
</ul>
<h2 id="legend">Legend</h2>
<ul>
<li>+, public</li>
<li>-, private</li>
<li>#, protected</li>
<li>underline, static</li>
<li><em>italics</em>, pure virtual</li>
</ul>
<blockquote>
<p><strong>Note</strong>: We do not use <strong>“in”</strong>. We also do not want to be too specific with types because UML are designed to be language agnostic.</p>
</blockquote>
<h2 id="associations">Associations</h2>
<p>An association represents a relationship between two classes, share a physical or conceptual link.</p>
<ul>
<li><strong>Non-transient link</strong>, not just one parameter of a classes member function.</li>
<li>One class contains another.</li>
<li>We can name our associations (<em>optional</em>).</li>
<li>We can name the roles of associations.</li>
<li>Arrows denote who refers to whom.</li>
<li>Self-association can exist.</li>
<li><strong>Multiplicity</strong>, place them on the side of the relationship that they refer to. It can be just a number (0), a variable (p), a range (0..1), or an asterisk (*) to represent <strong>many</strong>.</li>
</ul>
<blockquote>
<p>Consider marks a student has in a course. To which class should we attribtue marks? Marks should be associated with a pair of (student, course).</p>
</blockquote>
<ul>
<li>We can create association classes that allow for a unique value for each link. The name of the class is the name of the association.</li>
<li>Instances of the association class exists only when a link exists between the associated classes.</li>
<li>Association classes can be used as other classes in your diagram and have associations themselves.</li>
</ul>
<h2 id="relationships">Relationships</h2>
<h3 id="composition-relationship">Composition Relationship</h3>
<blockquote>
<p>A specialization of association, where one class <strong>owns</strong> an object(s) of another class.</p>
</blockquote>
<p>If A <em>owns</em> B, then typically …</p>
<ul>
<li>B has no identity outside of A (no independent existence).</li>
<li>If A is destroyed / copied, B is destroyed / copied.</li>
<li>In code, usually represented by one class having an object field of another, or by an <strong>owning</strong> pointer.</li>
</ul>
<p>Modelled in UML as a solid diamond on the owner connected to the owned.</p>
<h3 id="aggregation-relationship">Aggregation Relationship</h3>
<blockquote>
<p>A specialization of association, where one class <strong>has</strong> objects(s) of a class.</p>
</blockquote>
<p>If A <em>has</em> B then …</p>
<ul>
<li>B has an identity outside of its association with A.</li>
<li>If A is destroyed, B is not necessarily destroyed.</li>
<li>If A is copied, B is not copied (<strong>shallow copy</strong>).</li>
<li>In code, usually represented by <strong>non-owning</strong> pointers.</li>
</ul>
<p>Modelled in UML as a hollow diamond on the owner connected to the owned.</p>
<h3 id="generalization-specialization-relationship">Generalization / Specialization Relationship</h3>
<blockquote>
<p>One class <strong>is</strong> another class.</p>
</blockquote>
<ul>
<li>Public inheritance.</li>
</ul>
<p>Modelled in UML as a hollow triangle pointing to the base class.</p>
<p><img src="https://i.imgur.com/Zm2Kwcj.jpg?1" /></p>
<h2 id="uml-object-model">UML Object Model</h2>
<ul>
<li>An object model models a runtime instance of class model.
<ul>
<li>Every object in our object model is an instantiation of our particular class.</li>
<li>Every link is an instantiation of a specific association.</li>
</ul></li>
</ul>
<p><img src="https://i.imgur.com/ypbv44Q.jpg?1" /></p>
<h2 id="uml-sequence-diagram">UML Sequence Diagram</h2>
<ul>
<li>Graphical model of communication events between objets as exhibited in one execution.</li>
<li>Boxes are the execution patterns.</li>
</ul>
<p><img src="https://i.imgur.com/q2TAAbt.jpg?1" /></p>
<h1 id="design-patterns">Design Patterns</h1>
<ul>
<li>If you have a problem <span class="math inline">\(p\)</span> which is a common problem or simliar to a common problem, then <strong>maybe</strong> design pattern <span class="math inline">\(D\)</span> is a good solution.</li>
</ul>
<h2 id="observer-pattern">Observer Pattern</h2>
<blockquote>
<p>We want to abstract away change.</p>
</blockquote>
<ul>
<li>Publish and subscribe model.</li>
<li>You need to maintain / propogate updates from a source to those it affects.</li>
<li>We have one class called the <strong>publisher</strong> or the <strong>subject</strong> which generates the data.</li>
<li>One or more classes are our <strong>subscribers</strong> or <strong>observers</strong>. They receive updates and react to it.</li>
</ul>
<p>Example: Publisher is spreadsheet cells and observers are our generated graphs.</p>
<ul>
<li>There can be many different kinds of observers, and the subject should not need to know details about them.</li>
</ul>
<p><img src="https://i.imgur.com/Mr3Seyk.jpg?1" /></p>
<ul>
<li>The abstract class subject contains all the code common to all subjects, the abstract class observer defines an interface common to all observers for subject to use.</li>
</ul>
<ol type="1">
<li>Subject’s state is updated.</li>
<li>Subject::notifyObservers is called, it calls notify() on all its observers.</li>
<li>Each observer does their update, which likely involves calling concreteSubject::getState to query the state and react accordingly.</li>
</ol>
<p>Example: Horse Races. The subject publishes the winning horse, the observers are individual betters who will declare victory if their horse wins.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">class</span> Subject {</a>
<a class="sourceLine" id="cb34-2" data-line-number="2">    vector&lt;Observer *&gt; <span class="va">observers_</span>;</a>
<a class="sourceLine" id="cb34-3" data-line-number="3"></a>
<a class="sourceLine" id="cb34-4" data-line-number="4"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">    <span class="dt">void</span> attach(Observer *ob) {</a>
<a class="sourceLine" id="cb34-6" data-line-number="6">        <span class="va">observers_</span>.emplace_back(ob);</a>
<a class="sourceLine" id="cb34-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb34-8" data-line-number="8">    <span class="dt">void</span> detach(Observer *ob);</a>
<a class="sourceLine" id="cb34-9" data-line-number="9">    <span class="dt">void</span> notifyObservers() {</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">        <span class="cf">for</span> (<span class="kw">auto</span> &amp;p : <span class="va">observers_</span>) {</a>
<a class="sourceLine" id="cb34-11" data-line-number="11">            p-&gt;notify();</a>
<a class="sourceLine" id="cb34-12" data-line-number="12">        }</a>
<a class="sourceLine" id="cb34-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb34-14" data-line-number="14">    <span class="kw">virtual</span> ~Subject() = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb34-15" data-line-number="15">    Subject::Subject() {}</a>
<a class="sourceLine" id="cb34-16" data-line-number="16">};</a>
<a class="sourceLine" id="cb34-17" data-line-number="17"></a>
<a class="sourceLine" id="cb34-18" data-line-number="18"><span class="kw">class</span> Observer {</a>
<a class="sourceLine" id="cb34-19" data-line-number="19"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb34-20" data-line-number="20">    <span class="kw">virtual</span> <span class="dt">void</span> notify() = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb34-21" data-line-number="21">    <span class="kw">virtual</span> ~Observer();</a>
<a class="sourceLine" id="cb34-22" data-line-number="22">};</a>
<a class="sourceLine" id="cb34-23" data-line-number="23"></a>
<a class="sourceLine" id="cb34-24" data-line-number="24"><span class="kw">class</span> Horserace : <span class="kw">public</span> Subject {</a>
<a class="sourceLine" id="cb34-25" data-line-number="25">    ifstream <span class="va">in_</span>;</a>
<a class="sourceLine" id="cb34-26" data-line-number="26">    string <span class="va">last_winner_</span>;</a>
<a class="sourceLine" id="cb34-27" data-line-number="27"></a>
<a class="sourceLine" id="cb34-28" data-line-number="28"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb34-29" data-line-number="29">    Horserace(string source) : in{source} {}</a>
<a class="sourceLine" id="cb34-30" data-line-number="30">    ~Horserace() {}</a>
<a class="sourceLine" id="cb34-31" data-line-number="31">    <span class="dt">bool</span> runRace() {</a>
<a class="sourceLine" id="cb34-32" data-line-number="32">        <span class="cf">return</span> <span class="va">in_</span> &gt;&gt; <span class="va">last_winner_</span>;</a>
<a class="sourceLine" id="cb34-33" data-line-number="33">    }</a>
<a class="sourceLine" id="cb34-34" data-line-number="34">    string getState() <span class="at">const</span> {</a>
<a class="sourceLine" id="cb34-35" data-line-number="35">        <span class="cf">return</span> <span class="va">last_winner_</span>;</a>
<a class="sourceLine" id="cb34-36" data-line-number="36">    }</a>
<a class="sourceLine" id="cb34-37" data-line-number="37">};</a>
<a class="sourceLine" id="cb34-38" data-line-number="38"></a>
<a class="sourceLine" id="cb34-39" data-line-number="39"><span class="kw">class</span> Bettor : <span class="kw">public</span> Observer {</a>
<a class="sourceLine" id="cb34-40" data-line-number="40">    Horserace *<span class="va">subject_</span>;</a>
<a class="sourceLine" id="cb34-41" data-line-number="41">    string <span class="va">name_</span>, <span class="va">horse_</span>;</a>
<a class="sourceLine" id="cb34-42" data-line-number="42"></a>
<a class="sourceLine" id="cb34-43" data-line-number="43"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb34-44" data-line-number="44">    Bettor(...) {</a>
<a class="sourceLine" id="cb34-45" data-line-number="45">        <span class="va">subject_</span>-&gt;attach(<span class="kw">this</span>);</a>
<a class="sourceLine" id="cb34-46" data-line-number="46">    }</a>
<a class="sourceLine" id="cb34-47" data-line-number="47">    <span class="dt">void</span> notify() {</a>
<a class="sourceLine" id="cb34-48" data-line-number="48">        string winner = <span class="va">subject_</span>-&gt;getState();</a>
<a class="sourceLine" id="cb34-49" data-line-number="49">        cout &lt;&lt; (winner == <span class="va">horse_</span> ? <span class="st">&quot;Win!&quot;</span> : <span class="st">&quot;Lose.&quot;</span>) &lt;&lt; endl;</a>
<a class="sourceLine" id="cb34-50" data-line-number="50">    }</a>
<a class="sourceLine" id="cb34-51" data-line-number="51">};</a></code></pre></div>
<ul>
<li>If you only have one ConcreteSubject, you may consider merging Subject and ConcreteSubject. Don’t do so lightly however, if you need to add another subject in the future you will have to refactor.</li>
<li>If the state is trivial (i.e. getting notified is all the information you need), you may not need getState method.</li>
<li>If the subject and the observer are the same (e.g. cells in a grid), you could merge these classes.</li>
</ul>
<h2 id="decorator-pattern">Decorator Pattern</h2>
<p>Suppose you want to enhance an object (e.g. adding functionality or features).</p>
<p>Example: Windowing System. We start with a basic window, and then add a toolbar, scrollbar, and a menu. We want the user to be able to choose these at runtime.</p>
<p><img src="https://i.imgur.com/0tFP1IZ.jpg?1" /></p>
<ul>
<li>Every Decorator is a component, and every Decorator has a component.</li>
<li>Example, a window with a scrollbar <strong>is</strong> a window, but it also has a pointer to the underlying plain window.
<ul>
<li>A window with a menu and a scrollbar is a window, but is also has a pointer to the window with a scrollbar.</li>
</ul></li>
</ul>
<p>Example: Pizza.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">class</span> Pizza {</a>
<a class="sourceLine" id="cb35-2" data-line-number="2"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">    <span class="kw">virtual</span> <span class="dt">float</span> price() <span class="at">const</span> = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb35-4" data-line-number="4">    <span class="kw">virtual</span> string description() <span class="at">const</span> = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">    <span class="kw">virtual</span> ~Pizza();</a>
<a class="sourceLine" id="cb35-6" data-line-number="6">};</a>
<a class="sourceLine" id="cb35-7" data-line-number="7"></a>
<a class="sourceLine" id="cb35-8" data-line-number="8"><span class="kw">class</span> CrustAndSauce : <span class="kw">public</span> Pizza {</a>
<a class="sourceLine" id="cb35-9" data-line-number="9"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb35-10" data-line-number="10">    <span class="dt">float</span> price() <span class="at">const</span> <span class="kw">override</span> {</a>
<a class="sourceLine" id="cb35-11" data-line-number="11">        <span class="cf">return</span> <span class="fl">5.99</span>;</a>
<a class="sourceLine" id="cb35-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb35-13" data-line-number="13">    string description() <span class="at">const</span> <span class="kw">override</span> {</a>
<a class="sourceLine" id="cb35-14" data-line-number="14">        <span class="cf">return</span> <span class="st">&quot;Pizza&quot;</span>;</a>
<a class="sourceLine" id="cb35-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb35-16" data-line-number="16">};</a>
<a class="sourceLine" id="cb35-17" data-line-number="17"></a>
<a class="sourceLine" id="cb35-18" data-line-number="18"><span class="kw">class</span> Decorator : <span class="kw">public</span> Pizza {</a>
<a class="sourceLine" id="cb35-19" data-line-number="19"><span class="kw">protected</span>:</a>
<a class="sourceLine" id="cb35-20" data-line-number="20">    Pizza *<span class="va">component_</span>;</a>
<a class="sourceLine" id="cb35-21" data-line-number="21"></a>
<a class="sourceLine" id="cb35-22" data-line-number="22"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb35-23" data-line-number="23">    Decorator(Pizza *p) : <span class="va">component_</span>(p) {}</a>
<a class="sourceLine" id="cb35-24" data-line-number="24">    <span class="kw">virtual</span> ~Decorator() {</a>
<a class="sourceLine" id="cb35-25" data-line-number="25">        <span class="co">// Depends on whether we have aggregation or composition.</span></a>
<a class="sourceLine" id="cb35-26" data-line-number="26">        <span class="kw">delete</span> <span class="va">component_</span>;</a>
<a class="sourceLine" id="cb35-27" data-line-number="27">    }</a>
<a class="sourceLine" id="cb35-28" data-line-number="28">};</a>
<a class="sourceLine" id="cb35-29" data-line-number="29"></a>
<a class="sourceLine" id="cb35-30" data-line-number="30"><span class="kw">class</span> StuffedCrust : <span class="kw">public</span> Decorator {</a>
<a class="sourceLine" id="cb35-31" data-line-number="31"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb35-32" data-line-number="32">    StuffedCrust(Pizza *p) : Decorator(p) {}</a>
<a class="sourceLine" id="cb35-33" data-line-number="33">    <span class="dt">float</span> price() <span class="at">const</span> <span class="kw">override</span> {</a>
<a class="sourceLine" id="cb35-34" data-line-number="34">        <span class="co">// Better to have pass-through methods.</span></a>
<a class="sourceLine" id="cb35-35" data-line-number="35">        <span class="cf">return</span> <span class="va">component_</span>-&gt;price() + <span class="fl">2.69</span>;</a>
<a class="sourceLine" id="cb35-36" data-line-number="36">    }</a>
<a class="sourceLine" id="cb35-37" data-line-number="37">    string description() <span class="at">const</span> <span class="kw">override</span> {</a>
<a class="sourceLine" id="cb35-38" data-line-number="38">        <span class="cf">return</span> <span class="va">component_</span>-&gt;description() + <span class="st">&quot; with Stuffed Crust&quot;</span></a>
<a class="sourceLine" id="cb35-39" data-line-number="39">    }</a>
<a class="sourceLine" id="cb35-40" data-line-number="40">};</a>
<a class="sourceLine" id="cb35-41" data-line-number="41"></a>
<a class="sourceLine" id="cb35-42" data-line-number="42"><span class="kw">class</span> Topping : <span class="kw">public</span> Decorator {</a>
<a class="sourceLine" id="cb35-43" data-line-number="43"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb35-44" data-line-number="44">    string <span class="va">topping_</span>;</a>
<a class="sourceLine" id="cb35-45" data-line-number="45"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb35-46" data-line-number="46">    Topping(Pizza *p, string topping) : Decorator(p), <span class="va">topping_</span>(topping) {}</a>
<a class="sourceLine" id="cb35-47" data-line-number="47">    <span class="dt">float</span> price() <span class="at">const</span> <span class="kw">override</span> {</a>
<a class="sourceLine" id="cb35-48" data-line-number="48">        <span class="cf">return</span> <span class="va">component_</span>-&gt;price() + <span class="fl">0.75</span>;</a>
<a class="sourceLine" id="cb35-49" data-line-number="49">    }</a>
<a class="sourceLine" id="cb35-50" data-line-number="50">    string description() <span class="at">const</span> <span class="kw">override</span> {</a>
<a class="sourceLine" id="cb35-51" data-line-number="51">        <span class="cf">return</span> <span class="va">component_</span>-&gt;description() + <span class="st">&quot; with &quot;</span> + <span class="va">topping_</span>;</a>
<a class="sourceLine" id="cb35-52" data-line-number="52">    }</a>
<a class="sourceLine" id="cb35-53" data-line-number="53">};</a>
<a class="sourceLine" id="cb35-54" data-line-number="54"></a>
<a class="sourceLine" id="cb35-55" data-line-number="55"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb35-56" data-line-number="56">    Pizza *p = <span class="kw">new</span> CrustAndSauce;</a>
<a class="sourceLine" id="cb35-57" data-line-number="57">    p = <span class="kw">new</span> Topping(p, <span class="st">&quot;Cheese&quot;</span>);</a>
<a class="sourceLine" id="cb35-58" data-line-number="58">    p = <span class="kw">new</span> Topping(p, <span class="st">&quot;Pineapple&quot;</span>);</a>
<a class="sourceLine" id="cb35-59" data-line-number="59">    <span class="bu">std::</span>cout &lt;&lt; p-&gt;description() &lt;&lt; <span class="bu">std::</span>endl;</a>
<a class="sourceLine" id="cb35-60" data-line-number="60">    <span class="co">// Pizza with Cheese with Pineapple.</span></a>
<a class="sourceLine" id="cb35-61" data-line-number="61">}</a></code></pre></div>
<h2 id="factory-method-pattern">Factory Method Pattern</h2>
<p>Exampe: We want to write a video game with two kinds of enemies: turtles and bullets. The system randomly sends turtles and bullets, but bullets become more frequent in later levels.</p>
<p>We never know exactly which enemy is going to come next, we (<em>client</em>) can’t call the constructors directly. Moreover, we dont want to hardcode the policy that decides what comes next, it should be customizable. Instead we add a factory method in Level that creates enemies.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">class</span> Level {</a>
<a class="sourceLine" id="cb36-2" data-line-number="2">    ...</a>
<a class="sourceLine" id="cb36-3" data-line-number="3"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb36-4" data-line-number="4">    <span class="co">// Factory method.</span></a>
<a class="sourceLine" id="cb36-5" data-line-number="5">    <span class="kw">virtual</span> Enemy *createEnemy() = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb36-6" data-line-number="6">    ...</a>
<a class="sourceLine" id="cb36-7" data-line-number="7">};</a>
<a class="sourceLine" id="cb36-8" data-line-number="8"></a>
<a class="sourceLine" id="cb36-9" data-line-number="9"><span class="kw">class</span> NormalLevel : <span class="kw">public</span> Level {</a>
<a class="sourceLine" id="cb36-10" data-line-number="10">    ...</a>
<a class="sourceLine" id="cb36-11" data-line-number="11"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb36-12" data-line-number="12">    Enemy *createEnemy() <span class="kw">override</span> {</a>
<a class="sourceLine" id="cb36-13" data-line-number="13">        <span class="co">// Create enemies, mostly Turtles.</span></a>
<a class="sourceLine" id="cb36-14" data-line-number="14">    }</a>
<a class="sourceLine" id="cb36-15" data-line-number="15">    ...</a>
<a class="sourceLine" id="cb36-16" data-line-number="16">};</a>
<a class="sourceLine" id="cb36-17" data-line-number="17"></a>
<a class="sourceLine" id="cb36-18" data-line-number="18"><span class="kw">class</span> Castle : <span class="kw">public</span> Level {</a>
<a class="sourceLine" id="cb36-19" data-line-number="19">    ...</a>
<a class="sourceLine" id="cb36-20" data-line-number="20"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb36-21" data-line-number="21">    Enemy *createEnemy() <span class="kw">override</span> {</a>
<a class="sourceLine" id="cb36-22" data-line-number="22">        <span class="co">// Create enemies, mostly Bullets.</span></a>
<a class="sourceLine" id="cb36-23" data-line-number="23">    }</a>
<a class="sourceLine" id="cb36-24" data-line-number="24">    ...</a>
<a class="sourceLine" id="cb36-25" data-line-number="25">};</a></code></pre></div>
<ul>
<li>This pattern is also called the <strong>Virtual Constructor</strong> pattern.</li>
</ul>
<h2 id="template-method-pattern">Template Method Pattern</h2>
<blockquote>
<p>Pattern is used when we want subclasses to override some aspects of a superclass method behaviour but not all.</p>
</blockquote>
<p>Example: Red-shelled Turtles and Green-shelled Turtles.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="kw">class</span> Turtle {</a>
<a class="sourceLine" id="cb37-2" data-line-number="2"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb37-3" data-line-number="3">    <span class="dt">void</span> draw() {</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">        drawHead();</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">        drawShell();</a>
<a class="sourceLine" id="cb37-6" data-line-number="6">        drawFeet();</a>
<a class="sourceLine" id="cb37-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb37-8" data-line-number="8"></a>
<a class="sourceLine" id="cb37-9" data-line-number="9"><span class="kw">private</span>:</a>
<a class="sourceLine" id="cb37-10" data-line-number="10">    <span class="dt">void</span> drawHead() {</a>
<a class="sourceLine" id="cb37-11" data-line-number="11">        ...</a>
<a class="sourceLine" id="cb37-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb37-13" data-line-number="13">    <span class="dt">void</span> drawFeet() {</a>
<a class="sourceLine" id="cb37-14" data-line-number="14">        ...</a>
<a class="sourceLine" id="cb37-15" data-line-number="15">    }</a>
<a class="sourceLine" id="cb37-16" data-line-number="16">    <span class="kw">virtual</span> <span class="dt">void</span> drawShell() = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb37-17" data-line-number="17">};</a></code></pre></div>
<p>Subclasses cannot change the way a turtle is drawn, nor can they change how feet or head are drawn, but they can change how shell is drawn.</p>
<h2 id="non-virtual-interface-nvi-idiom">Non-Virtual Interface (<em>NVI</em>) Idiom</h2>
<blockquote>
<p>The NVI idiom extends the template method by wrapping every virtual method with a non-virtual method.</p>
</blockquote>
<ul>
<li>A public virtual method is really two things.
<ul>
<li>An interface to the client. Indicates provided behaviour, and pre / post conditions, as well as promise representation invariants.</li>
<li>An interface (node) for subclasses. A hook for subclasses to insert specialized behaviour.</li>
</ul></li>
</ul>
<blockquote>
<p>Hard to separate these 2 ideas if they’re wrapped up in one function declaration.</p>
</blockquote>
<ul>
<li>What if you want to separate the customizable behaviour into two methods, with some non-customizable steps in between? We don’t want to change the public interface.</li>
<li>How to make sure all derived classes conform to the pre / post conditions that the parent class promises?</li>
</ul>
<p>The NVI idiom says that all public methods should be <strong>non-virtual</strong>.</p>
<p>All public methods should be non-virtual. All virtual methods should be private, or at the very least protected, with the exception of the destructor.</p>
<p><strong>Bad Example</strong></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="kw">class</span> DigitalMedia {</a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb38-3" data-line-number="3">    <span class="co">// We cannot have control over play without changing all derived classes.</span></a>
<a class="sourceLine" id="cb38-4" data-line-number="4">    <span class="kw">virtual</span> <span class="dt">void</span> play() = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">    <span class="kw">virtual</span> ~DigitalMedia();</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">};</a></code></pre></div>
<p><strong>Translated to NVI</strong></p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="kw">class</span> DigitalMedia {</a>
<a class="sourceLine" id="cb39-2" data-line-number="2">    <span class="kw">virtual</span> <span class="dt">void</span> doPlay() = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb39-3" data-line-number="3"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb39-4" data-line-number="4">    <span class="dt">void</span> play() {</a>
<a class="sourceLine" id="cb39-5" data-line-number="5">        doPlay();</a>
<a class="sourceLine" id="cb39-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb39-7" data-line-number="7">    <span class="kw">virtual</span> ~DigitalMedia();</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">};</a></code></pre></div>
<p><strong>Now</strong> if we want to exert extra control over play, we just put the behaviour we want in the superclass play method. We can add more <em>hooks</em> by calling more virtual methods.</p>
<ul>
<li>It’s much easier to keep control of our interface from the beginning than having to refactor after the fact.</li>
</ul>
<h2 id="adapter-pattern">Adapter Pattern</h2>
<blockquote>
<p>Solves the problem of interface mismatch between two modules.</p>
</blockquote>
<ul>
<li>We want to reuse an existing subsystem (class or library) but its interface doesn’t match our needs.</li>
<li>The interface of one of our modules may change and we dont want to make major changes to the existing working code.</li>
<li>An adapter calss maps one interface (<strong>adaptee</strong>) to another (<strong>target</strong>).</li>
</ul>
<p>Example: STL Stacks are implemented as an adapter of a container class (usually a deque).</p>
<ol type="1">
<li><strong>Object Adapater</strong>.
<ul>
<li>Done through composition, the adapter owns an object of adaptee type.</li>
<li>Generally preferred, better, and cleaner.</li>
</ul></li>
<li><strong>Class Adapter</strong>.
<ul>
<li>Done through inheritance.</li>
<li>Should only be used if behaviour needs to be adjusted and it is easier to do so with overriding.</li>
</ul></li>
</ol>
<h2 id="facade-pattern">Facade Pattern</h2>
<ul>
<li>When subsystem interfaces change, we only need to update Facade.</li>
<li>Supports teamwork, not everyone needs to dedicate time understanding complex subsystem.</li>
<li>Reduce code complexity.</li>
<li>Decoupling subsystem from client code, promotes reuse of subsystems.</li>
<li>Important to note that original subsystem is still available for the client to use.
<ul>
<li>The major difference between Facade and Adapter.</li>
</ul></li>
</ul>
<h2 id="strategy-pattern">Strategy Pattern</h2>
<blockquote>
<p>We want to vary an algorithm (<em>strategy</em>) at runtime.</p>
</blockquote>
<p>We encapsulate the algorithm itself. We define an algorithm as a component object of our class that uses. We will have an ABC for algorithm and use inheritance to specialize.</p>
<p><img src="https://i.imgur.com/wxPLhKQ.jpg?1" /></p>
<ul>
<li>Goal is allowed to switch strategies at runtime. Simply swap strategy pointers.</li>
<li>Similar to Factory Method.</li>
</ul>
<h2 id="visitor-pattern">Visitor Pattern</h2>
<blockquote>
<p>For implementing <strong>double dispatch</strong>.</p>
</blockquote>
<ul>
<li>Virtual methods are chosen based on the actual runtime type of the object.</li>
<li>What if we want to choose a method based on two objects?
<ul>
<li>e.g. Striking an enemy with a weapon.</li>
</ul>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">virtual</span> <span class="dt">void</span> strike(Enemy &amp;e, Weapon &amp;w);</a></code></pre></div>
<ul>
<li>If we put it in Enemy, Enemy::strike(Weapon &amp;w) then you choose based on enemy but not weapon.</li>
<li>If we put it in Weapon, Weapon::strike(Enemy &amp;e) then you choose based on weapon but not enemy.</li>
</ul></li>
<li>The trick is to use <strong>both</strong> overriding, and overloading.</li>
<li>We will have some coupling between the classes inherent to the visitor pattern.</li>
</ul>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">class</span> Enemy {</a>
<a class="sourceLine" id="cb41-2" data-line-number="2"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb41-3" data-line-number="3">    <span class="kw">virtual</span> <span class="dt">void</span> beStruckBy(Weapon &amp;w) = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">};</a>
<a class="sourceLine" id="cb41-5" data-line-number="5"></a>
<a class="sourceLine" id="cb41-6" data-line-number="6"><span class="kw">class</span> Turtle : <span class="kw">public</span> Enemy {</a>
<a class="sourceLine" id="cb41-7" data-line-number="7"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb41-8" data-line-number="8">    <span class="dt">void</span> beStruckBy(Weapon &amp;w) <span class="kw">override</span> {</a>
<a class="sourceLine" id="cb41-9" data-line-number="9">        <span class="co">// Turtle object type.</span></a>
<a class="sourceLine" id="cb41-10" data-line-number="10">        w.strike(*<span class="kw">this</span>);</a>
<a class="sourceLine" id="cb41-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb41-12" data-line-number="12">};</a>
<a class="sourceLine" id="cb41-13" data-line-number="13"></a>
<a class="sourceLine" id="cb41-14" data-line-number="14"><span class="kw">class</span> Bullet : <span class="kw">public</span> Enemy {</a>
<a class="sourceLine" id="cb41-15" data-line-number="15"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb41-16" data-line-number="16">    <span class="dt">void</span> beStruckBy(Weapon &amp;w) <span class="kw">override</span> {</a>
<a class="sourceLine" id="cb41-17" data-line-number="17">        <span class="co">// Bullet object type.</span></a>
<a class="sourceLine" id="cb41-18" data-line-number="18">        w.strike(*<span class="kw">this</span>);</a>
<a class="sourceLine" id="cb41-19" data-line-number="19">    }</a>
<a class="sourceLine" id="cb41-20" data-line-number="20">};</a></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="kw">class</span> Weapon {</a>
<a class="sourceLine" id="cb42-2" data-line-number="2"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb42-3" data-line-number="3">    <span class="kw">virtual</span> <span class="dt">void</span> strike(Turtle &amp;t) = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb42-4" data-line-number="4">    <span class="kw">virtual</span> <span class="dt">void</span> strike(Bullet &amp;b) = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb42-5" data-line-number="5">};</a>
<a class="sourceLine" id="cb42-6" data-line-number="6"></a>
<a class="sourceLine" id="cb42-7" data-line-number="7"><span class="kw">class</span> Stick : <span class="kw">public</span> Weapon {</a>
<a class="sourceLine" id="cb42-8" data-line-number="8"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb42-9" data-line-number="9">    <span class="dt">void</span> strike(Turtle &amp;t) <span class="kw">override</span>;</a>
<a class="sourceLine" id="cb42-10" data-line-number="10">    <span class="dt">void</span> strike(Bullet &amp;b) <span class="kw">override</span>;</a>
<a class="sourceLine" id="cb42-11" data-line-number="11">};</a>
<a class="sourceLine" id="cb42-12" data-line-number="12"></a>
<a class="sourceLine" id="cb42-13" data-line-number="13"><span class="kw">class</span> Rock : <span class="kw">public</span> Weapon {</a>
<a class="sourceLine" id="cb42-14" data-line-number="14"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb42-15" data-line-number="15">    <span class="dt">void</span> strike(Turtle &amp;t) <span class="kw">override</span>;</a>
<a class="sourceLine" id="cb42-16" data-line-number="16">    <span class="dt">void</span> strike(Bullet &amp;b) <span class="kw">override</span>;</a>
<a class="sourceLine" id="cb42-17" data-line-number="17">};</a></code></pre></div>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">    Enemy *e = EnemyFactory();</a>
<a class="sourceLine" id="cb43-3" data-line-number="3">    Weapon *w = WeaponFactory();</a>
<a class="sourceLine" id="cb43-4" data-line-number="4">    e-&gt;beStruckBy(*w);</a>
<a class="sourceLine" id="cb43-5" data-line-number="5">    <span class="co">// Turtle::beStruckBy gets called (virtual dispatch).</span></a>
<a class="sourceLine" id="cb43-6" data-line-number="6">    <span class="co">// This calls Weapon::strike(Turtle &amp;) (overload).</span></a>
<a class="sourceLine" id="cb43-7" data-line-number="7">    <span class="co">// Which is actually calling Stick::strike(Turtle &amp;) (virtual override).</span></a>
<a class="sourceLine" id="cb43-8" data-line-number="8">}</a></code></pre></div>
<ul>
<li>Visitor can be used to add functionality to existing classes, without having to change or recompile them.</li>
</ul>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="kw">class</span> MyClass {</a>
<a class="sourceLine" id="cb44-2" data-line-number="2">    <span class="kw">virtual</span> <span class="dt">void</span> accept(MyClassVisitor &amp;v) {</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">        v.visit(*<span class="kw">this</span>);</a>
<a class="sourceLine" id="cb44-4" data-line-number="4">    }</a>
<a class="sourceLine" id="cb44-5" data-line-number="5">};</a>
<a class="sourceLine" id="cb44-6" data-line-number="6"></a>
<a class="sourceLine" id="cb44-7" data-line-number="7"><span class="kw">class</span> MyClassVisitor {</a>
<a class="sourceLine" id="cb44-8" data-line-number="8">    <span class="kw">virtual</span> <span class="dt">void</span> visit(MyClassA &amp;) = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb44-9" data-line-number="9">    <span class="kw">virtual</span> <span class="dt">void</span> visit(MyClassB &amp;) = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb44-10" data-line-number="10">};</a></code></pre></div>
<h2 id="composite-pattern">Composite Pattern</h2>
<ul>
<li>When written with tree structures, code must be written such that it specializes actions / operations depending on if the data is a leaf or not.</li>
<li>When creating tree-like structures of similar objects, we have a better solution.</li>
<li>A collection of Heroes, which itself contains.
<ul>
<li>An individual hero(s). Leaf.</li>
<li>A collection (team) of heroes. Non-leaf.</li>
</ul></li>
<li>We want a unified interface for our client code to work with the Hero groups or just an individual Hero.</li>
</ul>
<p><img src="https://i.imgur.com/PwG1XIS.jpg?1" /></p>
<blockquote>
<p>Missing a large example about using iterators with HeroTeam and Hero pointer. Please send if you have ~</p>
</blockquote>
<h1 id="measures-of-design-quality">Measures of Design Quality</h1>
<h2 id="coupling">Coupling</h2>
<blockquote>
<p>The degree to which distinct modules interact and rely / <strong>depend</strong> on each other.</p>
</blockquote>
<ul>
<li>If multiple modules are highly coupled, it is indicative to bad design.</li>
</ul>
<h3 id="severity-of-coupling">Severity of Coupling</h3>
<ol type="1">
<li>(<strong>Low</strong>) Modules communicate via function calls with basic parameters / results.</li>
<li>Modules pass arrays / structs back and forth.</li>
<li>Modules affect each other’s control flow.</li>
<li>Modules share global data.</li>
<li>(<strong>High</strong>) Modules share / have access to each other’s implementations (<em>friends</em>).</li>
</ol>
<h3 id="high-coupling">High Coupling</h3>
<ul>
<li>Bad since changes to one module require greater changes to another.</li>
<li>Hard to reuse individual modules.</li>
</ul>
<h2 id="cohesion">Cohesion</h2>
<blockquote>
<p>How closely elements of a module are related to each other.</p>
</blockquote>
<h3 id="levels-of-cohesion">Levels of Cohesion</h3>
<ol type="1">
<li>(<strong>Low</strong>) Arbitrary grouping of unrelated elements. Example: utility.</li>
<li>Element share a common theme, otherwise unrelated.</li>
<li>Elements manipulate the state over the lifetime of an entity.</li>
<li>(<strong>High</strong>) Elements cooperate to perform exactly one task.</li>
</ol>
<h3 id="low-cohesion">Low Cohesion</h3>
<ul>
<li>Indicates poorly organized code.</li>
<li>Hard to understand or maintain.</li>
</ul>
<blockquote>
<p><strong>Goal</strong>: Low coupling and high cohesion.</p>
</blockquote>
<h1 id="decoupling-the-interface-mvc">Decoupling the Interface (<strong>MVC</strong>)</h1>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="kw">class</span> ChessBoard {</a>
<a class="sourceLine" id="cb45-2" data-line-number="2">    ...</a>
<a class="sourceLine" id="cb45-3" data-line-number="3">    cout &lt;&lt; <span class="st">&quot;Your Move&quot;</span> &lt;&lt; ...</a>
<a class="sourceLine" id="cb45-4" data-line-number="4">};</a></code></pre></div>
<ul>
<li>This is bad design, inhibits code reuse.</li>
<li>What if you wanted to reuse ChessBoard class, but not have it communicate through stdout.</li>
</ul>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="kw">class</span> ChessBoard {</a>
<a class="sourceLine" id="cb46-2" data-line-number="2">    ostream &amp;out;</a>
<a class="sourceLine" id="cb46-3" data-line-number="3">    ...</a>
<a class="sourceLine" id="cb46-4" data-line-number="4">    out &lt;&lt; <span class="st">&quot;Your Move&quot;</span> &lt;&lt; ...</a>
<a class="sourceLine" id="cb46-5" data-line-number="5">};</a></code></pre></div>
<ul>
<li>Better, but what if we want a graphical interface?</li>
<li>ChessBoard should not be communicating at all.</li>
<li><strong>“Single Responsibilty Principle”</strong>: A class should only have one reason to change.</li>
</ul>
<h2 id="model-view-controller">Model-View-Controller</h2>
<ul>
<li>Separate the distinct notions of data (state), the presentation of the data, and the control of the data.</li>
<li><strong>Model</strong>: The main data you are manipulating.</li>
<li><strong>View</strong>: How the model is displayed to the user.</li>
<li><strong>Controller</strong>: How the model is manipulated.</li>
</ul>
<h3 id="model">Model</h3>
<ul>
<li>Can have multiple views (e.g. graphical / text).</li>
<li>Does not need to know about their details.</li>
<li>Could be implemented as a class observer, or communicate through the controller.</li>
</ul>
<h3 id="controller">Controller</h3>
<ul>
<li>Mediates communication between model and view.</li>
<li>May encapsulate turn-taking, or full game rules (trade-off with model).</li>
<li>May communicate with the user, or receive messages from view.</li>
</ul>
<h1 id="oo-design-principles">OO Design Principles</h1>
<ul>
<li><strong>Separation of Concerns</strong>, decompose our programs along distinct lines of entities, features, or behaviours.</li>
<li><strong>Low Coupling</strong>.</li>
<li><strong>Info Hiding</strong>, hide implementation and design details behind an abstraction (our interface).</li>
<li>Includes knowledge of our complex object’s structure (pImpl).</li>
<li>Least knowledge principle (law of demeter).</li>
<li>Avoid duplicate code.
<ul>
<li>Shared helper methods.</li>
<li>Inherited method swith implementations when applicable.</li>
<li>Default parameters.</li>
</ul></li>
</ul>
<h2 id="open-closed-principle">Open Closed Principle</h2>
<blockquote>
<p>A module should be <strong>open</strong> to extension, but <strong>closed</strong> to modification. Program to an interface and not to an implementation.</p>
</blockquote>
<p>The idea is that your client code should depend only on ABC’s that can be extended, not on concrete classes (e.g. the <strong>target</strong> interface in Adapter Pattern rather than Client using Adapter directly).</p>
<p><strong>Suggestion</strong>: All base classes should be ABC’s. This implies that you should never inherit from a concrete class.</p>
<ul>
<li>We may not know 100% what we need in our interface when starting out but some subscription to the open closed principle is better than none.</li>
</ul>
<h2 id="inheritance-or-composition">Inheritance or Composition?</h2>
<blockquote>
<p>When defining a new class that includes attributes or behaviour from an existing class, do we inherit or compose?</p>
</blockquote>
<ul>
<li>In general, favour composition over inheritance.
<ul>
<li>Keeps classes focused.</li>
<li>Helps maintain encapsulation.</li>
<li>Can allow for objects to be swapped out at runtime.</li>
</ul></li>
<li>Use inheritance when you are …
<ul>
<li>Using <strong>subtyping</strong> (polymorphic behaviour), when the new class should be substitutable for the old class.</li>
<li>Use the <strong>entire</strong> interface from the old class.</li>
</ul></li>
</ul>
<h2 id="liskov-substitutability-principle-lsp">Liskov Substitutability Principle (LSP)</h2>
<blockquote>
<p>A derived class <strong>must</strong> be substitutable for its base class.</p>
</blockquote>
<ul>
<li>Objects accept all base class messages.</li>
<li>Methods must require <strong>no more</strong> than the base class methods.</li>
<li>Methods promise <strong>no less</strong> than the base class methods.</li>
</ul>
<p>Example: A BoundedStack is a specialized type of Stack that cannot grow past a certain size. Is a BoundedStack substitutable for a Stack? Assume BoundedStack has a limit of 255 elements.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb47-1" data-line-number="1">Stack *s;</a>
<a class="sourceLine" id="cb47-2" data-line-number="2"><span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">1000</span>; ++i) {</a>
<a class="sourceLine" id="cb47-3" data-line-number="3">    s-&gt;push(i);</a>
<a class="sourceLine" id="cb47-4" data-line-number="4">}</a></code></pre></div>
<p><strong>No</strong>, a BoundedStack is <strong>not</strong> substitutable for a Stack. Instead, BoundedStack should be <strong>composed</strong> with a Stack.</p>
<p><strong>Note</strong>: On overriding in c++.</p>
<ul>
<li>Parameter types must match exactly.</li>
<li>Name must match exactly.</li>
<li>Return type must be the same type <strong>or</strong> be a subtype of the original return type.</li>
<li>Use <strong>override</strong> keyword to make sure there are no mistakes.</li>
</ul>
<h2 id="law-of-demeter">Law of Demeter</h2>
<blockquote>
<p>A class should only talk to its neighbours.</p>
</blockquote>
<ul>
<li>Method A::m should only call methods on …
<ul>
<li>A itself.</li>
<li>A’s data members.</li>
<li>m’s parameters.</li>
<li>Objects constructed by A’s methods.</li>
</ul></li>
</ul>
<h3 id="advantages">Advantages</h3>
<ul>
<li>Reduces complexity sine there is at most 1 level of indirection to follow.</li>
<li>Interface is easier to understand for outsiders.</li>
<li>Testing client code and composition object code is easier.</li>
</ul>
<h3 id="disadvantages">Disadvantages</h3>
<ul>
<li>Larger interfaces per class.</li>
<li>Small performance hit.
<ul>
<li>In general, don’t design for performance, design for modularity and cleanly. Then test for bottlenecks and optimize, couple if necessary, those code points.</li>
</ul></li>
</ul>
<p>Examples:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="dt">void</span> A::m1(SomeObj b) {</a>
<a class="sourceLine" id="cb48-2" data-line-number="2">    b.m2() <span class="co">// Ok. Params.</span></a>
<a class="sourceLine" id="cb48-3" data-line-number="3">    <span class="kw">this</span>-&gt;otherObj.m3(); <span class="co">// Ok. A&#39;s data members.</span></a>
<a class="sourceLine" id="cb48-4" data-line-number="4">    b.gen().m4(); <span class="co">// Not ok.</span></a>
<a class="sourceLine" id="cb48-5" data-line-number="5">    AnotherObj obj{};</a>
<a class="sourceLine" id="cb48-6" data-line-number="6">    obj.m5(); <span class="co">// Ok. Object constructed by A&#39;s methods.</span></a>
<a class="sourceLine" id="cb48-7" data-line-number="7">}</a></code></pre></div>
<h1 id="refactoring">Refactoring</h1>
<blockquote>
<p>Changing existing code to “clean it up”.</p>
</blockquote>
<ul>
<li>You are not making externally observable changes. <strong>Not</strong> changing behaviour or interface.</li>
<li>Test suites should be still usable and give the same results after proper refactoring.</li>
<li>You <strong>are</strong> changing the <strong>design</strong> of your software to improve upon it.
<ul>
<li>Easier to understand and modify, striving for a better, cleaner design.</li>
</ul></li>
</ul>
<h2 id="why-refactor">Why Refactor?</h2>
<ul>
<li>Even if you wrote perfectly clean code the first time around (you didn’t), better solutions may become apparent.</li>
<li>Does not happen in reality, <em>“quick and dirty”</em> solutions are used all the time to meet deadlines.</li>
<li>After a while, these sketchy solutions add up and build what is called <strong>“Technical Debt”</strong>.</li>
</ul>
<h2 id="when-refactor">When Refactor?</h2>
<ul>
<li>Upon recognizing a <em>“bad smell”</em>.</li>
<li>When you add a function, it is likely not isolated. We may need to factor to support it.</li>
<li>Code review.</li>
<li>When you fix a bug, it may have been caused by bad design.</li>
</ul>
<h2 id="when-not-to-refactor">When Not To Refactor?</h2>
<ul>
<li>When a deadline is approaching.</li>
<li>Invasive changes that will break other engineers’ mental model of the code.</li>
<li>When prohibitively expensive or time consuming.</li>
<li>Generally, earlier refactoring is less expensive.</li>
</ul>
<h2 id="what-to-refactor">What to Refactor?</h2>
<ul>
<li>Bad smells (indications of bad design).</li>
</ul>
<h3 id="duplicated-code">Duplicated Code</h3>
<ul>
<li>Expressions in different methods of the same class.</li>
<li>Duplicate / similar expressions in “sibling” subclasses.</li>
<li>Methods that perform the same function but with different algorithms.</li>
</ul>
<h3 id="long-method">Long Method</h3>
<ul>
<li>Best to think carefully about major tasks and how they inter-relate.
<ul>
<li>Often a sign of trying to do too much.</li>
<li>Often indicative of poorly thought out abstractions and boundaries.</li>
</ul></li>
<li><strong>Fowler’s Heuristic</strong>: When you see a comment, make a method.</li>
</ul>
<h3 id="large-class">Large Class</h3>
<ul>
<li>Too many member variables, may be trying to do too many things.</li>
<li>Try to eliminate redundancy by gathering codependent pieces and separate into aggregate subparts. Compose yourself of these subparts.</li>
</ul>
<h3 id="long-parameter-list">Long Parameter List</h3>
<ul>
<li>Again, trying to do too much?
<ul>
<li>Trying to do too much, too far from home with too many subparts?</li>
</ul></li>
</ul>
<h3 id="divergent-changes">Divergent Changes</h3>
<ul>
<li>One class commonly refactored / changed in different ways for different reasons.</li>
<li>Containing too many unrelated subparts.</li>
<li>Sign of poor cohesion and responsibility creep (poor boundaries).</li>
</ul>
<h3 id="shotgun-surgery">Shotgun Surgery</h3>
<blockquote>
<p>Opposite of divergent change.</p>
</blockquote>
<ul>
<li>Often when making a seemingly coherent change, you must make many little changes to many classes.</li>
<li>Poor cohesion, possibly high coupling.</li>
</ul>
<h3 id="primitive-obsession">Primitive Obsession</h3>
<ul>
<li>Many member variables all of primitive types.</li>
<li>Probably have constraints and invariants that apply to these values.</li>
<li>Perhaps should be pulled out and wrapped up in a value ADT, or some other aggregate type.</li>
</ul>
<h3 id="feature-envy">Feature Envy</h3>
<ul>
<li>Method <strong>A::m</strong> uses other classes’ methods, features, and data much more than its own.
<ul>
<li>Consider moving <strong>m</strong> to class B.</li>
<li>Some patterns are deliberate exceptions, Strategy, Iterator, Visitor.</li>
</ul></li>
</ul>
<h3 id="lazy-class">Lazy Class</h3>
<ul>
<li>A class that doesn’t do much different than other classes.
<ul>
<li>Could be vestigial, and should be deprecated then removed.</li>
<li>Could be relic from ambitious design hopes.</li>
<li>Could have been gutted from previous refactoring.</li>
</ul></li>
</ul>
<h2 id="automated-testing">Automated Testing</h2>
<ul>
<li>For every new feature you add, you should add a test case.</li>
<li>Should also re-test all of your old tests, to make sure nothing broke.</li>
<li>Build test suite to have a list of automated tests, display which ones fail and any information.</li>
</ul>
<h1 id="casting">Casting</h1>
<blockquote>
<p>Casting should be avoided, and in particular, c-style casting should be avoided. If you must cast, use c++-style.</p>
</blockquote>
<h2 id="casting-in-c">Casting in C</h2>
<div class="sourceCode" id="cb49"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb49-1" data-line-number="1">Node n;</a>
<a class="sourceLine" id="cb49-2" data-line-number="2"><span class="dt">int</span> *ip = (<span class="dt">int</span>*) &amp;n;</a></code></pre></div>
<h2 id="casting-in-c-1">Casting in C++</h2>
<ol type="1">
<li><p><strong>static_cast</strong> is for “sensible-casts” between types where conversion has well-defined behaviour.</p>
<ul>
<li>e.g. DerivedClass pointer to SuperClass pointer (upcast).</li>
</ul>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="dt">double</span> d;</a>
<a class="sourceLine" id="cb50-2" data-line-number="2"><span class="dt">int</span> i = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(d);</a>
<a class="sourceLine" id="cb50-3" data-line-number="3"></a>
<a class="sourceLine" id="cb50-4" data-line-number="4">Hero *h;</a>
<a class="sourceLine" id="cb50-5" data-line-number="5"><span class="co">// Not needed, can implicitly upcast.</span></a>
<a class="sourceLine" id="cb50-6" data-line-number="6">Heroic *heroic = <span class="kw">static_cast</span>&lt;Heroic*&gt;(h);</a></code></pre></div></li>
<li><p><strong>reinterpret_cast</strong> is for unsafe, implementation dependent “weird” conversions. Nearly all uses result in undefined behaviour.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb51-1" data-line-number="1">Student s;</a>
<a class="sourceLine" id="cb51-2" data-line-number="2">Turtle *t = <span class="kw">reinterpret_cast</span>&lt;Turtle*&gt;(&amp;s);</a></code></pre></div></li>
<li><p><strong>const_cast</strong> is for converting between const and non-const. It is the only c++ cast that can “cast away” constness.</p></li>
<li><p><strong>dynamic_cast</strong> asks “is it safe to cast”.</p>
<ul>
<li>What does the pointer actually point to?</li>
<li>Would be better to check if the pointer actually points at an object of the type you are trying to cast to.</li>
</ul>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb52-1" data-line-number="1">Book *pb = ...;</a>
<a class="sourceLine" id="cb52-2" data-line-number="2">Text *pt = <span class="kw">dynamic_cast</span>&lt;Text*&gt;(pb);</a></code></pre></div>
<ul>
<li>If pb actually points to a Text object, dynamic_cast&lt;Text*&gt; will return the pointer passed in.</li>
<li>If pb does <strong>not</strong> point to a Text object, dynamic_cast&lt;Text*&gt; will return the nullptr.</li>
</ul>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="cf">if</span> (pt) cout &lt;&lt; pt-&gt;subject();</a>
<a class="sourceLine" id="cb53-2" data-line-number="2"><span class="cf">else</span> cout &lt;&lt; <span class="st">&quot;Not a text.&quot;</span>;</a></code></pre></div>
<ul>
<li>These casts have been operating on raw pointer, but you should be using smart pointers.</li>
<li>We must use the versions of these functions made for smart pointers which are defined in &lt;memory&gt;.</li>
</ul>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb54-1" data-line-number="1">static_pointer_cast&lt;T&gt;();</a>
<a class="sourceLine" id="cb54-2" data-line-number="2">const_pointer_cast&lt;T&gt;();</a>
<a class="sourceLine" id="cb54-3" data-line-number="3">dynamic_pointer_cast&lt;T&gt;();</a></code></pre></div>
<ul>
<li>dynamic_cast can only be used on types that have at least one virtual method because it replies on runtime type information (RTTI) that only exists if you have virtual methods. We can use dynamic_cast on references and make decisions based on RTII but making decisions based on RTII is exactly against OOP principles.</li>
</ul>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="dt">void</span> what(Book &amp;b) {</a>
<a class="sourceLine" id="cb55-2" data-line-number="2">    Text &amp;rt = <span class="kw">dynamic_cast</span>&lt;Text&amp;&gt;(b);</a>
<a class="sourceLine" id="cb55-3" data-line-number="3">    <span class="co">// If b does not refer to a Text object, we throw.</span></a>
<a class="sourceLine" id="cb55-4" data-line-number="4">}</a></code></pre></div>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="dt">bool</span> HeroTeamIter::<span class="kw">operator</span>!=(<span class="at">const</span> Iterator &amp;other) {</a>
<a class="sourceLine" id="cb56-2" data-line-number="2">    <span class="cf">try</span> {</a>
<a class="sourceLine" id="cb56-3" data-line-number="3">        <span class="at">const</span> HeroTeamIter &amp;o = <span class="kw">dynamic_cast</span>&lt;<span class="at">const</span> HeroTeamIter&amp;&gt;(other);</a>
<a class="sourceLine" id="cb56-4" data-line-number="4">        <span class="cf">return</span> !(ourField == o.ourField ...);</a>
<a class="sourceLine" id="cb56-5" data-line-number="5">    } <span class="cf">catch</span> (...) {</a>
<a class="sourceLine" id="cb56-6" data-line-number="6">        <span class="cf">return</span> <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb56-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb56-8" data-line-number="8">}</a></code></pre></div></li>
</ol>
<h1 id="virtual-methods-review">Virtual Methods Review</h1>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb57-1" data-line-number="1"><span class="kw">class</span> vec {</a>
<a class="sourceLine" id="cb57-2" data-line-number="2">    <span class="dt">int</span> x, y;</a>
<a class="sourceLine" id="cb57-3" data-line-number="3"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb57-4" data-line-number="4">    <span class="dt">int</span> something();</a>
<a class="sourceLine" id="cb57-5" data-line-number="5">};</a>
<a class="sourceLine" id="cb57-6" data-line-number="6"></a>
<a class="sourceLine" id="cb57-7" data-line-number="7"><span class="kw">class</span> vec2 {</a>
<a class="sourceLine" id="cb57-8" data-line-number="8">    <span class="dt">int</span> x, y;</a>
<a class="sourceLine" id="cb57-9" data-line-number="9"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb57-10" data-line-number="10">    <span class="kw">virtual</span> <span class="dt">int</span> something();</a>
<a class="sourceLine" id="cb57-11" data-line-number="11">};</a>
<a class="sourceLine" id="cb57-12" data-line-number="12"></a>
<a class="sourceLine" id="cb57-13" data-line-number="13"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb57-14" data-line-number="14">    vec v1;</a>
<a class="sourceLine" id="cb57-15" data-line-number="15">    vec2 v2;</a>
<a class="sourceLine" id="cb57-16" data-line-number="16">    cout &lt;&lt; <span class="kw">sizeof</span>(v1) &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; <span class="kw">sizeof</span>(v2);</a>
<a class="sourceLine" id="cb57-17" data-line-number="17">    <span class="co">// 8 16.</span></a>
<a class="sourceLine" id="cb57-18" data-line-number="18">}</a></code></pre></div>
<p>First, 8 bytes is for the two ints <span class="math inline">\(x,y\)</span>. The extra 8 bytes in <span class="math inline">\(v2\)</span> are for a pointer.</p>
<p>For each class that has virtual methods the compiler creates a table. It is a table of <strong>function pointers</strong>, they point to the implementations of the classes virtual methods. We call this the vtable.</p>
<p>The compiler stores a pointer to the class’ vtable in all objects of that type (at the start). When you call a virtual method, the compiler follows that pointer to the vtable, jumps to the location pointed to be the function pointer in that table.</p>
<h1 id="deadly-diamond-of-death">Deadly Diamond of Death</h1>
<blockquote>
<p>Class B, C inherit from A. Class D inherits from B, C.</p>
</blockquote>
<p>When D calls a function from A, overwritten in B and C, which function gets called? This can be solved with <strong>virtual inheritance</strong> in c++.</p>
<h1 id="templates">Templates</h1>
<ul>
<li>Templates support static polymorphism through duck-typing.</li>
<li>The most specialized version is taken.</li>
</ul>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;</a>
<a class="sourceLine" id="cb58-2" data-line-number="2">T m(<span class="at">const</span> T &amp;x, <span class="at">const</span> T &amp; y) {</a>
<a class="sourceLine" id="cb58-3" data-line-number="3">    <span class="cf">return</span> x &lt; y ? x : y;</a>
<a class="sourceLine" id="cb58-4" data-line-number="4">}</a></code></pre></div>
<p><strong>Note</strong>: No need to specify types when calling templated methods (when those types are deducible). Must always specify for classes.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb59-1" data-line-number="1"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb59-2" data-line-number="2">    <span class="dt">int</span> x = <span class="dv">1</span>, y = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb59-3" data-line-number="3">    cout &lt;&lt; m(x, y); <span class="co">// Compiler deduces type.</span></a>
<a class="sourceLine" id="cb59-4" data-line-number="4">    <span class="dt">short</span> s = <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb59-5" data-line-number="5">    cout &lt;&lt; m(s, <span class="dv">20</span>); <span class="co">// Cannot deduce type.</span></a>
<a class="sourceLine" id="cb59-6" data-line-number="6">    cout &lt;&lt; m(s, x); <span class="co">// Cannot deduce type.</span></a>
<a class="sourceLine" id="cb59-7" data-line-number="7">    cout &lt;&lt; m&lt;<span class="dt">short</span>&gt;(s, <span class="dv">20</span>); <span class="co">// Works. Compiler knows to use implicit conversion.</span></a>
<a class="sourceLine" id="cb59-8" data-line-number="8">}</a></code></pre></div>
<ul>
<li>Templates are just blueprints for the compiler to create full functions / classes once parmeterized.</li>
<li>Most common example of compilers being unable to deduce type is when return type is different than parameter types.</li>
</ul>
<h2 id="variadic-templates">Variadic Templates</h2>
<ul>
<li>Take a variable amount of arguments.</li>
</ul>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb60-1" data-line-number="1"><span class="kw">template</span>&lt;<span class="kw">typename</span> T, <span class="kw">typename</span>... Ts&gt;</a>
<a class="sourceLine" id="cb60-2" data-line-number="2"><span class="co">// &lt;First Argument, Parameter Pack&gt;</span></a>
<a class="sourceLine" id="cb60-3" data-line-number="3"><span class="dt">void</span> print(<span class="at">const</span> T&amp; arg <span class="at">const</span> Ts&amp; ...args) {</a>
<a class="sourceLine" id="cb60-4" data-line-number="4">    print(arg);</a>
<a class="sourceLine" id="cb60-5" data-line-number="5">    print(args...);</a>
<a class="sourceLine" id="cb60-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb60-7" data-line-number="7"></a>
<a class="sourceLine" id="cb60-8" data-line-number="8"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;</a>
<a class="sourceLine" id="cb60-9" data-line-number="9"><span class="dt">void</span> print(<span class="at">const</span> T&amp; arg) {</a>
<a class="sourceLine" id="cb60-10" data-line-number="10">    cout &lt;&lt; arg;</a>
<a class="sourceLine" id="cb60-11" data-line-number="11">}</a></code></pre></div>
<h2 id="class-templates">Class Templates</h2>
<ul>
<li>Header must include definitions of all functions.</li>
</ul>
<h1 id="stl">STL</h1>
<ul>
<li>Generic containers (vector, list, deque, set).</li>
<li>Different kinds of Iterators.</li>
<li>Algorithsm for working over ranges.</li>
<li>Not part of the language, but it <strong>is</strong> defined by the standard, which means a conforming compiler must provide it.</li>
</ul>
<h2 id="containers">Containers</h2>
<ul>
<li>Don’t need to know about what’s inside of them.</li>
<li>Require specific operations to exist on a per container basis.</li>
<li>Mostly limited to construction / assignment operators, comparison.</li>
<li>Define their own Iterators.</li>
</ul>
<h2 id="useful-algorithms">Useful Algorithms</h2>
<ul>
<li>Know nothing about the data structures they operate on.</li>
<li>Have limited requirements on the elements in those data structure.</li>
<li>Operate on ranges via <strong>Iterators</strong>.</li>
</ul>
<h2 id="design-principles">Design Principles</h2>
<ul>
<li>STL uses <strong>value semantics</strong> (copy constructor / assignment, move).</li>
<li>Containers and algorithms highly efficient.</li>
<li>No inheritance in STL, don’t inherit from containers, their methods are not virtual.</li>
</ul>
<h2 id="polymorphic-types-in-containers">Polymorphic Types in Containers</h2>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb61-1" data-line-number="1">vector&lt;Figure&gt; <span class="co">// No, Figure is ABC.</span></a>
<a class="sourceLine" id="cb61-2" data-line-number="2">vector&lt;Figure&amp;&gt; <span class="co">// No, can&#39;t store references in arrays.</span></a>
<a class="sourceLine" id="cb61-3" data-line-number="3">vector&lt;Figure*&gt; <span class="co">// Yes.</span></a>
<a class="sourceLine" id="cb61-4" data-line-number="4">vector&lt;unique_ptr&lt;Figure&gt;&gt; <span class="co">// Yes.</span></a>
<a class="sourceLine" id="cb61-5" data-line-number="5">vector&lt;shared_ptr&lt;Figure&gt;&gt; <span class="co">// Yes.</span></a></code></pre></div>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>Container Type</th>
<th>Details</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Sequence</td>
<td>Have strict ordering based on programmer’s placement.</td>
<td>Vector, deque, list, array</td>
</tr>
<tr class="even">
<td>Associative</td>
<td>Elements are referenced by keys rather than indices. Strict ordering based on the comparator.</td>
<td>Set, map, multiset, multimap</td>
</tr>
<tr class="odd">
<td>Unordered Associative</td>
<td>As above, but with no guarantee on ordering.</td>
<td>Unordered_map, unordered_set, …</td>
</tr>
</tbody>
</table>
<h3 id="sequence-containers">Sequence Containers</h3>
<ul>
<li>Vector &amp; deque allow random access through [] or at().
<ul>
<li>List only allows sequence access through Iterators.</li>
</ul></li>
<li>Deque allows both emplace_front &amp; emplace_back.</li>
<li>List optimized for arbitrary insertion / deletion.</li>
<li>Vector / deque are optimized for random access.</li>
</ul>
<h3 id="associative-containers">Associative Containers</h3>
<ul>
<li>Store your elements in order, requires either the elements stored inside are comparable or use a function object.</li>
</ul>
<h2 id="function-objects">Function Objects</h2>
<ul>
<li>Objects of a type that overloads the function call operator.</li>
<li>Templates take types (or integral values), so we must use a type for our comparator.</li>
</ul>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb62-1" data-line-number="1"><span class="kw">class</span> X {</a>
<a class="sourceLine" id="cb62-2" data-line-number="2"><span class="kw">public</span>:</a>
<a class="sourceLine" id="cb62-3" data-line-number="3">    <span class="dt">int</span> <span class="kw">operator</span>()(<span class="dt">int</span> x, <span class="dt">int</span> y) {</a>
<a class="sourceLine" id="cb62-4" data-line-number="4">        <span class="cf">return</span> x - y + <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb62-5" data-line-number="5">    }</a>
<a class="sourceLine" id="cb62-6" data-line-number="6">};</a></code></pre></div>
<ul>
<li>Function objects can hold state.</li>
</ul>
<h1 id="iterator-invalidation">Iterator Invalidation</h1>
<blockquote>
<p>Any sort of reference to the contents of an STL container can become invalidated with certain operations.</p>
</blockquote>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb63-1" data-line-number="1">vector&lt;<span class="dt">int</span>&gt; v;</a>
<a class="sourceLine" id="cb63-2" data-line-number="2"><span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; ++i) {</a>
<a class="sourceLine" id="cb63-3" data-line-number="3">    v.emplace_back(i);</a>
<a class="sourceLine" id="cb63-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb63-5" data-line-number="5"></a>
<a class="sourceLine" id="cb63-6" data-line-number="6"><span class="kw">auto</span> it = v.begin() + <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb63-7" data-line-number="7"><span class="dt">int</span> &amp;ref = v.at(<span class="dv">4</span>);</a>
<a class="sourceLine" id="cb63-8" data-line-number="8"><span class="dt">int</span> *ptr = &amp;v.at(<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb63-9" data-line-number="9"></a>
<a class="sourceLine" id="cb63-10" data-line-number="10">cout &lt;&lt; *it &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; ref &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; *ptr &lt;&lt; endl;</a>
<a class="sourceLine" id="cb63-11" data-line-number="11"></a>
<a class="sourceLine" id="cb63-12" data-line-number="12"><span class="co">// v will have to resize.</span></a>
<a class="sourceLine" id="cb63-13" data-line-number="13"><span class="cf">for</span> (<span class="dt">size_t</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10000</span>; ++i) {</a>
<a class="sourceLine" id="cb63-14" data-line-number="14">    v.emplace_back(i);</a>
<a class="sourceLine" id="cb63-15" data-line-number="15">}</a>
<a class="sourceLine" id="cb63-16" data-line-number="16"></a>
<a class="sourceLine" id="cb63-17" data-line-number="17"><span class="co">// Undefined behaviour.</span></a>
<a class="sourceLine" id="cb63-18" data-line-number="18">cout &lt;&lt; *it &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; ref &lt;&lt; <span class="st">&quot; &quot;</span> &lt;&lt; *ptr &lt;&lt; endl;</a></code></pre></div>
<h1 id="iterator-types">Iterator Types</h1>
<h2 id="forward-iterator">Forward Iterator</h2>
<h3 id="input-iterator">Input Iterator</h3>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb64-1" data-line-number="1"><span class="kw">operator</span>++</a>
<a class="sourceLine" id="cb64-2" data-line-number="2"><span class="kw">operator</span>!=</a>
<a class="sourceLine" id="cb64-3" data-line-number="3"><span class="co">// On right-hand side of assignment or rvalue contents.</span></a>
<a class="sourceLine" id="cb64-4" data-line-number="4"><span class="kw">operator</span>*</a></code></pre></div>
<h3 id="output-iterator">Output Iterator</h3>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb65-1" data-line-number="1"><span class="kw">operator</span>++</a>
<a class="sourceLine" id="cb65-2" data-line-number="2"><span class="kw">operator</span>!=</a>
<a class="sourceLine" id="cb65-3" data-line-number="3"><span class="co">// On left-hand side of statements.</span></a>
<a class="sourceLine" id="cb65-4" data-line-number="4"><span class="kw">operator</span>*</a></code></pre></div>
<h2 id="bidirectional-iterator">Bidirectional Iterator</h2>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb66-1" data-line-number="1"><span class="kw">operator</span>--</a></code></pre></div>
<h2 id="random-access-iterator">Random Access Iterator</h2>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb67-1" data-line-number="1"><span class="kw">operator</span>+=</a>
<a class="sourceLine" id="cb67-2" data-line-number="2"><span class="kw">operator</span>-=</a>
<a class="sourceLine" id="cb67-3" data-line-number="3"><span class="kw">operator</span>+</a>
<a class="sourceLine" id="cb67-4" data-line-number="4"><span class="kw">operator</span>-</a>
<a class="sourceLine" id="cb67-5" data-line-number="5"><span class="kw">operator</span>[]</a>
<a class="sourceLine" id="cb67-6" data-line-number="6"><span class="kw">operator</span>&lt;</a>
<a class="sourceLine" id="cb67-7" data-line-number="7">...</a></code></pre></div>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb68-1" data-line-number="1"><span class="kw">template</span>&lt;<span class="kw">typename</span> InIter, <span class="kw">typename</span> T&gt;</a>
<a class="sourceLine" id="cb68-2" data-line-number="2">InIter find(InIter first, InIter last, <span class="at">const</span> T &amp;val) {</a>
<a class="sourceLine" id="cb68-3" data-line-number="3">    <span class="co">// Returns an InIter to the first occurance of val in the range [first, last), or last if val not found.</span></a>
<a class="sourceLine" id="cb68-4" data-line-number="4">}</a></code></pre></div>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb69-1" data-line-number="1"><span class="kw">template</span>&lt;<span class="kw">typename</span> InIter, <span class="kw">typename</span> OutIter&gt;</a>
<a class="sourceLine" id="cb69-2" data-line-number="2">OutIter copy(InIter first, InIter last, OutIter dest) {</a>
<a class="sourceLine" id="cb69-3" data-line-number="3">    <span class="co">// Copies items from [first, last) to the location starting at dest.</span></a>
<a class="sourceLine" id="cb69-4" data-line-number="4">    <span class="co">// Container associated with dest must have enough space!</span></a>
<a class="sourceLine" id="cb69-5" data-line-number="5">}</a></code></pre></div>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb70-1" data-line-number="1"><span class="kw">template</span>&lt;<span class="kw">typename</span> InIter, <span class="kw">typename</span> OutIter, <span class="kw">typename</span> Func&gt;</a>
<a class="sourceLine" id="cb70-2" data-line-number="2">OutIter transform(InIter first, InIter last, OutIter result, Func f) {</a>
<a class="sourceLine" id="cb70-3" data-line-number="3">    <span class="cf">while</span> (first != last) {</a>
<a class="sourceLine" id="cb70-4" data-line-number="4">        *result = f(*first);</a>
<a class="sourceLine" id="cb70-5" data-line-number="5">        ++first;</a>
<a class="sourceLine" id="cb70-6" data-line-number="6">        ++result;</a>
<a class="sourceLine" id="cb70-7" data-line-number="7">    }</a>
<a class="sourceLine" id="cb70-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb70-9" data-line-number="9"></a>
<a class="sourceLine" id="cb70-10" data-line-number="10"><span class="dt">int</span> add1(<span class="dt">int</span> n) {</a>
<a class="sourceLine" id="cb70-11" data-line-number="11">    <span class="cf">return</span> n + <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb70-12" data-line-number="12">}</a>
<a class="sourceLine" id="cb70-13" data-line-number="13"></a>
<a class="sourceLine" id="cb70-14" data-line-number="14">vector&lt;<span class="dt">int</span>&gt; v{<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">11</span>};</a>
<a class="sourceLine" id="cb70-15" data-line-number="15">vector&lt;<span class="dt">int</span>&gt; w(v.size());</a>
<a class="sourceLine" id="cb70-16" data-line-number="16"></a>
<a class="sourceLine" id="cb70-17" data-line-number="17">transform(v.begin(), v.end(), w.begin(), add1);</a></code></pre></div>
</body>
</html>
